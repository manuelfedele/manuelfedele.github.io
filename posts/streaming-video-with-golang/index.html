<!doctype html><html lang=en><head><title>Streaming Video With Golang :: Git Push and Run</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Streaming video with Go (Golang) is a popular choice for building efficient and scalable video streaming applications. In this blog post, we&rsquo;ll discuss some of the key concepts and considerations for building a video streaming application with Go.
One of the first things to consider when building a video streaming application is the underlying video format. Go has built-in support for working with a variety of video formats, including MP4, FLV, and AVI. However, the most common format for streaming video is probably H.264, which is a popular choice due to its high compression ratio and wide compatibility with a variety of devices and platforms.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://manuelfedele.github.io/posts/streaming-video-with-golang/><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><link rel=stylesheet href=https://manuelfedele.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://manuelfedele.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://manuelfedele.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://manuelfedele.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://manuelfedele.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://manuelfedele.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://manuelfedele.github.io/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css><link rel=stylesheet href=https://manuelfedele.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css><link rel=stylesheet href=https://manuelfedele.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://manuelfedele.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css><link rel=stylesheet href=https://manuelfedele.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://manuelfedele.github.io/favicon.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Streaming Video With Golang"><meta property="og:description" content="Streaming video with Go (Golang) is a popular choice for building efficient and scalable video streaming applications. In this blog post, we&rsquo;ll discuss some of the key concepts and considerations for building a video streaming application with Go.
One of the first things to consider when building a video streaming application is the underlying video format. Go has built-in support for working with a variety of video formats, including MP4, FLV, and AVI. However, the most common format for streaming video is probably H.264, which is a popular choice due to its high compression ratio and wide compatibility with a variety of devices and platforms.
"><meta property="og:url" content="https://manuelfedele.github.io/posts/streaming-video-with-golang/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:image" content="https://manuelfedele.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2023-01-04 21:23:20 +0100 +0100"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>git push && run</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://manuelfedele.github.io/posts/streaming-video-with-golang/>Streaming Video With Golang</a></h1><div class=post-meta><time class=post-date>2023-01-04</time><span class=post-reading-time>5 min read (1063 words)</span></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/golang/>golang</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/video-streaming/>video streaming</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents></nav></div><div class=post-content><div><p>Streaming video with Go (Golang) is a popular choice for building efficient and scalable video streaming applications. In this blog post, we&rsquo;ll discuss some of the key concepts and considerations for building a video streaming application with Go.</p><p>One of the first things to consider when building a video streaming application is the underlying video format. Go has built-in support for working with a variety of video formats, including MP4, FLV, and AVI. However, the most common format for streaming video is probably H.264, which is a popular choice due to its high compression ratio and wide compatibility with a variety of devices and platforms.</p><p>Another important consideration is the protocol used to deliver the video to the client. The most common protocol for streaming video is probably HTTP-based streaming, such as HLS (HTTP Live Streaming) or DASH (Dynamic Adaptive Streaming over HTTP). These protocols allow the video to be delivered over the HTTP protocol, which is widely supported by web browsers and other client devices.</p><p>To deliver the video using HTTP-based streaming, the server needs to be able to generate and serve the necessary video segments and playlists on-the-fly. Go has a number of libraries and frameworks available that can help with this, such as GStreamer and FFmpeg.</p><p>In addition to the video format and delivery protocol, there are a number of other considerations to keep in mind when building a video streaming application with Go. For example, you&rsquo;ll need to think about things like scalability, reliability, and security. You may also need to consider issues like bandwidth limitations and network latency, which can have a big impact on the user experience.</p><p>Overall, building a video streaming application with Go can be a great choice due to the language&rsquo;s efficiency and scalability. By carefully considering the various factors involved and choosing the right tools and frameworks, it&rsquo;s possible to build a high-quality and reliable video streaming application with Go.</p><p>Why is Go a good candidate?</p><ul><li><p>Go&rsquo;s support for concurrency makes it a good choice for building scalable video streaming applications that can handle a large number of concurrent connections.</p></li><li><p>Go&rsquo;s built-in support for HTTP and other network protocols makes it easy to implement the server-side of a video streaming application. You can use the net/http package to build an HTTP server that serves the video segments and playlists to clients.</p></li><li><p>To generate the video segments and playlists on the fly, you can use a library or framework like GStreamer or FFmpeg. These tools provide a powerful set of APIs for working with video and audio streams, and can be used to transcode, mux, and demux video and audio as needed.</p></li><li><p>When building a video streaming application, it&rsquo;s important to consider issues like scalability, reliability, and security. You may want to use a load balancer to distribute incoming connections across a cluster of servers, and you may want to implement measures like rate limiting and authentication to protect against malicious users.</p></li><li><p>Finally, keep in mind that video streaming applications can be resource-intensive, both in terms of CPU and bandwidth. It&rsquo;s important to optimize your Go code and use tools like caching and compression to minimize the impact on your servers and network.</p></li></ul><p>Here is a simple example of how you might use Go to serve a video file over HTTP:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/video&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>http</span><span class=p>.</span><span class=nf>ServeFile</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>,</span> <span class=s>&#34;myvideo.mp4&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8080&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This code sets up an HTTP server that listens on port 8080, and serves the file myvideo.mp4 whenever a client makes a request to /video. The client can then play the video by opening a URL like http://localhost:8080/video in a web browser or media player.</p><p>Keep in mind that this is just a very basic example, and there are many additional considerations to take into account when building a production-grade video streaming application. For example, you&rsquo;ll likely want to use a more advanced server framework, implement streaming protocols like HLS or DASH, and handle issues like scalability and security.</p><p>Here is an example of how you might use the GStreamer library to generate HLS segments on-the-fly in Go:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/ziutek/gst&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>gst</span><span class=p>.</span><span class=nf>Init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Create a pipeline to read the video file and encode it to H.264</span>
</span></span><span class=line><span class=cl>	<span class=nx>pipeline</span> <span class=o>:=</span> <span class=nx>gst</span><span class=p>.</span><span class=nf>ParseLaunch</span><span class=p>(</span><span class=s>&#34;filesrc location=myvideo.mp4 ! qtdemux ! h264parse ! mpegtsmux ! hlssink target-duration=10 playlist-length=3&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Set up an HTTP server to serve the HLS segments and playlist</span>
</span></span><span class=line><span class=cl>	<span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/video&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>http</span><span class=p>.</span><span class=nf>ServeFile</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>URL</span><span class=p>.</span><span class=nx>Path</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8080&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Run the pipeline</span>
</span></span><span class=line><span class=cl>	<span class=nx>pipeline</span><span class=p>.</span><span class=nf>SetState</span><span class=p>(</span><span class=nx>gst</span><span class=p>.</span><span class=nx>StatePlaying</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Wait for the pipeline to finish</span>
</span></span><span class=line><span class=cl>	<span class=nx>pipeline</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This code sets up an HTTP server that listens on port 8080, and serves the HLS segments and playlist generated by the GStreamer pipeline. The pipeline reads the input video file myvideo.mp4, transcodes it to H.264, and muxes it into MPEG-TS segments using the mpegtsmux element. It then uses the hlssink element to generate an HLS playlist and segments, with a target duration of 10 seconds and a playlist length of 3 segments.</p><p>Last but not least, here is an example of how you might use the FFmpeg library to generate HLS segments on-the-fly in Go:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/griffithsh/go-ffmpeg-cmd&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Set up the FFmpeg command</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span> <span class=o>:=</span> <span class=nx>ffmpeg</span><span class=p>.</span><span class=nf>Command</span><span class=p>(</span><span class=s>&#34;ffmpeg&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Set the input and output options</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nf>Input</span><span class=p>(</span><span class=s>&#34;myvideo.mp4&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nf>Output</span><span class=p>(</span><span class=s>&#34;video.m3u8&#34;</span><span class=p>).</span><span class=nf>Type</span><span class=p>(</span><span class=s>&#34;hls&#34;</span><span class=p>).</span><span class=nf>HlsListSize</span><span class=p>(</span><span class=mi>3</span><span class=p>).</span><span class=nf>HlsSegmentDuration</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Start the command</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>cmd</span><span class=p>.</span><span class=nf>Start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Set up an HTTP server to serve the HLS segments and playlist</span>
</span></span><span class=line><span class=cl>	<span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/video&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>http</span><span class=p>.</span><span class=nf>ServeFile</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>URL</span><span class=p>.</span><span class=nx>Path</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8080&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Wait for the command to finish</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=p>=</span> <span class=nx>cmd</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This code sets up an HTTP server that listens on port 8080, and serves the HLS segments and playlist generated by the FFmpeg command. The command reads the input video file myvideo.mp4 and transcodes it to H.264, generating an HLS playlist and segments with a target duration of 10 seconds and a playlist length of 3 segments.</p><p>To play the video, the client can open a URL like http://localhost:8080/video.m3u8 in a media player that supports HLS, such as VLC or QuickTime.</p><p>Again, keep in mind that this is just a basic example, and there are many additional options and configurations available for the GStreamer or for the FFmpeg command.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://manuelfedele.github.io/posts/what-is-the-difference-between-git-pull-and-git-fetch/ class="button inline prev">&lt; [<span class=button__text>What Is the Difference Between Git Pull and Git Fetch</span>]
</a>::
<a href=https://manuelfedele.github.io/posts/use-protobuf-with-fastapi/ class="button inline next">[<span class=button__text>Use Protobuf With Fastapi</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>