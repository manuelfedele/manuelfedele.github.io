<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ECS Fargate Production Patterns That Actually Work | Git Push and Run</title><meta name=keywords content="AWS,ECS,Fargate,Terraform,Docker,cloud"><meta name=description content="ECS Fargate Production Patterns That Actually Work
I&rsquo;ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.
The Standard Architecture
Every service I deploy follows the same high-level architecture:
Internet/VPC -> ALB (HTTPS, TLS 1.3) -> ECS Fargate -> Aurora PostgreSQL Serverless v2
                 |
                WAF (rate limiting + AWS managed rules)
Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS."><meta name=author content><link rel=canonical href=https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/><link crossorigin=anonymous href=/assets/css/stylesheet.c2189e7d36d72767de292f8b9d897e4a464aa5bc7eb692cda50064f5eb9eeece.css integrity="sha256-whiefTbXJ2feKS+LnYl+SkZKpbx+tpLNpQBk9eue7s4=" rel="preload stylesheet" as=style><link rel=icon href=https://manuelfedele.github.io/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://manuelfedele.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://manuelfedele.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/img/apple-touch-icon-144-precomposed.png><link rel=mask-icon href=https://manuelfedele.github.io/img/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta name=google-site-verification content="bNHRtbwz1iqFFQ60i1jOBm2U7WHWMc8LgejU7wLaDSs"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><meta property="og:url" content="https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:title" content="ECS Fargate Production Patterns That Actually Work"><meta property="og:description" content="ECS Fargate Production Patterns That Actually Work I’ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.
The Standard Architecture Every service I deploy follows the same high-level architecture:
Internet/VPC -> ALB (HTTPS, TLS 1.3) -> ECS Fargate -> Aurora PostgreSQL Serverless v2 | WAF (rate limiting + AWS managed rules) Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-08T14:20:00+01:00"><meta property="article:modified_time" content="2026-01-08T14:20:00+01:00"><meta property="article:tag" content="AWS"><meta property="article:tag" content="ECS"><meta property="article:tag" content="Fargate"><meta property="article:tag" content="Terraform"><meta property="article:tag" content="Docker"><meta property="article:tag" content="Cloud"><meta property="og:image" content="https://manuelfedele.github.io/img/card-pillow.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://manuelfedele.github.io/img/card-pillow.jpg"><meta name=twitter:title content="ECS Fargate Production Patterns That Actually Work"><meta name=twitter:description content="ECS Fargate Production Patterns That Actually Work
I&rsquo;ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.
The Standard Architecture
Every service I deploy follows the same high-level architecture:
Internet/VPC -> ALB (HTTPS, TLS 1.3) -> ECS Fargate -> Aurora PostgreSQL Serverless v2
                 |
                WAF (rate limiting + AWS managed rules)
Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://manuelfedele.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ECS Fargate Production Patterns That Actually Work","item":"https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ECS Fargate Production Patterns That Actually Work","name":"ECS Fargate Production Patterns That Actually Work","description":"ECS Fargate Production Patterns That Actually Work I\u0026rsquo;ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.\nThe Standard Architecture Every service I deploy follows the same high-level architecture:\nInternet/VPC -\u0026gt; ALB (HTTPS, TLS 1.3) -\u0026gt; ECS Fargate -\u0026gt; Aurora PostgreSQL Serverless v2 | WAF (rate limiting + AWS managed rules) Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS.\n","keywords":["AWS","ECS","Fargate","Terraform","Docker","cloud"],"articleBody":"ECS Fargate Production Patterns That Actually Work I’ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.\nThe Standard Architecture Every service I deploy follows the same high-level architecture:\nInternet/VPC -\u003e ALB (HTTPS, TLS 1.3) -\u003e ECS Fargate -\u003e Aurora PostgreSQL Serverless v2 | WAF (rate limiting + AWS managed rules) Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS.\nFargate Spot Strategy Fargate Spot can save up to 70% on compute costs, but you need to handle interruptions. The approach: use a weighted capacity provider strategy that balances cost savings with availability.\nresource \"aws_ecs_cluster\" \"main\" { name = \"${var.service_name}-${var.environment}\" setting { name = \"containerInsights\" value = \"enabled\" } tags = var.tags } resource \"aws_ecs_cluster_capacity_providers\" \"main\" { cluster_name = aws_ecs_cluster.main.name capacity_providers = [\"FARGATE\", \"FARGATE_SPOT\"] default_capacity_provider_strategy { capacity_provider = \"FARGATE_SPOT\" weight = var.spot_weight base = 1 # At least 1 task on regular Fargate } default_capacity_provider_strategy { capacity_provider = \"FARGATE\" weight = var.ondemand_weight } } The base = 1 on FARGATE ensures you always have at least one task running on On-Demand capacity. This is your safety net during Spot interruptions.\nFor non-production, I use a 4:1 Spot-to-OnDemand ratio. For production, I flip it to 1:4, prioritizing stability while still getting some Spot savings.\nDeployment Circuit Breakers ECS deployment circuit breakers automatically roll back failed deployments. Combined with the right health check configuration, they prevent bad deployments from taking down your service:\nresource \"aws_ecs_service\" \"main\" { name = var.service_name cluster = aws_ecs_cluster.main.id task_definition = aws_ecs_task_definition.main.arn desired_count = var.desired_count deployment_circuit_breaker { enable = true rollback = true } deployment_configuration { maximum_percent = 200 minimum_healthy_percent = 100 } load_balancer { target_group_arn = var.target_group_arn container_name = var.service_name container_port = var.container_port } network_configuration { subnets = var.subnet_ids security_groups = [var.security_group_id] assign_public_ip = false } capacity_provider_strategy { capacity_provider = \"FARGATE_SPOT\" weight = var.spot_weight base = 1 } capacity_provider_strategy { capacity_provider = \"FARGATE\" weight = var.ondemand_weight } tags = var.tags } The maximum_percent = 200 with minimum_healthy_percent = 100 means ECS will spin up new tasks before draining old ones (rolling deployment). If the new tasks fail health checks, the circuit breaker kicks in and rolls back.\nHealth Check Configuration Getting health checks right is critical. Too aggressive and you get false positives; too lenient and failed deployments take forever to detect:\nresource \"aws_lb_target_group\" \"main\" { name = \"${var.service_name}-${var.environment}\" port = var.container_port protocol = \"HTTP\" vpc_id = var.vpc_id target_type = \"ip\" health_check { enabled = true path = \"/health\" port = \"traffic-port\" protocol = \"HTTP\" healthy_threshold = 2 unhealthy_threshold = 3 timeout = 10 interval = 30 matcher = \"200\" } deregistration_delay = 30 tags = var.tags } A few things to note:\nderegistration_delay = 30 instead of the default 300 seconds. Most applications can drain in-flight requests in 30 seconds, and the shorter delay means faster deployments. healthy_threshold = 2 means a task needs only 2 successful health checks to be considered healthy (60 seconds with a 30-second interval). unhealthy_threshold = 3 gives tasks 90 seconds of failed health checks before being marked unhealthy. ALB with Path-Based Routing For services with separate frontend and backend containers, path-based routing on a single ALB keeps things simple:\nresource \"aws_lb_listener\" \"https\" { load_balancer_arn = aws_lb.main.arn port = 443 protocol = \"HTTPS\" ssl_policy = \"ELBSecurityPolicy-TLS13-1-2-2021-06\" certificate_arn = var.certificate_arn default_action { type = \"forward\" target_group_arn = aws_lb_target_group.frontend.arn } tags = var.tags } resource \"aws_lb_listener_rule\" \"api\" { listener_arn = aws_lb_listener.https.arn priority = 100 action { type = \"forward\" target_group_arn = aws_lb_target_group.backend.arn } condition { path_pattern { values = [\"/api/*\"] } } tags = var.tags } Note the TLS 1.3 policy. There’s no reason to support older TLS versions for internal services.\nAuto-Scaling ECS services should auto-scale on both CPU and memory. I use target tracking policies:\nresource \"aws_appautoscaling_target\" \"ecs\" { max_capacity = var.max_count min_capacity = var.min_count resource_id = \"service/${aws_ecs_cluster.main.name}/${aws_ecs_service.main.name}\" scalable_dimension = \"ecs:service:DesiredCount\" service_namespace = \"ecs\" } resource \"aws_appautoscaling_policy\" \"cpu\" { name = \"${var.service_name}-cpu-scaling\" policy_type = \"TargetTrackingScaling\" resource_id = aws_appautoscaling_target.ecs.resource_id scalable_dimension = aws_appautoscaling_target.ecs.scalable_dimension service_namespace = aws_appautoscaling_target.ecs.service_namespace target_tracking_scaling_policy_configuration { predefined_metric_specification { predefined_metric_type = \"ECSServiceAverageCPUUtilization\" } target_value = 70.0 scale_in_cooldown = 300 scale_out_cooldown = 60 } } resource \"aws_appautoscaling_policy\" \"memory\" { name = \"${var.service_name}-memory-scaling\" policy_type = \"TargetTrackingScaling\" resource_id = aws_appautoscaling_target.ecs.resource_id scalable_dimension = aws_appautoscaling_target.ecs.scalable_dimension service_namespace = aws_appautoscaling_target.ecs.service_namespace target_tracking_scaling_policy_configuration { predefined_metric_specification { predefined_metric_type = \"ECSServiceAverageMemoryUtilization\" } target_value = 80.0 scale_in_cooldown = 300 scale_out_cooldown = 60 } } The asymmetric cooldowns matter: scale_out_cooldown = 60 means the service reacts quickly to load spikes, while scale_in_cooldown = 300 prevents premature scale-down during bursty traffic.\nMigrating to ARM64 (Graviton) AWS Graviton instances offer ~20% better price-performance than x86. Migrating ECS Fargate tasks to ARM64 is straightforward if your images support it:\n# Multi-arch Dockerfile FROM --platform=$TARGETPLATFORM python:3.12-slim WORKDIR /app COPY requirements.txt . RUN pip install --no-cache-dir -r requirements.txt COPY . . CMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"] Build and push multi-arch images:\ndocker buildx create --use docker buildx build \\ --platform linux/amd64,linux/arm64 \\ -t $ECR_REPO:latest \\ --push . Then update the task definition:\nresource \"aws_ecs_task_definition\" \"main\" { family = var.service_name requires_compatibilities = [\"FARGATE\"] network_mode = \"awsvpc\" cpu = var.cpu memory = var.memory execution_role_arn = var.execution_role_arn task_role_arn = var.task_role_arn runtime_platform { operating_system_family = \"LINUX\" cpu_architecture = \"ARM64\" } container_definitions = jsonencode([{ name = var.service_name image = var.image essential = true portMappings = [{ containerPort = var.container_port protocol = \"tcp\" }] logConfiguration = { logDriver = \"awslogs\" options = { \"awslogs-group\" = var.log_group_name \"awslogs-region\" = var.region \"awslogs-stream-prefix\" = var.service_name } } }]) tags = var.tags } The key line is cpu_architecture = \"ARM64\". That’s it. If your Docker image is multi-arch, Fargate pulls the right architecture automatically.\nSecrets Management Never bake secrets into container images. Use AWS Secrets Manager with ECS native integration:\nresource \"aws_secretsmanager_secret\" \"db_credentials\" { name = \"${var.service_name}/${var.environment}/db-credentials\" tags = var.tags } # In the container definition container_definitions = jsonencode([{ name = var.service_name image = var.image secrets = [ { name = \"DATABASE_URL\" valueFrom = aws_secretsmanager_secret.db_credentials.arn }, { name = \"DJANGO_SECRET_KEY\" valueFrom = \"${aws_secretsmanager_secret.app_secrets.arn}:django_secret_key::\" } ] }]) ECS injects the secret values as environment variables at task startup. The execution role needs secretsmanager:GetSecretValue permission on the specific secret ARNs.\nCloudWatch Logging with Sane Retention Every service gets a log group with a retention policy. Keeping logs forever is expensive and rarely useful:\nresource \"aws_cloudwatch_log_group\" \"main\" { name = \"/ecs/${var.service_name}/${var.environment}\" retention_in_days = 14 tags = var.tags } 14 days is usually enough for debugging. If you need longer retention for compliance, ship logs to S3 or OpenSearch.\nPutting It All Together Here’s the complete pattern for a new service:\nECR repository with lifecycle policy (keep last 10 images) ECS cluster with Container Insights enabled Task definition with ARM64, proper resource limits, secrets injection ECS service with circuit breaker, Spot strategy, auto-scaling ALB with HTTPS (TLS 1.3), path-based routing WAF with rate limiting and AWS managed rules Aurora Serverless v2 with environment-appropriate scaling Route53 private hosted zone record CloudWatch log group with 14-day retention Security groups with three-tier model (ALB -\u003e ECS -\u003e Aurora) Once you have this as a set of Terraform modules, deploying a new service is just composing the modules with service-specific variables. The infrastructure is consistent, secure, and cost-optimized across all environments.\nReferences ECS Fargate Capacity Providers Deployment Circuit Breaker AWS Graviton Getting Started Aurora Serverless v2 ","wordCount":"1250","inLanguage":"en","image":"https://manuelfedele.github.io/img/card-pillow.jpg","datePublished":"2026-01-08T14:20:00+01:00","dateModified":"2026-01-08T14:20:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/"},"publisher":{"@type":"Organization","name":"Git Push and Run","logo":{"@type":"ImageObject","url":"https://manuelfedele.github.io/img/favicon.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://manuelfedele.github.io/ accesskey=h title="Git Push and Run (Alt + H)"><img src=https://manuelfedele.github.io/img/apple-touch-icon-144-precomposed.png alt aria-label=logo height=25>Git Push and Run</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://manuelfedele.github.io/ title=Home><span>Home</span></a></li><li><a href=https://manuelfedele.github.io/search/ title=Search><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://manuelfedele.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://manuelfedele.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">ECS Fargate Production Patterns That Actually Work</h1><div class=post-meta><span title='2026-01-08 14:20:00 +0100 +0100'>January 8, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1250 words</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#the-standard-architecture>The Standard Architecture</a></li><li><a href=#fargate-spot-strategy>Fargate Spot Strategy</a></li><li><a href=#deployment-circuit-breakers>Deployment Circuit Breakers</a></li><li><a href=#health-check-configuration>Health Check Configuration</a></li><li><a href=#alb-with-path-based-routing>ALB with Path-Based Routing</a></li><li><a href=#auto-scaling>Auto-Scaling</a></li><li><a href=#migrating-to-arm64-graviton>Migrating to ARM64 (Graviton)</a></li><li><a href=#secrets-management>Secrets Management</a></li><li><a href=#cloudwatch-logging-with-sane-retention>CloudWatch Logging with Sane Retention</a></li><li><a href=#putting-it-all-together>Putting It All Together</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h1 id=ecs-fargate-production-patterns-that-actually-work>ECS Fargate Production Patterns That Actually Work<a hidden class=anchor aria-hidden=true href=#ecs-fargate-production-patterns-that-actually-work>#</a></h1><p>I&rsquo;ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.</p><h2 id=the-standard-architecture>The Standard Architecture<a hidden class=anchor aria-hidden=true href=#the-standard-architecture>#</a></h2><p>Every service I deploy follows the same high-level architecture:</p><pre tabindex=0><code>Internet/VPC -&gt; ALB (HTTPS, TLS 1.3) -&gt; ECS Fargate -&gt; Aurora PostgreSQL Serverless v2
                 |
                WAF (rate limiting + AWS managed rules)
</code></pre><p>Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS.</p><h2 id=fargate-spot-strategy>Fargate Spot Strategy<a hidden class=anchor aria-hidden=true href=#fargate-spot-strategy>#</a></h2><p>Fargate Spot can save up to 70% on compute costs, but you need to handle interruptions. The approach: use a weighted capacity provider strategy that balances cost savings with availability.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_ecs_cluster&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span> <span class=o>=</span> <span class=s2>&#34;${var.service_name}-${var.environment}&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>setting</span> {
</span></span><span class=line><span class=cl><span class=n>    name</span>  <span class=o>=</span> <span class=s2>&#34;containerInsights&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    value</span> <span class=o>=</span> <span class=s2>&#34;enabled&#34;</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_ecs_cluster_capacity_providers&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  cluster_name</span> <span class=o>=</span> <span class=k>aws_ecs_cluster</span><span class=p>.</span><span class=k>main</span><span class=p>.</span><span class=k>name</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  capacity_providers</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;FARGATE&#34;, &#34;FARGATE_SPOT&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>default_capacity_provider_strategy</span> {
</span></span><span class=line><span class=cl><span class=n>    capacity_provider</span> <span class=o>=</span> <span class=s2>&#34;FARGATE_SPOT&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    weight</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>spot_weight</span>
</span></span><span class=line><span class=cl><span class=n>    base</span>              <span class=o>=</span> <span class=m>1</span><span class=c1>  # At least 1 task on regular Fargate
</span></span></span><span class=line><span class=cl><span class=c1></span>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>default_capacity_provider_strategy</span> {
</span></span><span class=line><span class=cl><span class=n>    capacity_provider</span> <span class=o>=</span> <span class=s2>&#34;FARGATE&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    weight</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>ondemand_weight</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>The <code>base = 1</code> on FARGATE ensures you always have at least one task running on On-Demand capacity. This is your safety net during Spot interruptions.</p><p>For non-production, I use a 4:1 Spot-to-OnDemand ratio. For production, I flip it to 1:4, prioritizing stability while still getting some Spot savings.</p><h2 id=deployment-circuit-breakers>Deployment Circuit Breakers<a hidden class=anchor aria-hidden=true href=#deployment-circuit-breakers>#</a></h2><p>ECS deployment circuit breakers automatically roll back failed deployments. Combined with the right health check configuration, they prevent bad deployments from taking down your service:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_ecs_service&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl><span class=n>  cluster</span>         <span class=o>=</span> <span class=k>aws_ecs_cluster</span><span class=p>.</span><span class=k>main</span><span class=p>.</span><span class=k>id</span>
</span></span><span class=line><span class=cl><span class=n>  task_definition</span> <span class=o>=</span> <span class=k>aws_ecs_task_definition</span><span class=p>.</span><span class=k>main</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl><span class=n>  desired_count</span>   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>desired_count</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>deployment_circuit_breaker</span> {
</span></span><span class=line><span class=cl><span class=n>    enable</span>   <span class=o>=</span> <span class=kt>true</span>
</span></span><span class=line><span class=cl><span class=n>    rollback</span> <span class=o>=</span> <span class=kt>true</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>deployment_configuration</span> {
</span></span><span class=line><span class=cl><span class=n>    maximum_percent</span>         <span class=o>=</span> <span class=m>200</span>
</span></span><span class=line><span class=cl><span class=n>    minimum_healthy_percent</span> <span class=o>=</span> <span class=m>100</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>load_balancer</span> {
</span></span><span class=line><span class=cl><span class=n>    target_group_arn</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>target_group_arn</span>
</span></span><span class=line><span class=cl><span class=n>    container_name</span>   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl><span class=n>    container_port</span>   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>container_port</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>network_configuration</span> {
</span></span><span class=line><span class=cl><span class=n>    subnets</span>          <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>subnet_ids</span>
</span></span><span class=line><span class=cl><span class=n>    security_groups</span>  <span class=o>=</span> <span class=p>[</span><span class=k>var</span><span class=p>.</span><span class=k>security_group_id</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>    assign_public_ip</span> <span class=o>=</span> <span class=kt>false</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>capacity_provider_strategy</span> {
</span></span><span class=line><span class=cl><span class=n>    capacity_provider</span> <span class=o>=</span> <span class=s2>&#34;FARGATE_SPOT&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    weight</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>spot_weight</span>
</span></span><span class=line><span class=cl><span class=n>    base</span>              <span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>capacity_provider_strategy</span> {
</span></span><span class=line><span class=cl><span class=n>    capacity_provider</span> <span class=o>=</span> <span class=s2>&#34;FARGATE&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    weight</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>ondemand_weight</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>The <code>maximum_percent = 200</code> with <code>minimum_healthy_percent = 100</code> means ECS will spin up new tasks before draining old ones (rolling deployment). If the new tasks fail health checks, the circuit breaker kicks in and rolls back.</p><h2 id=health-check-configuration>Health Check Configuration<a hidden class=anchor aria-hidden=true href=#health-check-configuration>#</a></h2><p>Getting health checks right is critical. Too aggressive and you get false positives; too lenient and failed deployments take forever to detect:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_lb_target_group&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span>        <span class=o>=</span> <span class=s2>&#34;${var.service_name}-${var.environment}&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  port</span>        <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>container_port</span>
</span></span><span class=line><span class=cl><span class=n>  protocol</span>    <span class=o>=</span> <span class=s2>&#34;HTTP&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  vpc_id</span>      <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>vpc_id</span>
</span></span><span class=line><span class=cl><span class=n>  target_type</span> <span class=o>=</span> <span class=s2>&#34;ip&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>health_check</span> {
</span></span><span class=line><span class=cl><span class=n>    enabled</span>             <span class=o>=</span> <span class=kt>true</span>
</span></span><span class=line><span class=cl><span class=n>    path</span>                <span class=o>=</span> <span class=s2>&#34;/health&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    port</span>                <span class=o>=</span> <span class=s2>&#34;traffic-port&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    protocol</span>            <span class=o>=</span> <span class=s2>&#34;HTTP&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    healthy_threshold</span>   <span class=o>=</span> <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=n>    unhealthy_threshold</span> <span class=o>=</span> <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=n>    timeout</span>             <span class=o>=</span> <span class=m>10</span>
</span></span><span class=line><span class=cl><span class=n>    interval</span>            <span class=o>=</span> <span class=m>30</span>
</span></span><span class=line><span class=cl><span class=n>    matcher</span>             <span class=o>=</span> <span class=s2>&#34;200&#34;</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  deregistration_delay</span> <span class=o>=</span> <span class=m>30</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>A few things to note:</p><ul><li><strong><code>deregistration_delay = 30</code></strong> instead of the default 300 seconds. Most applications can drain in-flight requests in 30 seconds, and the shorter delay means faster deployments.</li><li><strong><code>healthy_threshold = 2</code></strong> means a task needs only 2 successful health checks to be considered healthy (60 seconds with a 30-second interval).</li><li><strong><code>unhealthy_threshold = 3</code></strong> gives tasks 90 seconds of failed health checks before being marked unhealthy.</li></ul><h2 id=alb-with-path-based-routing>ALB with Path-Based Routing<a hidden class=anchor aria-hidden=true href=#alb-with-path-based-routing>#</a></h2><p>For services with separate frontend and backend containers, path-based routing on a single ALB keeps things simple:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_lb_listener&#34; &#34;https&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  load_balancer_arn</span> <span class=o>=</span> <span class=k>aws_lb</span><span class=p>.</span><span class=k>main</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl><span class=n>  port</span>              <span class=o>=</span> <span class=m>443</span>
</span></span><span class=line><span class=cl><span class=n>  protocol</span>          <span class=o>=</span> <span class=s2>&#34;HTTPS&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  ssl_policy</span>        <span class=o>=</span> <span class=s2>&#34;ELBSecurityPolicy-TLS13-1-2-2021-06&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  certificate_arn</span>   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>certificate_arn</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>default_action</span> {
</span></span><span class=line><span class=cl><span class=n>    type</span>             <span class=o>=</span> <span class=s2>&#34;forward&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    target_group_arn</span> <span class=o>=</span> <span class=k>aws_lb_target_group</span><span class=p>.</span><span class=k>frontend</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_lb_listener_rule&#34; &#34;api&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  listener_arn</span> <span class=o>=</span> <span class=k>aws_lb_listener</span><span class=p>.</span><span class=k>https</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl><span class=n>  priority</span>     <span class=o>=</span> <span class=m>100</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>action</span> {
</span></span><span class=line><span class=cl><span class=n>    type</span>             <span class=o>=</span> <span class=s2>&#34;forward&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    target_group_arn</span> <span class=o>=</span> <span class=k>aws_lb_target_group</span><span class=p>.</span><span class=k>backend</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>condition</span> {
</span></span><span class=line><span class=cl>    <span class=k>path_pattern</span> {
</span></span><span class=line><span class=cl><span class=n>      values</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;/api/*&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>Note the TLS 1.3 policy. There&rsquo;s no reason to support older TLS versions for internal services.</p><h2 id=auto-scaling>Auto-Scaling<a hidden class=anchor aria-hidden=true href=#auto-scaling>#</a></h2><p>ECS services should auto-scale on both CPU and memory. I use target tracking policies:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_appautoscaling_target&#34; &#34;ecs&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  max_capacity</span>       <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>max_count</span>
</span></span><span class=line><span class=cl><span class=n>  min_capacity</span>       <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>min_count</span>
</span></span><span class=line><span class=cl><span class=n>  resource_id</span>        <span class=o>=</span> <span class=s2>&#34;service/${aws_ecs_cluster.main.name}/${aws_ecs_service.main.name}&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  scalable_dimension</span> <span class=o>=</span> <span class=s2>&#34;ecs:service:DesiredCount&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  service_namespace</span>  <span class=o>=</span> <span class=s2>&#34;ecs&#34;</span>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_appautoscaling_policy&#34; &#34;cpu&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span>               <span class=o>=</span> <span class=s2>&#34;${var.service_name}-cpu-scaling&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  policy_type</span>        <span class=o>=</span> <span class=s2>&#34;TargetTrackingScaling&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  resource_id</span>        <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>resource_id</span>
</span></span><span class=line><span class=cl><span class=n>  scalable_dimension</span> <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>scalable_dimension</span>
</span></span><span class=line><span class=cl><span class=n>  service_namespace</span>  <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>service_namespace</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>target_tracking_scaling_policy_configuration</span> {
</span></span><span class=line><span class=cl>    <span class=k>predefined_metric_specification</span> {
</span></span><span class=line><span class=cl><span class=n>      predefined_metric_type</span> <span class=o>=</span> <span class=s2>&#34;ECSServiceAverageCPUUtilization&#34;</span>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl><span class=n>    target_value</span>       <span class=o>=</span> <span class=m>70</span><span class=p>.</span><span class=m>0</span>
</span></span><span class=line><span class=cl><span class=n>    scale_in_cooldown</span>  <span class=o>=</span> <span class=m>300</span>
</span></span><span class=line><span class=cl><span class=n>    scale_out_cooldown</span> <span class=o>=</span> <span class=m>60</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_appautoscaling_policy&#34; &#34;memory&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span>               <span class=o>=</span> <span class=s2>&#34;${var.service_name}-memory-scaling&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  policy_type</span>        <span class=o>=</span> <span class=s2>&#34;TargetTrackingScaling&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  resource_id</span>        <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>resource_id</span>
</span></span><span class=line><span class=cl><span class=n>  scalable_dimension</span> <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>scalable_dimension</span>
</span></span><span class=line><span class=cl><span class=n>  service_namespace</span>  <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>service_namespace</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>target_tracking_scaling_policy_configuration</span> {
</span></span><span class=line><span class=cl>    <span class=k>predefined_metric_specification</span> {
</span></span><span class=line><span class=cl><span class=n>      predefined_metric_type</span> <span class=o>=</span> <span class=s2>&#34;ECSServiceAverageMemoryUtilization&#34;</span>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl><span class=n>    target_value</span>       <span class=o>=</span> <span class=m>80</span><span class=p>.</span><span class=m>0</span>
</span></span><span class=line><span class=cl><span class=n>    scale_in_cooldown</span>  <span class=o>=</span> <span class=m>300</span>
</span></span><span class=line><span class=cl><span class=n>    scale_out_cooldown</span> <span class=o>=</span> <span class=m>60</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>The asymmetric cooldowns matter: <code>scale_out_cooldown = 60</code> means the service reacts quickly to load spikes, while <code>scale_in_cooldown = 300</code> prevents premature scale-down during bursty traffic.</p><h2 id=migrating-to-arm64-graviton>Migrating to ARM64 (Graviton)<a hidden class=anchor aria-hidden=true href=#migrating-to-arm64-graviton>#</a></h2><p>AWS Graviton instances offer ~20% better price-performance than x86. Migrating ECS Fargate tasks to ARM64 is straightforward if your images support it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># Multi-arch Dockerfile</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> --platform=$TARGETPLATFORM python:3.12-slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> requirements.txt .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> pip install --no-cache-dir -r requirements.txt<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;uvicorn&#34;</span><span class=p>,</span> <span class=s2>&#34;main:app&#34;</span><span class=p>,</span> <span class=s2>&#34;--host&#34;</span><span class=p>,</span> <span class=s2>&#34;0.0.0.0&#34;</span><span class=p>,</span> <span class=s2>&#34;--port&#34;</span><span class=p>,</span> <span class=s2>&#34;8000&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>Build and push multi-arch images:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker buildx create --use
</span></span><span class=line><span class=cl>docker buildx build <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --platform linux/amd64,linux/arm64 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -t <span class=nv>$ECR_REPO</span>:latest <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --push .
</span></span></code></pre></div><p>Then update the task definition:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_ecs_task_definition&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  family</span>                   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl><span class=n>  requires_compatibilities</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;FARGATE&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>  network_mode</span>             <span class=o>=</span> <span class=s2>&#34;awsvpc&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  cpu</span>                      <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>cpu</span>
</span></span><span class=line><span class=cl><span class=n>  memory</span>                   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>memory</span>
</span></span><span class=line><span class=cl><span class=n>  execution_role_arn</span>       <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>execution_role_arn</span>
</span></span><span class=line><span class=cl><span class=n>  task_role_arn</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>task_role_arn</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>runtime_platform</span> {
</span></span><span class=line><span class=cl><span class=n>    operating_system_family</span> <span class=o>=</span> <span class=s2>&#34;LINUX&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    cpu_architecture</span>        <span class=o>=</span> <span class=s2>&#34;ARM64&#34;</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  container_definitions</span> <span class=o>=</span> <span class=k>jsonencode</span><span class=p>([</span>{
</span></span><span class=line><span class=cl><span class=n>    name</span>      <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl><span class=n>    image</span>     <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>image</span>
</span></span><span class=line><span class=cl><span class=n>    essential</span> <span class=o>=</span> <span class=kt>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>    portMappings</span> <span class=o>=</span> <span class=p>[</span>{
</span></span><span class=line><span class=cl><span class=n>      containerPort</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>container_port</span>
</span></span><span class=line><span class=cl><span class=n>      protocol</span>      <span class=o>=</span> <span class=s2>&#34;tcp&#34;</span>
</span></span><span class=line><span class=cl>    }<span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>    logConfiguration</span> <span class=o>=</span> {
</span></span><span class=line><span class=cl><span class=n>      logDriver</span> <span class=o>=</span> <span class=s2>&#34;awslogs&#34;</span>
</span></span><span class=line><span class=cl><span class=n>      options</span> <span class=o>=</span> {
</span></span><span class=line><span class=cl><span class=n>        &#34;awslogs-group&#34;</span>         <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>log_group_name</span>
</span></span><span class=line><span class=cl><span class=n>        &#34;awslogs-region&#34;</span>        <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>region</span>
</span></span><span class=line><span class=cl><span class=n>        &#34;awslogs-stream-prefix&#34;</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>  }<span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>The key line is <code>cpu_architecture = "ARM64"</code>. That&rsquo;s it. If your Docker image is multi-arch, Fargate pulls the right architecture automatically.</p><h2 id=secrets-management>Secrets Management<a hidden class=anchor aria-hidden=true href=#secrets-management>#</a></h2><p>Never bake secrets into container images. Use AWS Secrets Manager with ECS native integration:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_secretsmanager_secret&#34; &#34;db_credentials&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span> <span class=o>=</span> <span class=s2>&#34;${var.service_name}/${var.environment}/db-credentials&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}<span class=c1>
</span></span></span><span class=line><span class=cl><span class=c1>
</span></span></span><span class=line><span class=cl><span class=c1># In the container definition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>container_definitions</span> <span class=o>=</span> <span class=k>jsonencode</span><span class=p>([</span>{
</span></span><span class=line><span class=cl><span class=n>  name</span>  <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl><span class=n>  image</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>image</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  secrets</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl><span class=n>      name</span>      <span class=o>=</span> <span class=s2>&#34;DATABASE_URL&#34;</span>
</span></span><span class=line><span class=cl><span class=n>      valueFrom</span> <span class=o>=</span> <span class=k>aws_secretsmanager_secret</span><span class=p>.</span><span class=k>db_credentials</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl>    }<span class=p>,</span>
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl><span class=n>      name</span>      <span class=o>=</span> <span class=s2>&#34;DJANGO_SECRET_KEY&#34;</span>
</span></span><span class=line><span class=cl><span class=n>      valueFrom</span> <span class=o>=</span> <span class=s2>&#34;${aws_secretsmanager_secret.app_secrets.arn}:django_secret_key::&#34;</span>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl>}<span class=p>])</span>
</span></span></code></pre></div><p>ECS injects the secret values as environment variables at task startup. The execution role needs <code>secretsmanager:GetSecretValue</code> permission on the specific secret ARNs.</p><h2 id=cloudwatch-logging-with-sane-retention>CloudWatch Logging with Sane Retention<a hidden class=anchor aria-hidden=true href=#cloudwatch-logging-with-sane-retention>#</a></h2><p>Every service gets a log group with a retention policy. Keeping logs forever is expensive and rarely useful:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_cloudwatch_log_group&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span>              <span class=o>=</span> <span class=s2>&#34;/ecs/${var.service_name}/${var.environment}&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  retention_in_days</span> <span class=o>=</span> <span class=m>14</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>14 days is usually enough for debugging. If you need longer retention for compliance, ship logs to S3 or OpenSearch.</p><h2 id=putting-it-all-together>Putting It All Together<a hidden class=anchor aria-hidden=true href=#putting-it-all-together>#</a></h2><p>Here&rsquo;s the complete pattern for a new service:</p><ol><li><strong>ECR repository</strong> with lifecycle policy (keep last 10 images)</li><li><strong>ECS cluster</strong> with Container Insights enabled</li><li><strong>Task definition</strong> with ARM64, proper resource limits, secrets injection</li><li><strong>ECS service</strong> with circuit breaker, Spot strategy, auto-scaling</li><li><strong>ALB</strong> with HTTPS (TLS 1.3), path-based routing</li><li><strong>WAF</strong> with rate limiting and AWS managed rules</li><li><strong>Aurora Serverless v2</strong> with environment-appropriate scaling</li><li><strong>Route53</strong> private hosted zone record</li><li><strong>CloudWatch</strong> log group with 14-day retention</li><li><strong>Security groups</strong> with three-tier model (ALB -> ECS -> Aurora)</li></ol><p>Once you have this as a set of Terraform modules, deploying a new service is just composing the modules with service-specific variables. The infrastructure is consistent, secure, and cost-optimized across all environments.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://docs.aws.amazon.com/AmazonECS/latest/developerguide/fargate-capacity-providers.html>ECS Fargate Capacity Providers</a></li><li><a href=https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html>Deployment Circuit Breaker</a></li><li><a href=https://github.com/aws/aws-graviton-getting-started>AWS Graviton Getting Started</a></li><li><a href=https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.html>Aurora Serverless v2</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://manuelfedele.github.io/tags/aws/>AWS</a></li><li><a href=https://manuelfedele.github.io/tags/ecs/>ECS</a></li><li><a href=https://manuelfedele.github.io/tags/fargate/>Fargate</a></li><li><a href=https://manuelfedele.github.io/tags/terraform/>Terraform</a></li><li><a href=https://manuelfedele.github.io/tags/docker/>Docker</a></li><li><a href=https://manuelfedele.github.io/tags/cloud/>Cloud</a></li></ul><nav class=paginav><a class=prev href=https://manuelfedele.github.io/posts/building-ai-powered-platform-operations-agent/><span class=title>« Prev</span><br><span>Building an AI-Powered Platform Operations Agent</span>
</a><a class=next href=https://manuelfedele.github.io/posts/building-ai-document-processing-pipeline-aws/><span class=title>Next »</span><br><span>Building an AI-Powered Document Processing Pipeline on AWS</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ECS Fargate Production Patterns That Actually Work on x" href="https://x.com/intent/tweet/?text=ECS%20Fargate%20Production%20Patterns%20That%20Actually%20Work&amp;url=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fecs-fargate-production-patterns%2f&amp;hashtags=AWS%2cECS%2cFargate%2cTerraform%2cDocker%2ccloud"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ECS Fargate Production Patterns That Actually Work on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fecs-fargate-production-patterns%2f&amp;title=ECS%20Fargate%20Production%20Patterns%20That%20Actually%20Work&amp;summary=ECS%20Fargate%20Production%20Patterns%20That%20Actually%20Work&amp;source=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fecs-fargate-production-patterns%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ECS Fargate Production Patterns That Actually Work on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fecs-fargate-production-patterns%2f&title=ECS%20Fargate%20Production%20Patterns%20That%20Actually%20Work"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ECS Fargate Production Patterns That Actually Work on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fecs-fargate-production-patterns%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ECS Fargate Production Patterns That Actually Work on whatsapp" href="https://api.whatsapp.com/send?text=ECS%20Fargate%20Production%20Patterns%20That%20Actually%20Work%20-%20https%3a%2f%2fmanuelfedele.github.io%2fposts%2fecs-fargate-production-patterns%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ECS Fargate Production Patterns That Actually Work on telegram" href="https://telegram.me/share/url?text=ECS%20Fargate%20Production%20Patterns%20That%20Actually%20Work&amp;url=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fecs-fargate-production-patterns%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ECS Fargate Production Patterns That Actually Work on ycombinator" href="https://news.ycombinator.com/submitlink?t=ECS%20Fargate%20Production%20Patterns%20That%20Actually%20Work&u=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fecs-fargate-production-patterns%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//manuelfedele-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://manuelfedele.github.io/>Git Push and Run</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>