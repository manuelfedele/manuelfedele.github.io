<!doctype html><html lang=en><head><title>ECS Fargate Production Patterns That Actually Work :: Git Push and Run</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="ECS Fargate Production Patterns That Actually Work I&rsquo;ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.
The Standard Architecture Every service I deploy follows the same high-level architecture:
Internet/VPC -> ALB (HTTPS, TLS 1.3) -> ECS Fargate -> Aurora PostgreSQL Serverless v2 | WAF (rate limiting + AWS managed rules) Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><link rel=stylesheet href=https://manuelfedele.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://manuelfedele.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://manuelfedele.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://manuelfedele.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://manuelfedele.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://manuelfedele.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://manuelfedele.github.io/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css><link rel=stylesheet href=https://manuelfedele.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css><link rel=stylesheet href=https://manuelfedele.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://manuelfedele.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css><link rel=stylesheet href=https://manuelfedele.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://manuelfedele.github.io/favicon.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="ECS Fargate Production Patterns That Actually Work"><meta property="og:description" content="ECS Fargate Production Patterns That Actually Work I&rsquo;ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.
The Standard Architecture Every service I deploy follows the same high-level architecture:
Internet/VPC -> ALB (HTTPS, TLS 1.3) -> ECS Fargate -> Aurora PostgreSQL Serverless v2 | WAF (rate limiting + AWS managed rules) Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS.
"><meta property="og:url" content="https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:image" content="https://manuelfedele.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2026-01-08 14:20:00 +0100 +0100"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>git push && run</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/>ECS Fargate Production Patterns That Actually Work</a></h1><div class=post-meta><time class=post-date>2026-01-08</time><span class=post-reading-time>6 min read (1250 words)</span></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/ecs/>ECS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/fargate/>Fargate</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/terraform/>Terraform</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/docker/>Docker</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/cloud/>cloud</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#the-standard-architecture>The Standard Architecture</a></li><li><a href=#fargate-spot-strategy>Fargate Spot Strategy</a></li><li><a href=#deployment-circuit-breakers>Deployment Circuit Breakers</a></li><li><a href=#health-check-configuration>Health Check Configuration</a></li><li><a href=#alb-with-path-based-routing>ALB with Path-Based Routing</a></li><li><a href=#auto-scaling>Auto-Scaling</a></li><li><a href=#migrating-to-arm64-graviton>Migrating to ARM64 (Graviton)</a></li><li><a href=#secrets-management>Secrets Management</a></li><li><a href=#cloudwatch-logging-with-sane-retention>CloudWatch Logging with Sane Retention</a></li><li><a href=#putting-it-all-together>Putting It All Together</a></li><li><a href=#references>References</a></li></ul></nav></div><div class=post-content><div><h1 id=ecs-fargate-production-patterns-that-actually-work>ECS Fargate Production Patterns That Actually Work<a href=#ecs-fargate-production-patterns-that-actually-work class=hanchor arialabel=Anchor>#</a></h1><p>I&rsquo;ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.</p><h2 id=the-standard-architecture>The Standard Architecture<a href=#the-standard-architecture class=hanchor arialabel=Anchor>#</a></h2><p>Every service I deploy follows the same high-level architecture:</p><pre tabindex=0><code>Internet/VPC -&gt; ALB (HTTPS, TLS 1.3) -&gt; ECS Fargate -&gt; Aurora PostgreSQL Serverless v2
                 |
                WAF (rate limiting + AWS managed rules)
</code></pre><p>Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS.</p><h2 id=fargate-spot-strategy>Fargate Spot Strategy<a href=#fargate-spot-strategy class=hanchor arialabel=Anchor>#</a></h2><p>Fargate Spot can save up to 70% on compute costs, but you need to handle interruptions. The approach: use a weighted capacity provider strategy that balances cost savings with availability.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_ecs_cluster&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span> <span class=o>=</span> <span class=s2>&#34;${var.service_name}-${var.environment}&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>setting</span> {
</span></span><span class=line><span class=cl><span class=n>    name</span>  <span class=o>=</span> <span class=s2>&#34;containerInsights&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    value</span> <span class=o>=</span> <span class=s2>&#34;enabled&#34;</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_ecs_cluster_capacity_providers&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  cluster_name</span> <span class=o>=</span> <span class=k>aws_ecs_cluster</span><span class=p>.</span><span class=k>main</span><span class=p>.</span><span class=k>name</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  capacity_providers</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;FARGATE&#34;, &#34;FARGATE_SPOT&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>default_capacity_provider_strategy</span> {
</span></span><span class=line><span class=cl><span class=n>    capacity_provider</span> <span class=o>=</span> <span class=s2>&#34;FARGATE_SPOT&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    weight</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>spot_weight</span>
</span></span><span class=line><span class=cl><span class=n>    base</span>              <span class=o>=</span> <span class=m>1</span><span class=c1>  # At least 1 task on regular Fargate
</span></span></span><span class=line><span class=cl><span class=c1></span>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>default_capacity_provider_strategy</span> {
</span></span><span class=line><span class=cl><span class=n>    capacity_provider</span> <span class=o>=</span> <span class=s2>&#34;FARGATE&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    weight</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>ondemand_weight</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>The <code>base = 1</code> on FARGATE ensures you always have at least one task running on On-Demand capacity. This is your safety net during Spot interruptions.</p><p>For non-production, I use a 4:1 Spot-to-OnDemand ratio. For production, I flip it to 1:4, prioritizing stability while still getting some Spot savings.</p><h2 id=deployment-circuit-breakers>Deployment Circuit Breakers<a href=#deployment-circuit-breakers class=hanchor arialabel=Anchor>#</a></h2><p>ECS deployment circuit breakers automatically roll back failed deployments. Combined with the right health check configuration, they prevent bad deployments from taking down your service:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_ecs_service&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl><span class=n>  cluster</span>         <span class=o>=</span> <span class=k>aws_ecs_cluster</span><span class=p>.</span><span class=k>main</span><span class=p>.</span><span class=k>id</span>
</span></span><span class=line><span class=cl><span class=n>  task_definition</span> <span class=o>=</span> <span class=k>aws_ecs_task_definition</span><span class=p>.</span><span class=k>main</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl><span class=n>  desired_count</span>   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>desired_count</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>deployment_circuit_breaker</span> {
</span></span><span class=line><span class=cl><span class=n>    enable</span>   <span class=o>=</span> <span class=kt>true</span>
</span></span><span class=line><span class=cl><span class=n>    rollback</span> <span class=o>=</span> <span class=kt>true</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>deployment_configuration</span> {
</span></span><span class=line><span class=cl><span class=n>    maximum_percent</span>         <span class=o>=</span> <span class=m>200</span>
</span></span><span class=line><span class=cl><span class=n>    minimum_healthy_percent</span> <span class=o>=</span> <span class=m>100</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>load_balancer</span> {
</span></span><span class=line><span class=cl><span class=n>    target_group_arn</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>target_group_arn</span>
</span></span><span class=line><span class=cl><span class=n>    container_name</span>   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl><span class=n>    container_port</span>   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>container_port</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>network_configuration</span> {
</span></span><span class=line><span class=cl><span class=n>    subnets</span>          <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>subnet_ids</span>
</span></span><span class=line><span class=cl><span class=n>    security_groups</span>  <span class=o>=</span> <span class=p>[</span><span class=k>var</span><span class=p>.</span><span class=k>security_group_id</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>    assign_public_ip</span> <span class=o>=</span> <span class=kt>false</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>capacity_provider_strategy</span> {
</span></span><span class=line><span class=cl><span class=n>    capacity_provider</span> <span class=o>=</span> <span class=s2>&#34;FARGATE_SPOT&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    weight</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>spot_weight</span>
</span></span><span class=line><span class=cl><span class=n>    base</span>              <span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>capacity_provider_strategy</span> {
</span></span><span class=line><span class=cl><span class=n>    capacity_provider</span> <span class=o>=</span> <span class=s2>&#34;FARGATE&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    weight</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>ondemand_weight</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>The <code>maximum_percent = 200</code> with <code>minimum_healthy_percent = 100</code> means ECS will spin up new tasks before draining old ones (rolling deployment). If the new tasks fail health checks, the circuit breaker kicks in and rolls back.</p><h2 id=health-check-configuration>Health Check Configuration<a href=#health-check-configuration class=hanchor arialabel=Anchor>#</a></h2><p>Getting health checks right is critical. Too aggressive and you get false positives; too lenient and failed deployments take forever to detect:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_lb_target_group&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span>        <span class=o>=</span> <span class=s2>&#34;${var.service_name}-${var.environment}&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  port</span>        <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>container_port</span>
</span></span><span class=line><span class=cl><span class=n>  protocol</span>    <span class=o>=</span> <span class=s2>&#34;HTTP&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  vpc_id</span>      <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>vpc_id</span>
</span></span><span class=line><span class=cl><span class=n>  target_type</span> <span class=o>=</span> <span class=s2>&#34;ip&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>health_check</span> {
</span></span><span class=line><span class=cl><span class=n>    enabled</span>             <span class=o>=</span> <span class=kt>true</span>
</span></span><span class=line><span class=cl><span class=n>    path</span>                <span class=o>=</span> <span class=s2>&#34;/health&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    port</span>                <span class=o>=</span> <span class=s2>&#34;traffic-port&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    protocol</span>            <span class=o>=</span> <span class=s2>&#34;HTTP&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    healthy_threshold</span>   <span class=o>=</span> <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=n>    unhealthy_threshold</span> <span class=o>=</span> <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=n>    timeout</span>             <span class=o>=</span> <span class=m>10</span>
</span></span><span class=line><span class=cl><span class=n>    interval</span>            <span class=o>=</span> <span class=m>30</span>
</span></span><span class=line><span class=cl><span class=n>    matcher</span>             <span class=o>=</span> <span class=s2>&#34;200&#34;</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  deregistration_delay</span> <span class=o>=</span> <span class=m>30</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>A few things to note:</p><ul><li><strong><code>deregistration_delay = 30</code></strong> instead of the default 300 seconds. Most applications can drain in-flight requests in 30 seconds, and the shorter delay means faster deployments.</li><li><strong><code>healthy_threshold = 2</code></strong> means a task needs only 2 successful health checks to be considered healthy (60 seconds with a 30-second interval).</li><li><strong><code>unhealthy_threshold = 3</code></strong> gives tasks 90 seconds of failed health checks before being marked unhealthy.</li></ul><h2 id=alb-with-path-based-routing>ALB with Path-Based Routing<a href=#alb-with-path-based-routing class=hanchor arialabel=Anchor>#</a></h2><p>For services with separate frontend and backend containers, path-based routing on a single ALB keeps things simple:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_lb_listener&#34; &#34;https&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  load_balancer_arn</span> <span class=o>=</span> <span class=k>aws_lb</span><span class=p>.</span><span class=k>main</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl><span class=n>  port</span>              <span class=o>=</span> <span class=m>443</span>
</span></span><span class=line><span class=cl><span class=n>  protocol</span>          <span class=o>=</span> <span class=s2>&#34;HTTPS&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  ssl_policy</span>        <span class=o>=</span> <span class=s2>&#34;ELBSecurityPolicy-TLS13-1-2-2021-06&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  certificate_arn</span>   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>certificate_arn</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>default_action</span> {
</span></span><span class=line><span class=cl><span class=n>    type</span>             <span class=o>=</span> <span class=s2>&#34;forward&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    target_group_arn</span> <span class=o>=</span> <span class=k>aws_lb_target_group</span><span class=p>.</span><span class=k>frontend</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_lb_listener_rule&#34; &#34;api&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  listener_arn</span> <span class=o>=</span> <span class=k>aws_lb_listener</span><span class=p>.</span><span class=k>https</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl><span class=n>  priority</span>     <span class=o>=</span> <span class=m>100</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>action</span> {
</span></span><span class=line><span class=cl><span class=n>    type</span>             <span class=o>=</span> <span class=s2>&#34;forward&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    target_group_arn</span> <span class=o>=</span> <span class=k>aws_lb_target_group</span><span class=p>.</span><span class=k>backend</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>condition</span> {
</span></span><span class=line><span class=cl>    <span class=k>path_pattern</span> {
</span></span><span class=line><span class=cl><span class=n>      values</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;/api/*&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>Note the TLS 1.3 policy. There&rsquo;s no reason to support older TLS versions for internal services.</p><h2 id=auto-scaling>Auto-Scaling<a href=#auto-scaling class=hanchor arialabel=Anchor>#</a></h2><p>ECS services should auto-scale on both CPU and memory. I use target tracking policies:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_appautoscaling_target&#34; &#34;ecs&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  max_capacity</span>       <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>max_count</span>
</span></span><span class=line><span class=cl><span class=n>  min_capacity</span>       <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>min_count</span>
</span></span><span class=line><span class=cl><span class=n>  resource_id</span>        <span class=o>=</span> <span class=s2>&#34;service/${aws_ecs_cluster.main.name}/${aws_ecs_service.main.name}&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  scalable_dimension</span> <span class=o>=</span> <span class=s2>&#34;ecs:service:DesiredCount&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  service_namespace</span>  <span class=o>=</span> <span class=s2>&#34;ecs&#34;</span>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_appautoscaling_policy&#34; &#34;cpu&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span>               <span class=o>=</span> <span class=s2>&#34;${var.service_name}-cpu-scaling&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  policy_type</span>        <span class=o>=</span> <span class=s2>&#34;TargetTrackingScaling&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  resource_id</span>        <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>resource_id</span>
</span></span><span class=line><span class=cl><span class=n>  scalable_dimension</span> <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>scalable_dimension</span>
</span></span><span class=line><span class=cl><span class=n>  service_namespace</span>  <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>service_namespace</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>target_tracking_scaling_policy_configuration</span> {
</span></span><span class=line><span class=cl>    <span class=k>predefined_metric_specification</span> {
</span></span><span class=line><span class=cl><span class=n>      predefined_metric_type</span> <span class=o>=</span> <span class=s2>&#34;ECSServiceAverageCPUUtilization&#34;</span>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl><span class=n>    target_value</span>       <span class=o>=</span> <span class=m>70</span><span class=p>.</span><span class=m>0</span>
</span></span><span class=line><span class=cl><span class=n>    scale_in_cooldown</span>  <span class=o>=</span> <span class=m>300</span>
</span></span><span class=line><span class=cl><span class=n>    scale_out_cooldown</span> <span class=o>=</span> <span class=m>60</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_appautoscaling_policy&#34; &#34;memory&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span>               <span class=o>=</span> <span class=s2>&#34;${var.service_name}-memory-scaling&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  policy_type</span>        <span class=o>=</span> <span class=s2>&#34;TargetTrackingScaling&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  resource_id</span>        <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>resource_id</span>
</span></span><span class=line><span class=cl><span class=n>  scalable_dimension</span> <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>scalable_dimension</span>
</span></span><span class=line><span class=cl><span class=n>  service_namespace</span>  <span class=o>=</span> <span class=k>aws_appautoscaling_target</span><span class=p>.</span><span class=k>ecs</span><span class=p>.</span><span class=k>service_namespace</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>target_tracking_scaling_policy_configuration</span> {
</span></span><span class=line><span class=cl>    <span class=k>predefined_metric_specification</span> {
</span></span><span class=line><span class=cl><span class=n>      predefined_metric_type</span> <span class=o>=</span> <span class=s2>&#34;ECSServiceAverageMemoryUtilization&#34;</span>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl><span class=n>    target_value</span>       <span class=o>=</span> <span class=m>80</span><span class=p>.</span><span class=m>0</span>
</span></span><span class=line><span class=cl><span class=n>    scale_in_cooldown</span>  <span class=o>=</span> <span class=m>300</span>
</span></span><span class=line><span class=cl><span class=n>    scale_out_cooldown</span> <span class=o>=</span> <span class=m>60</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>The asymmetric cooldowns matter: <code>scale_out_cooldown = 60</code> means the service reacts quickly to load spikes, while <code>scale_in_cooldown = 300</code> prevents premature scale-down during bursty traffic.</p><h2 id=migrating-to-arm64-graviton>Migrating to ARM64 (Graviton)<a href=#migrating-to-arm64-graviton class=hanchor arialabel=Anchor>#</a></h2><p>AWS Graviton instances offer ~20% better price-performance than x86. Migrating ECS Fargate tasks to ARM64 is straightforward if your images support it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># Multi-arch Dockerfile</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> --platform=$TARGETPLATFORM python:3.12-slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> requirements.txt .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> pip install --no-cache-dir -r requirements.txt<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;uvicorn&#34;</span><span class=p>,</span> <span class=s2>&#34;main:app&#34;</span><span class=p>,</span> <span class=s2>&#34;--host&#34;</span><span class=p>,</span> <span class=s2>&#34;0.0.0.0&#34;</span><span class=p>,</span> <span class=s2>&#34;--port&#34;</span><span class=p>,</span> <span class=s2>&#34;8000&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>Build and push multi-arch images:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker buildx create --use
</span></span><span class=line><span class=cl>docker buildx build <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --platform linux/amd64,linux/arm64 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -t <span class=nv>$ECR_REPO</span>:latest <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --push .
</span></span></code></pre></div><p>Then update the task definition:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_ecs_task_definition&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  family</span>                   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl><span class=n>  requires_compatibilities</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;FARGATE&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>  network_mode</span>             <span class=o>=</span> <span class=s2>&#34;awsvpc&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  cpu</span>                      <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>cpu</span>
</span></span><span class=line><span class=cl><span class=n>  memory</span>                   <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>memory</span>
</span></span><span class=line><span class=cl><span class=n>  execution_role_arn</span>       <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>execution_role_arn</span>
</span></span><span class=line><span class=cl><span class=n>  task_role_arn</span>            <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>task_role_arn</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>runtime_platform</span> {
</span></span><span class=line><span class=cl><span class=n>    operating_system_family</span> <span class=o>=</span> <span class=s2>&#34;LINUX&#34;</span>
</span></span><span class=line><span class=cl><span class=n>    cpu_architecture</span>        <span class=o>=</span> <span class=s2>&#34;ARM64&#34;</span>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  container_definitions</span> <span class=o>=</span> <span class=k>jsonencode</span><span class=p>([</span>{
</span></span><span class=line><span class=cl><span class=n>    name</span>      <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl><span class=n>    image</span>     <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>image</span>
</span></span><span class=line><span class=cl><span class=n>    essential</span> <span class=o>=</span> <span class=kt>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>    portMappings</span> <span class=o>=</span> <span class=p>[</span>{
</span></span><span class=line><span class=cl><span class=n>      containerPort</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>container_port</span>
</span></span><span class=line><span class=cl><span class=n>      protocol</span>      <span class=o>=</span> <span class=s2>&#34;tcp&#34;</span>
</span></span><span class=line><span class=cl>    }<span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>    logConfiguration</span> <span class=o>=</span> {
</span></span><span class=line><span class=cl><span class=n>      logDriver</span> <span class=o>=</span> <span class=s2>&#34;awslogs&#34;</span>
</span></span><span class=line><span class=cl><span class=n>      options</span> <span class=o>=</span> {
</span></span><span class=line><span class=cl><span class=n>        &#34;awslogs-group&#34;</span>         <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>log_group_name</span>
</span></span><span class=line><span class=cl><span class=n>        &#34;awslogs-region&#34;</span>        <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>region</span>
</span></span><span class=line><span class=cl><span class=n>        &#34;awslogs-stream-prefix&#34;</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>  }<span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>The key line is <code>cpu_architecture = "ARM64"</code>. That&rsquo;s it. If your Docker image is multi-arch, Fargate pulls the right architecture automatically.</p><h2 id=secrets-management>Secrets Management<a href=#secrets-management class=hanchor arialabel=Anchor>#</a></h2><p>Never bake secrets into container images. Use AWS Secrets Manager with ECS native integration:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_secretsmanager_secret&#34; &#34;db_credentials&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span> <span class=o>=</span> <span class=s2>&#34;${var.service_name}/${var.environment}/db-credentials&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}<span class=c1>
</span></span></span><span class=line><span class=cl><span class=c1>
</span></span></span><span class=line><span class=cl><span class=c1># In the container definition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>container_definitions</span> <span class=o>=</span> <span class=k>jsonencode</span><span class=p>([</span>{
</span></span><span class=line><span class=cl><span class=n>  name</span>  <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>service_name</span>
</span></span><span class=line><span class=cl><span class=n>  image</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>image</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  secrets</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl><span class=n>      name</span>      <span class=o>=</span> <span class=s2>&#34;DATABASE_URL&#34;</span>
</span></span><span class=line><span class=cl><span class=n>      valueFrom</span> <span class=o>=</span> <span class=k>aws_secretsmanager_secret</span><span class=p>.</span><span class=k>db_credentials</span><span class=p>.</span><span class=k>arn</span>
</span></span><span class=line><span class=cl>    }<span class=p>,</span>
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl><span class=n>      name</span>      <span class=o>=</span> <span class=s2>&#34;DJANGO_SECRET_KEY&#34;</span>
</span></span><span class=line><span class=cl><span class=n>      valueFrom</span> <span class=o>=</span> <span class=s2>&#34;${aws_secretsmanager_secret.app_secrets.arn}:django_secret_key::&#34;</span>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl>}<span class=p>])</span>
</span></span></code></pre></div><p>ECS injects the secret values as environment variables at task startup. The execution role needs <code>secretsmanager:GetSecretValue</code> permission on the specific secret ARNs.</p><h2 id=cloudwatch-logging-with-sane-retention>CloudWatch Logging with Sane Retention<a href=#cloudwatch-logging-with-sane-retention class=hanchor arialabel=Anchor>#</a></h2><p>Every service gets a log group with a retention policy. Keeping logs forever is expensive and rarely useful:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>resource</span> <span class=s2>&#34;aws_cloudwatch_log_group&#34; &#34;main&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  name</span>              <span class=o>=</span> <span class=s2>&#34;/ecs/${var.service_name}/${var.environment}&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  retention_in_days</span> <span class=o>=</span> <span class=m>14</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>  tags</span> <span class=o>=</span> <span class=k>var</span><span class=p>.</span><span class=k>tags</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>14 days is usually enough for debugging. If you need longer retention for compliance, ship logs to S3 or OpenSearch.</p><h2 id=putting-it-all-together>Putting It All Together<a href=#putting-it-all-together class=hanchor arialabel=Anchor>#</a></h2><p>Here&rsquo;s the complete pattern for a new service:</p><ol><li><strong>ECR repository</strong> with lifecycle policy (keep last 10 images)</li><li><strong>ECS cluster</strong> with Container Insights enabled</li><li><strong>Task definition</strong> with ARM64, proper resource limits, secrets injection</li><li><strong>ECS service</strong> with circuit breaker, Spot strategy, auto-scaling</li><li><strong>ALB</strong> with HTTPS (TLS 1.3), path-based routing</li><li><strong>WAF</strong> with rate limiting and AWS managed rules</li><li><strong>Aurora Serverless v2</strong> with environment-appropriate scaling</li><li><strong>Route53</strong> private hosted zone record</li><li><strong>CloudWatch</strong> log group with 14-day retention</li><li><strong>Security groups</strong> with three-tier model (ALB -> ECS -> Aurora)</li></ol><p>Once you have this as a set of Terraform modules, deploying a new service is just composing the modules with service-specific variables. The infrastructure is consistent, secure, and cost-optimized across all environments.</p><h2 id=references>References<a href=#references class=hanchor arialabel=Anchor>#</a></h2><ul><li><a href=https://docs.aws.amazon.com/AmazonECS/latest/developerguide/fargate-capacity-providers.html>ECS Fargate Capacity Providers</a></li><li><a href=https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html>Deployment Circuit Breaker</a></li><li><a href=https://github.com/aws/aws-graviton-getting-started>AWS Graviton Getting Started</a></li><li><a href=https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.html>Aurora Serverless v2</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://manuelfedele.github.io/posts/building-ai-powered-platform-operations-agent/ class="button inline prev">&lt; [<span class=button__text>Building an AI-Powered Platform Operations Agent</span>]
</a>::
<a href=https://manuelfedele.github.io/posts/building-ai-document-processing-pipeline-aws/ class="button inline next">[<span class=button__text>Building an AI-Powered Document Processing Pipeline on AWS</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>