<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Git Push and Run</title><link>https://manuelfedele.github.io/posts/</link><description>Recent content in Posts on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© 2026 Manuel Fedele</copyright><lastBuildDate>Sun, 01 Mar 2026 12:00:00 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Leveraging AI as a Software Engineer: What Actually Works</title><link>https://manuelfedele.github.io/posts/leveraging-ai-as-a-platform-engineer/</link><pubDate>Sun, 01 Mar 2026 12:00:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/leveraging-ai-as-a-platform-engineer/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I have been using AI coding assistants seriously for about a year — not casually, not experimentally, but as a core part of how I do my job every day. This is not a post about AI generating code. It is about how AI changes the way an experienced engineer thinks, investigates, and makes decisions.
&lt;/div>


&lt;h2 class="relative group">The Shift That Actually Matters
 &lt;div id="the-shift-that-actually-matters" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#the-shift-that-actually-matters" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>The naive version of AI-assisted development is: you describe what you want, the AI writes it, you review and move on. This is real and useful, but it is also the least interesting thing AI does for me.&lt;/p></description></item><item><title>Shipping a DORA Compliance Tool from Zero to Production in One Day</title><link>https://manuelfedele.github.io/posts/shipping-a-dora-compliance-tool-from-zero-to-prod/</link><pubDate>Sun, 01 Mar 2026 10:00:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/shipping-a-dora-compliance-tool-from-zero-to-prod/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I spent a single session building a DORA-compliant Third Party Management tool from scratch, adding Microsoft Entra ID SSO, migrating the entire infrastructure from CloudFormation to Terraform, deploying to both qual and prod on ECS Fargate, and fixing a cascade of real-world deployment problems along the way. Here is an honest account of what broke and how I fixed it.
&lt;/div>

&lt;p>I built a DORA-compliant Third Party Management (TPM) tool: a Django + React application for managing ICT provider lifecycles, risk assessments, and regulatory registers. Then I wired up Microsoft Entra ID SSO, containerized it, and deployed it to AWS ECS Fargate using a Terraform pipeline, in a corporate environment full of proxies, permission boundaries, and shared infrastructure.&lt;/p></description></item><item><title>WASM in the Browser: Deploying VERT on CloudFront for Free</title><link>https://manuelfedele.github.io/posts/wasm-vert-cloudfront-zero-cost/</link><pubDate>Sun, 01 Mar 2026 10:00:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/wasm-vert-cloudfront-zero-cost/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 WebAssembly lets CPU-heavy work run entirely inside the browser tab — no server, no uploads, no cost. This post covers what WASM actually is, and how to self-host VERT, a fully local file converter, on AWS CloudFront for effectively zero dollars.
&lt;/div>


&lt;h2 class="relative group">What is WebAssembly?
 &lt;div id="what-is-webassembly" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#what-is-webassembly" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>WebAssembly (WASM) is a binary instruction format that runs inside the browser at near-native speed. Think of it as a portable compilation target: you write code in Rust, C, C++, or Go, compile it to &lt;code>.wasm&lt;/code>, and the browser executes it directly in a sandboxed VM alongside JavaScript.&lt;/p></description></item><item><title>Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator</title><link>https://manuelfedele.github.io/posts/building-ai-sre-assistant-from-scratch/</link><pubDate>Sun, 22 Feb 2026 09:30:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/building-ai-sre-assistant-from-scratch/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 What if your on-call engineer never slept, had instant access to every repository and every AWS account, and could trace a production issue from DNS to database in under a minute? This post walks through every layer of the architecture — from the authentication system to the agent framework, tool registry, streaming infrastructure, and deployment.
&lt;/div>

&lt;div class="admonition relative overflow-hidden rounded-lg border-l-4 my-3 px-4 py-3 shadow-sm" data-type="note">
 &lt;div class="flex items-center gap-2 font-semibold text-inherit">
 &lt;div class="flex shrink-0 h-5 w-5 items-center justify-center text-lg">&lt;span class="relative block icon">&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">&lt;path fill="currentColor" d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z"/>&lt;/svg>
&lt;/span>&lt;/div>
 &lt;div class="grow">
 Note
 &lt;/div>
 &lt;/div>&lt;div class="admonition-content mt-3 text-base leading-relaxed text-inherit">&lt;p>This article describes an AI-powered SRE assistant built with the Strands Agents SDK, Django, React, and AWS. The agent autonomously investigates infrastructure issues by combining LLM reasoning with deep integrations into GitLab and AWS.&lt;/p></description></item><item><title>Building an AI-Powered Platform Operations Agent</title><link>https://manuelfedele.github.io/posts/building-ai-powered-platform-operations-agent/</link><pubDate>Sun, 15 Feb 2026 11:00:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/building-ai-powered-platform-operations-agent/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Platform engineering teams handle a constant stream of repetitive requests. This post walks through building an AI agent that automates common platform tasks — user provisioning, key rotation, service health checks — by giving an LLM access to internal tools through a structured tool-calling interface.
&lt;/div>

&lt;p>Platform engineering teams handle a constant stream of repetitive requests: onboarding users, managing API keys, checking service health, rotating credentials. Most of these tasks follow well-defined procedures that a human executes step by step. What if an AI agent could handle them instead?&lt;/p></description></item><item><title>ECS Fargate Production Patterns That Actually Work</title><link>https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/</link><pubDate>Thu, 08 Jan 2026 14:20:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 A set of battle-tested ECS Fargate patterns I apply to every production service — covering Spot strategies, deployment circuit breakers, ARM64 migration, health checks, and Aurora Serverless v2 cost optimization.
&lt;/div>

&lt;p>I&amp;rsquo;ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.&lt;/p></description></item><item><title>Building an AI-Powered Document Processing Pipeline on AWS</title><link>https://manuelfedele.github.io/posts/building-ai-document-processing-pipeline-aws/</link><pubDate>Wed, 03 Dec 2025 16:45:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/building-ai-document-processing-pipeline-aws/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 A serverless document processing pipeline on AWS that uses LLMs to extract structured data from unstructured documents — invoices, contracts, reports — at scale. No GPU clusters required.
&lt;/div>

&lt;p>Insurance companies process millions of documents every year: police reports, medical records, invoices, repair estimates. Traditionally, human operators read each document, classify it, extract the relevant fields, and enter the data into the claims system. This is slow, expensive, and error-prone.&lt;/p></description></item><item><title>Building Interactive CLI Tools in Go with Bubbletea</title><link>https://manuelfedele.github.io/posts/building-interactive-cli-tools-in-go-with-bubbletea/</link><pubDate>Fri, 14 Nov 2025 10:30:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/building-interactive-cli-tools-in-go-with-bubbletea/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Bubbletea brings the Elm architecture to the terminal, making it possible to build rich, interactive CLI tools in Go with clean state management. This post covers the fundamentals with a practical example.
&lt;/div>

&lt;p>If you&amp;rsquo;ve ever wanted to build a terminal application that feels more like a proper UI than a wall of text, the &lt;a href="https://github.com/charmbracelet" target="_blank" rel="noreferrer">charmbracelet&lt;/a> ecosystem is the way to go. I&amp;rsquo;ve been using it to build internal DevOps tools, and the developer experience is excellent. In this post, I&amp;rsquo;ll walk through building an interactive CLI tool using &lt;a href="https://github.com/charmbracelet/bubbletea" target="_blank" rel="noreferrer">Bubbletea&lt;/a> and &lt;a href="https://github.com/charmbracelet/huh" target="_blank" rel="noreferrer">Huh&lt;/a>, the same libraries behind tools like &lt;code>gum&lt;/code> and &lt;code>soft-serve&lt;/code>.&lt;/p></description></item><item><title>Managing Multi-Account AWS Infrastructure with Terraform Workspaces</title><link>https://manuelfedele.github.io/posts/multi-account-aws-terraform-workspaces/</link><pubDate>Mon, 22 Sep 2025 09:15:00 +0200</pubDate><guid>https://manuelfedele.github.io/posts/multi-account-aws-terraform-workspaces/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Managing Terraform across multiple AWS accounts and environments without duplicating code. This post covers the workspace pattern, remote state, cross-account role assumptions, and the module structure that scales from 3 accounts to 30.
&lt;/div>

&lt;p>When you&amp;rsquo;re managing infrastructure across dozens of AWS accounts, you need patterns that scale. In this post I&amp;rsquo;ll share the approach I use to manage multi-account, multi-environment AWS infrastructure using Terraform workspaces, modular code, and a consistent tagging strategy.&lt;/p></description></item><item><title>Building a Chess Engine - From Position Evaluation to Search Techniques</title><link>https://manuelfedele.github.io/posts/evaluate-chess-position/</link><pubDate>Wed, 27 Nov 2024 17:33:00 +0000</pubDate><guid>https://manuelfedele.github.io/posts/evaluate-chess-position/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position&amp;hellip;
&lt;/div>

&lt;p>Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position evaluation and search strategies.&lt;/p></description></item><item><title>JWT Authentication in Go: HS256, RS256, and Middleware Patterns</title><link>https://manuelfedele.github.io/posts/jwt-issuer-in-go/</link><pubDate>Wed, 27 Nov 2024 17:18:00 +0000</pubDate><guid>https://manuelfedele.github.io/posts/jwt-issuer-in-go/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 JWTs are not sessions. They are signed, self-contained claims that cannot be revoked without additional infrastructure. Understanding that tradeoff before you reach for JWT is more important than any implementation detail. This post covers HS256 vs RS256, correct validation middleware, token revocation with Redis, and a JWKS endpoint for service-to-service verification.
&lt;/div>

&lt;p>JWTs are widely misused. Teams reach for them by default because every tutorial shows them, not because they are the right tool for the job. Before writing any code, you need to understand what JWTs actually are and what they are not.&lt;/p></description></item><item><title>Dijkstra's Algorithm in Go: Implementation, Optimization, and Real-World Use</title><link>https://manuelfedele.github.io/posts/implementing-djikstra-algorithm-in-go/</link><pubDate>Wed, 27 Nov 2024 17:01:00 +0000</pubDate><guid>https://manuelfedele.github.io/posts/implementing-djikstra-algorithm-in-go/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Graph shortest-path problems appear constantly in platform engineering: network routing, dependency resolution, service mesh path optimization, and CI pipeline scheduling all reduce to finding the minimum-cost path through a directed weighted graph. Dijkstra&amp;rsquo;s algorithm is the workhorse for these problems when edge weights are non-negative. This post covers a correct Go implementation, the heap-based optimization that makes it practical on large graphs, path reconstruction, and a realistic dependency-resolution use case.
&lt;/div>


&lt;h2 class="relative group">Graph Representation
 &lt;div id="graph-representation" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#graph-representation" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>An adjacency list using integer node IDs is the right choice for Dijkstra in Go. String keys are convenient for small examples but add unnecessary hashing overhead on graphs with thousands of nodes. We represent weighted edges as structs and store the graph as a slice of slices (indexed by node ID).&lt;/p></description></item><item><title>Clipboard Security Monitoring in Go: Detecting and Redacting Secrets</title><link>https://manuelfedele.github.io/posts/clipboard-watch-remove-accidentally-typed-passwords/</link><pubDate>Sun, 26 Nov 2023 11:29:46 +0100</pubDate><guid>https://manuelfedele.github.io/posts/clipboard-watch-remove-accidentally-typed-passwords/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Accidentally typing a password into the wrong field and having it sit in your clipboard is a real security risk. A clipboard monitor can detect common secret patterns and redact them automatically before you paste them somewhere they should not go.
&lt;/div>

&lt;p>This post builds a production-quality clipboard watcher in Go: regex-based secret detection, thread-safe polling with context cancellation, desktop notifications on redaction, and OS-level background service setup for macOS and Linux.&lt;/p></description></item><item><title>Shipping Lambda Logs to OpenSearch Across AWS Accounts with Terraform</title><link>https://manuelfedele.github.io/posts/aws-opensearch-as-monitoring-tool/</link><pubDate>Wed, 12 Jul 2023 08:42:00 +0200</pubDate><guid>https://manuelfedele.github.io/posts/aws-opensearch-as-monitoring-tool/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Multi-account log centralization is table stakes for any platform team. If your Lambda functions live in one AWS account and your observability tooling in another, you need a production-grade pipeline that ships logs across account boundaries without compromising security. Here is the complete Terraform setup.
&lt;/div>

&lt;p>Every mature AWS organization eventually separates workloads from shared services into distinct accounts. Compute in Account A, OpenSearch in Account B. The challenge is getting CloudWatch logs to cross that account boundary reliably, with least-privilege IAM and no hardcoded credentials anywhere.&lt;/p></description></item><item><title>Clean Package Design in Go: Single Responsibility and Package Cohesion</title><link>https://manuelfedele.github.io/posts/the-single-responsibility-principle/</link><pubDate>Tue, 21 Mar 2023 15:10:03 +0100</pubDate><guid>https://manuelfedele.github.io/posts/the-single-responsibility-principle/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 SRP in Go is about package boundaries and exported surfaces, not just splitting methods into files. When a package has one reason to change, you can test it in isolation, swap implementations behind an interface, and reason about its behavior without reading the rest of the codebase.
&lt;/div>

&lt;p>The Single Responsibility Principle (SRP) is often stated as &amp;ldquo;a class should have one reason to change.&amp;rdquo; In Go, there are no classes, but the principle applies with equal force to packages and to the exported types within them. Getting it wrong produces a God service: one package that knows about the database, email, HTTP, and business logic all at once. Getting it right produces a codebase where changing the email provider does not require touching the database layer.&lt;/p></description></item><item><title>Scheduled Automation with GitHub Actions: Real DevOps Use Cases</title><link>https://manuelfedele.github.io/posts/schedule-github-action-with-cron/</link><pubDate>Sun, 12 Mar 2023 15:03:40 +0100</pubDate><guid>https://manuelfedele.github.io/posts/schedule-github-action-with-cron/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Cron triggers in GitHub Actions are powerful for automation that should not need a human to fire it: nightly vulnerability audits, weekly cost checks, certificate expiry alerts. This is the practical guide &amp;ndash; real workflows, real use cases, and the traps to avoid.
&lt;/div>

&lt;p>Most GitHub Actions tutorials cover push and pull request triggers. The &lt;code>schedule&lt;/code> trigger gets less attention, but it is often where the most valuable automation lives. A nightly dependency audit that opens an issue when it finds CVEs. A weekly cost check that alerts Slack when your AWS bill spikes. A certificate check that pages you before the cert expires rather than after. None of these need a developer to press a button.&lt;/p></description></item><item><title>Git Branch Management: Local, Remote, and Keeping Your Repo Clean</title><link>https://manuelfedele.github.io/posts/how-to-delete-git-branch-locally/</link><pubDate>Tue, 07 Mar 2023 17:14:30 +0100</pubDate><guid>https://manuelfedele.github.io/posts/how-to-delete-git-branch-locally/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Branch management is one of the most common sources of confusion and mistakes in team workflows. Branches pile up, remote tracking refs go stale, and people either delete the wrong thing or never clean up at all. This is the reference you&amp;rsquo;ll want to bookmark.
&lt;/div>

&lt;p>After a few months on a shared repository, the branch list starts to look like an archaeological dig. There are feature branches from tickets closed six months ago, a &lt;code>hotfix-DO-NOT-DELETE&lt;/code> that nobody dares touch, and a dozen &lt;code>origin/feature-*&lt;/code> tracking refs for branches that no longer exist on the remote. Understanding exactly how local branches, remote branches, and remote tracking refs relate to each other is the foundation of keeping this under control.&lt;/p></description></item><item><title>Undoing Changes in Git: reset, revert, restore, and When to Use Each</title><link>https://manuelfedele.github.io/posts/how-to-undo-most-recent-local-git-commit/</link><pubDate>Tue, 28 Feb 2023 17:09:02 +0100</pubDate><guid>https://manuelfedele.github.io/posts/how-to-undo-most-recent-local-git-commit/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Git has four main verbs for undoing things: restore, reset, revert, and reflog. Picking the wrong one either rewrites history that others have already pulled, or throws away work you wanted to keep. Here is the mental model for choosing correctly.
&lt;/div>

&lt;p>The &amp;ldquo;how do I undo this?&amp;rdquo; question comes up constantly, and the answer depends on one critical variable: has anyone else already pulled the commit you want to undo? If yes, rewriting history causes pain for your teammates. If no, you have more options. The map below will get you to the right command quickly, but understanding why each command works the way it does is what makes the difference in an incident at 2am.&lt;/p></description></item><item><title>Design Patterns in Go: Idiomatic Implementations</title><link>https://manuelfedele.github.io/posts/implement-desing-patterns-with-golang/</link><pubDate>Tue, 21 Feb 2023 13:16:06 +0100</pubDate><guid>https://manuelfedele.github.io/posts/implement-desing-patterns-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go approaches design patterns differently from Java or C++. Because Go uses composition instead of inheritance, and because functions are first-class values, many patterns that require elaborate class hierarchies in OOP languages collapse into a few idiomatic Go constructs. This post shows the correct, production-ready implementations and, just as importantly, tells you when not to reach for a pattern at all.
&lt;/div>

&lt;p>Design patterns are not a checklist. In Go, applying Java-style patterns wholesale is the fastest path to code that looks foreign to every Go developer who reads it. The patterns below are presented in their idiomatic Go form, which is often significantly simpler than the textbook version.&lt;/p></description></item><item><title>NATS Messaging in Go: Core, JetStream, and Production Patterns</title><link>https://manuelfedele.github.io/posts/nats-messaging-with-golang/</link><pubDate>Mon, 13 Feb 2023 18:57:15 +0100</pubDate><guid>https://manuelfedele.github.io/posts/nats-messaging-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 NATS is a single binary, sub-millisecond messaging system built for cloud-native workloads. It is not Kafka, and it is not Redis Streams. Knowing when to choose it and what it cannot do is as important as knowing how to use it. This post covers core NATS pub/sub, queue groups, request/reply, JetStream persistence, pull consumers, and authentication.
&lt;/div>

&lt;p>Kafka, NATS, Redis Streams, and RabbitMQ all describe themselves as &amp;ldquo;messaging systems.&amp;rdquo; They are not interchangeable. Kafka is optimised for high-throughput event log storage with long-term replay. Redis Streams is a good fit when you already have Redis and need a lightweight consumer group. RabbitMQ is the right choice when you need complex routing and AMQP semantics.&lt;/p></description></item><item><title>Solving Sudoku in Go: Backtracking, Constraint Caching, and Benchmarks</title><link>https://manuelfedele.github.io/posts/build-a-sudoku-solver-in-golang/</link><pubDate>Wed, 01 Feb 2023 21:09:26 +0100</pubDate><guid>https://manuelfedele.github.io/posts/build-a-sudoku-solver-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Sudoku solving is a classic constraint satisfaction problem (CSP). The same algorithmic techniques &amp;ndash; backtracking with constraint propagation &amp;ndash; appear in production systems for job scheduling, resource allocation, and configuration validation. Understanding how to implement and optimize a Sudoku solver gives you a concrete mental model for tackling these problems at scale.
&lt;/div>


&lt;h2 class="relative group">Problem Representation
 &lt;div id="problem-representation" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#problem-representation" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>A Sudoku grid is a 9x9 matrix of integers where 0 represents an empty cell. A fixed-size array is the right type: it lives on the stack, has no allocation overhead, and can be passed by value for snapshot semantics during backtracking.&lt;/p></description></item><item><title>Real-Time Communication in Go: TCP Sockets, Message Framing, and WebSockets</title><link>https://manuelfedele.github.io/posts/socket-messaging-with-golang/</link><pubDate>Sun, 29 Jan 2023 18:44:12 +0100</pubDate><guid>https://manuelfedele.github.io/posts/socket-messaging-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 TCP is a stream protocol, not a message protocol. If you read bytes into a fixed buffer, you will silently truncate messages larger than that buffer. You need framing. This post covers length-prefixed framing, a multi-client broadcast server, and WebSocket support for browser clients.
&lt;/div>

&lt;p>The first thing most tutorials about sockets in Go get wrong is the buffer. Reading into &lt;code>make([]byte, 1024)&lt;/code> is not message-oriented. A 1025-byte message gets split across two reads. A 512-byte message and a 300-byte message can arrive in one read. TCP is a stream &amp;ndash; you need to add structure on top of it.&lt;/p></description></item><item><title>Email Open Tracking with Go: Tracking Pixels, Unique URLs, and GDPR</title><link>https://manuelfedele.github.io/posts/tracking-pixel-technology-email-golang/</link><pubDate>Sun, 22 Jan 2023 19:02:19 +0100</pubDate><guid>https://manuelfedele.github.io/posts/tracking-pixel-technology-email-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 A tracking pixel is a 1x1 transparent image embedded in an HTML email. When an email client renders the image, it fires an HTTP GET request to your server &amp;ndash; logging the open event. Used correctly, tracking pixels power read receipts, delivery confirmation, and engagement analytics for transactional and marketing emails. Used carelessly, they violate GDPR and produce misleading metrics. This post covers a production-correct Go implementation with per-recipient unique URLs, an honest discussion of what the data actually measures, and the compliance obligations you cannot skip.
&lt;/div>


&lt;h2 class="relative group">How It Works
 &lt;div id="how-it-works" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#how-it-works" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>The mechanism is simple, but the details matter for accuracy and compliance.&lt;/p></description></item><item><title>Communicating with Stockfish from Go: The UCI Protocol</title><link>https://manuelfedele.github.io/posts/evaluate-chess-position-with-golang/</link><pubDate>Thu, 19 Jan 2023 21:33:41 +0100</pubDate><guid>https://manuelfedele.github.io/posts/evaluate-chess-position-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Stockfish is the world&amp;rsquo;s strongest chess engine. Communicating with it from Go via the UCI protocol takes about 30 lines. This post shows the real implementation: process spawning, the UCI handshake, FEN input, evaluation parsing, and a complete reusable Engine struct.
&lt;/div>

&lt;p>The original version of this post called non-existent methods like &lt;code>chess.NewEngine(&amp;quot;stockfish&amp;quot;)&lt;/code>, &lt;code>SetDifficulty&lt;/code>, and &lt;code>Evaluate&lt;/code> on the &lt;code>notnil/chess&lt;/code> library. That library is a chess rules engine &amp;ndash; it does not wrap Stockfish at all. Communicating with Stockfish requires the UCI protocol over stdin/stdout, which is exactly what this post covers.&lt;/p></description></item><item><title>Memoization in Go: Caching Expensive Computations Correctly</title><link>https://manuelfedele.github.io/posts/the-memoization-technique/</link><pubDate>Mon, 16 Jan 2023 21:07:26 +0100</pubDate><guid>https://manuelfedele.github.io/posts/the-memoization-technique/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Memoization is the optimization technique of caching the return value of a pure function so that repeated calls with the same inputs skip the computation entirely. It applies whenever a function is expensive, deterministic, and called multiple times with the same arguments. Done correctly in Go it requires a mutex, and in modern code a generic wrapper makes it reusable across types.
&lt;/div>

&lt;p>Memoization is often introduced with Fibonacci because the recursive explosion is easy to visualize. But the real production applications are elsewhere: permission checks that hit a database, configuration lookups over a network, or expensive cryptographic computations. This post covers the full picture from basic implementation through data race prevention, generic wrappers, and time-to-live (TTL) invalidation.&lt;/p></description></item><item><title>Algorithmic Trading with Alpaca and Go: Paper Trading and Real-Time Data</title><link>https://manuelfedele.github.io/posts/trading-with-alpaca-and-golang/</link><pubDate>Sun, 15 Jan 2023 19:24:09 +0100</pubDate><guid>https://manuelfedele.github.io/posts/trading-with-alpaca-and-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Alpaca provides commission-free, API-first trading with a paper trading environment for safe strategy testing. This post covers the actual Go SDK patterns, correct order placement, real-time data retrieval, a simple momentum strategy, and the risk management you need before going live.
&lt;/div>

&lt;p>The original version of this post called functions like &lt;code>alpaca.PlaceOrder&lt;/code>, &lt;code>alpaca.GetQuote&lt;/code>, and &lt;code>alpaca.ListTrades&lt;/code> as package-level functions. None of these exist in the current SDK. The real library uses a client struct. This post uses the actual &lt;code>github.com/alpacahq/alpaca-trade-api-go/v3/alpaca&lt;/code> package.&lt;/p></description></item><item><title>Elasticsearch in Practice: Indexing, Searching, and Relevance Scoring</title><link>https://manuelfedele.github.io/posts/a-quick-overview-of-elasticsearch/</link><pubDate>Fri, 13 Jan 2023 17:24:25 +0100</pubDate><guid>https://manuelfedele.github.io/posts/a-quick-overview-of-elasticsearch/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Elasticsearch is not just a database with a search box. It is a distributed relevance engine built on inverted indexes, and understanding that distinction changes how you design schemas, queries, and aggregations.
&lt;/div>

&lt;p>I have run Elasticsearch in production for log analytics, product search, and document retrieval pipelines. The same mistakes appear every time a team treats it like a relational database. This post covers what you actually need to know: mappings, query semantics, relevance scoring, and aggregations as they really work.&lt;/p></description></item><item><title>Testing in Go: From Unit Tests to Mocks and Benchmarks</title><link>https://manuelfedele.github.io/posts/unit-testing-in-golang/</link><pubDate>Mon, 09 Jan 2023 20:49:03 +0100</pubDate><guid>https://manuelfedele.github.io/posts/unit-testing-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go&amp;rsquo;s testing philosophy is stdlib-first and table-driven. You rarely need an external framework. The &lt;code>testing&lt;/code> package, combined with interfaces for dependency injection and &lt;code>httptest&lt;/code> for HTTP, covers almost everything you will encounter in production codebases.
&lt;/div>

&lt;p>A lot of Go developers coming from Python or Java reach for testify or gomock before they need to. Go&amp;rsquo;s standard library is remarkably complete for testing. This post walks through the patterns that experienced Go engineers actually use: table-driven tests with subtests, interface-based mocks, HTTP handler testing, benchmarks, and coverage analysis.&lt;/p></description></item><item><title>git fetch vs git pull: Remote Tracking and Rebase Workflows</title><link>https://manuelfedele.github.io/posts/what-is-the-difference-between-git-pull-and-git-fetch/</link><pubDate>Sun, 08 Jan 2023 17:16:40 +0100</pubDate><guid>https://manuelfedele.github.io/posts/what-is-the-difference-between-git-pull-and-git-fetch/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 &lt;code>git fetch&lt;/code> is always safe. &lt;code>git pull&lt;/code> is fetch plus merge (or rebase), and that second step is where things go wrong. Understanding the difference changes how you collaborate on shared branches.
&lt;/div>

&lt;p>Most developers learn &lt;code>git pull&lt;/code> first and use it reflexively. It works fine in isolation, but on a team with an active shared branch it quietly adds merge commits to your history, can fail mid-operation if your working tree is dirty, and obscures what actually arrived from the remote. Knowing when to use &lt;code>fetch&lt;/code> instead gives you back control.&lt;/p></description></item><item><title>Video Streaming in Go: HTTP Range Requests, HLS Segments, and FFmpeg</title><link>https://manuelfedele.github.io/posts/streaming-video-with-golang/</link><pubDate>Wed, 04 Jan 2023 21:23:20 +0100</pubDate><guid>https://manuelfedele.github.io/posts/streaming-video-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Proper video streaming in HTTP is not about piping bytes. It is about range requests that let players seek, HLS segments that allow adaptive bitrate, and keeping FFmpeg as a subprocess while Go handles HTTP. Get these three things right and you have a working video server.
&lt;/div>

&lt;p>&lt;code>http.ServeFile&lt;/code> actually does handle range requests correctly for static files. The problem comes when you try to build something more sophisticated: transcoding on the fly, live streaming, or HLS segmentation. This post covers each scenario with working code, and explains what &lt;code>http.ServeFile&lt;/code> does and does not handle.&lt;/p></description></item><item><title>Serving Protocol Buffers from FastAPI: Binary Endpoints and gRPC Gateway</title><link>https://manuelfedele.github.io/posts/use-protobuf-with-fastapi/</link><pubDate>Wed, 04 Jan 2023 16:00:43 +0100</pubDate><guid>https://manuelfedele.github.io/posts/use-protobuf-with-fastapi/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 FastAPI is excellent for rapid API development. Protobuf is excellent for compact, typed binary payloads. You can combine them without any magic Pydantic integration &amp;ndash; just read raw bytes, parse with the generated class, and return bytes with the right Content-Type.
&lt;/div>

&lt;p>If you search for &amp;ldquo;FastAPI protobuf&amp;rdquo; you will find many posts that try to use Pydantic models as a bridge to protobuf serialization. There is no such bridge in Pydantic. The correct approach is simpler and more direct: FastAPI endpoints can accept and return raw bytes. The protobuf Python library handles the actual encoding. This post walks through a complete working implementation, content negotiation, and testing.&lt;/p></description></item><item><title>The Go context Package: Cancellation, Timeouts, and Propagation in Production</title><link>https://manuelfedele.github.io/posts/the-context-package/</link><pubDate>Tue, 03 Jan 2023 20:36:29 +0100</pubDate><guid>https://manuelfedele.github.io/posts/the-context-package/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 The &lt;code>context&lt;/code> package exists for one primary reason: goroutine lifecycle management. It gives you a standard, composable way to propagate cancellation signals, deadlines, and request-scoped metadata across API boundaries. Understanding how it works in production is the difference between a service that drains cleanly and one that leaks goroutines under load.
&lt;/div>

&lt;p>Every non-trivial Go service uses &lt;code>context&lt;/code>. You pass it from HTTP handlers to database queries, from gRPC interceptors to downstream API calls. But many engineers treat it as little more than a convention to satisfy function signatures. This post covers how &lt;code>context&lt;/code> actually works, where it fails silently when misused, and the patterns that matter in production.&lt;/p></description></item><item><title>Python Async/Await in Practice: asyncio, FastAPI, and Common Pitfalls</title><link>https://manuelfedele.github.io/posts/understand-async-await-in-python/</link><pubDate>Sun, 01 Jan 2023 14:50:35 +0100</pubDate><guid>https://manuelfedele.github.io/posts/understand-async-await-in-python/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Async/await is not magic. It is cooperative multitasking for I/O-bound work, built on a single-threaded event loop. Getting it wrong does not crash your program; it silently makes it slower and harder to debug. This post covers what the event loop actually does, how to use asyncio correctly, the FastAPI async model, and the mistakes that cost teams weeks.
&lt;/div>

&lt;p>Python&amp;rsquo;s &lt;code>async&lt;/code>/&lt;code>await&lt;/code> syntax landed in Python 3.5 and became genuinely production-ready in Python 3.7 with &lt;code>asyncio.run&lt;/code>. Today it powers FastAPI, aiohttp, and most of the modern Python async ecosystem. But a large fraction of the async code I see in the wild has subtle bugs: missing &lt;code>await&lt;/code>, calls to blocking libraries inside async functions, or CPU-heavy work that brings the event loop to a halt.&lt;/p></description></item><item><title>Building a Telegram Bot in Rust with Teloxide</title><link>https://manuelfedele.github.io/posts/create-a-telegram-bot-with-rust/</link><pubDate>Sat, 31 Dec 2022 14:26:23 +0100</pubDate><guid>https://manuelfedele.github.io/posts/create-a-telegram-bot-with-rust/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Rust is an unusual choice for a Telegram bot, but the trade-offs are real: a single statically linked binary, sub-10MB Docker images, and memory usage that stays flat under load. Teloxide is the community-standard Rust Telegram library and it makes the async plumbing invisible.
&lt;/div>

&lt;p>Most Telegram bot tutorials reach for Python or Node. Rust is genuinely worth considering if you care about deployment simplicity (one binary, no interpreter), memory footprint, or you are already in a Rust codebase. This post walks through a complete bot using &lt;code>teloxide&lt;/code>: commands, inline keyboards, a multi-step state machine, and production deployment.&lt;/p></description></item><item><title>Building Production APIs with FastAPI: Pydantic, Dependency Injection, and Deployment</title><link>https://manuelfedele.github.io/posts/create-webserver-with-fastapi-and-uvicorn/</link><pubDate>Fri, 30 Dec 2022 14:08:35 +0100</pubDate><guid>https://manuelfedele.github.io/posts/create-webserver-with-fastapi-and-uvicorn/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 FastAPI combines Python type hints with automatic OpenAPI documentation and near-Go performance. It has become the default choice for Python APIs. This post covers the patterns that matter in production: Pydantic models, dependency injection, background tasks, and multi-worker deployment.
&lt;/div>

&lt;p>FastAPI is not a thin wrapper around Starlette. The combination of Pydantic v2 for validation, &lt;code>Depends()&lt;/code> for dependency injection, and async-native request handling makes it the closest Python equivalent to a typed HTTP framework. The original version of this post had a broken handler signature and no production content. This is the rebuild.&lt;/p></description></item><item><title>Python Generators and yield: Building Memory-Efficient Pipelines</title><link>https://manuelfedele.github.io/posts/what-does-yield-keyword-do-in-python/</link><pubDate>Thu, 29 Dec 2022 10:19:25 +0100</pubDate><guid>https://manuelfedele.github.io/posts/what-does-yield-keyword-do-in-python/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 A generator is a lazy sequence. It produces values one at a time on demand instead of materializing everything into memory at once. For large datasets, streaming APIs, and data processing pipelines, generators are the correct default, not an optimization applied after the fact.
&lt;/div>

&lt;p>Python generators are one of the most practically useful features in the language, and one of the most underused by engineers who learned Python from web tutorials. This post goes beyond &amp;ldquo;use yield instead of return&amp;rdquo; and covers the full picture: the iterator protocol, memory characteristics, &lt;code>yield from&lt;/code>, generator pipelines, and real-world streaming use cases.&lt;/p></description></item><item><title>Protocol Buffers in Go: Serialization, gRPC, and Performance</title><link>https://manuelfedele.github.io/posts/use-protobuf-with-golang/</link><pubDate>Tue, 27 Dec 2022 18:48:44 +0100</pubDate><guid>https://manuelfedele.github.io/posts/use-protobuf-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Protocol Buffers give you binary serialization that is roughly 40% smaller and 6x faster than JSON. That trade-off is worth it for internal microservice traffic. It is not worth it for a public REST API that humans need to read with curl.
&lt;/div>

&lt;p>Protocol Buffers (protobuf) are Google&amp;rsquo;s binary serialization format. The pitch is simple: define your data schema once in a &lt;code>.proto&lt;/code> file, generate typed code in any language, and get compact wire format for free. The catch is tooling overhead and the loss of human readability. This post walks through a complete Go setup: correct marshaling API, a gRPC service, and a benchmark comparing protobuf to JSON.&lt;/p></description></item><item><title>Building CLIs in Go with Cobra: Flags, Subcommands, and Shell Completion</title><link>https://manuelfedele.github.io/posts/create-command-line-application-with-golang/</link><pubDate>Tue, 20 Dec 2022 10:03:30 +0100</pubDate><guid>https://manuelfedele.github.io/posts/create-command-line-application-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Cobra is the de-facto standard for serious Go CLIs. kubectl, the GitHub CLI, and Docker all use it. If you are building a command-line tool with multiple subcommands, typed flags, and shell completion, this is how you do it properly.
&lt;/div>

&lt;p>Raw &lt;code>os.Args&lt;/code> parsing works for a single command with one positional argument. The moment you add a second subcommand or a &lt;code>--dry-run&lt;/code> flag, you are reinventing the wheel. Cobra handles argument parsing, flag validation, help text generation, and shell completion out of the box.&lt;/p></description></item><item><title>Deploying a Static Site with Hugo and GitHub Actions: Zero-Cost Hosting</title><link>https://manuelfedele.github.io/posts/create-website-with-gatsby-and-github-pages/</link><pubDate>Tue, 20 Dec 2022 09:49:01 +0100</pubDate><guid>https://manuelfedele.github.io/posts/create-website-with-gatsby-and-github-pages/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Static sites are the most cost-efficient way to host content. No servers to maintain, no runtime costs, no scaling surprises. With Hugo and GitHub Actions you get a fast, version-controlled blog deployed automatically on every push, for effectively zero cost.
&lt;/div>


&lt;h2 class="relative group">Why Hugo Over Gatsby or Next.js
 &lt;div id="why-hugo-over-gatsby-or-nextjs" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-hugo-over-gatsby-or-nextjs" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Gatsby had a good run, but the ecosystem has shifted. The project was acquired, maintenance slowed, and most teams that were using it have migrated to Next.js or a static generator. Hugo fills a different niche: it does not care about React, has no Node.js dependency, and builds thousands of pages in under a second. If you are building a blog or documentation site and not a full React application, Hugo is the right tool.&lt;/p></description></item><item><title>Redis in Go with go-redis/v9: Caching, Pub/Sub, and Production Patterns</title><link>https://manuelfedele.github.io/posts/use-redis-with-golang/</link><pubDate>Mon, 19 Dec 2022 19:32:27 +0100</pubDate><guid>https://manuelfedele.github.io/posts/use-redis-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Redis is not just a cache. It is a data structure server that speaks TCP, persists to disk, replicates across nodes, and handles pub/sub fan-out in a single binary. This post covers how to use it properly from Go with go-redis/v9: connection pools, TTL management, the cache-aside pattern, sorted sets for rate limiting, pub/sub, and pipelines.
&lt;/div>

&lt;p>Most teams reach for Redis when they need a fast key-value cache, hit it with &lt;code>SET&lt;/code>/&lt;code>GET&lt;/code>, and stop there. That misses most of what Redis can do. This post works through the data structures and operational patterns that matter in production services: proper connection pool configuration, TTL discipline, the cache-aside pattern with generics, lists as queues, sorted sets for sliding-window rate limiting, pub/sub for fan-out, and atomic pipelines.&lt;/p></description></item><item><title>Building Desktop Applications in Go with Fyne: Stock Market Dashboard</title><link>https://manuelfedele.github.io/posts/create-desktop-application-stock-market-data-golang/</link><pubDate>Mon, 19 Dec 2022 19:08:58 +0100</pubDate><guid>https://manuelfedele.github.io/posts/create-desktop-application-stock-market-data-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Fyne is Go&amp;rsquo;s best cross-platform UI toolkit. One codebase compiles to Windows, macOS, and Linux, shipping as a native binary with no runtime dependency. This post builds a real stock market dashboard, covering Fyne&amp;rsquo;s widget system, layout engine, goroutine safety rules, and distribution.
&lt;/div>


&lt;h2 class="relative group">Why Fyne
 &lt;div id="why-fyne" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-fyne" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Go desktop applications have historically been awkward. CGo-based bindings to GTK or Qt work, but the build complexity is painful. Fyne takes a different approach: it uses OpenGL for rendering, keeping the API pure Go and the resulting binary fully self-contained.&lt;/p></description></item><item><title>PostgreSQL JSONB: Flexible Schema, Indexing, and When to Use It</title><link>https://manuelfedele.github.io/posts/work-with-json-postgresql/</link><pubDate>Mon, 19 Dec 2022 18:20:30 +0100</pubDate><guid>https://manuelfedele.github.io/posts/work-with-json-postgresql/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 JSONB is not a replacement for normalized schemas. It is a tool for genuinely semi-structured data where the shape varies per row and you need to query inside it. Use it precisely, and it saves you from premature schema commits. Use it everywhere, and you have reinvented a document store on top of a relational database.
&lt;/div>

&lt;p>PostgreSQL&amp;rsquo;s JSONB type is one of the most powerful and most misused features in the database. This post covers the practical details: storage differences, operators, GIN indexes, mutation functions, and the patterns where JSONB earns its place.&lt;/p></description></item><item><title>Building Production HTTP Services in Go</title><link>https://manuelfedele.github.io/posts/how-to-create-a-webserver-in-golang/</link><pubDate>Sun, 11 Dec 2022 19:14:21 +0100</pubDate><guid>https://manuelfedele.github.io/posts/how-to-create-a-webserver-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go&amp;rsquo;s &lt;code>net/http&lt;/code> standard library is production-ready. With Go 1.22+ enhanced routing, method and path pattern matching are built in. You do not need a framework for most services &amp;ndash; but you do need to configure timeouts, graceful shutdown, and middleware correctly from the start.
&lt;/div>

&lt;p>Most Go HTTP tutorials show &lt;code>http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)&lt;/code> and call it a day. That code will run, but it will leak goroutines under load, hang forever on slow clients, and crash non-gracefully when you deploy a new version. This post covers what a production-ready Go HTTP service actually looks like, using only the standard library for the core, with a note on when a router library pays off.&lt;/p></description></item><item><title>Go Interfaces in Practice: Polymorphism, Composition, and Testing</title><link>https://manuelfedele.github.io/posts/how-to-use-interfaces-in-golang/</link><pubDate>Sun, 11 Dec 2022 19:04:27 +0100</pubDate><guid>https://manuelfedele.github.io/posts/how-to-use-interfaces-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go interfaces are implicit. You do not declare that a type implements an interface. If a type has the right methods, it satisfies the interface. This single design decision makes Go interfaces more flexible, more composable, and more powerful for testing than explicit interface implementations in Java or C#.
&lt;/div>

&lt;p>Interfaces are the mechanism Go uses to express polymorphism, to decouple consumers from producers, and to make code testable without heavyweight frameworks. This post works through the patterns that matter in real codebases: polymorphism with slices of interfaces, the &lt;code>io.Reader&lt;/code>/&lt;code>io.Writer&lt;/code> design, interface composition, interfaces for test mocks, and the line between &lt;code>any&lt;/code> and generics.&lt;/p></description></item><item><title>The Factory Pattern in Go: Dependency Inversion and Testable Services</title><link>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</link><pubDate>Sun, 11 Dec 2022 18:57:13 +0100</pubDate><guid>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 The factory pattern in Go is primarily about interface-based construction that enables dependency inversion and testing. The toy animal example is fine for learning the syntax. This post shows the version that matters in production: storage backends, notification senders, and testable services.
&lt;/div>

&lt;p>The original version of this post had two paragraphs and a &lt;code>Dog.Speak()&lt;/code> example. That covers the syntax but misses the point entirely. The factory pattern in Go is not about creating animals. It is about writing code where the calling layer does not need to know or care which concrete implementation it receives.&lt;/p></description></item><item><title>Creating a Hugo Theme From Scratch: Layouts, Partials, and Template Inheritance</title><link>https://manuelfedele.github.io/posts/create-template-hugo/</link><pubDate>Thu, 03 Nov 2022 14:57:41 +0100</pubDate><guid>https://manuelfedele.github.io/posts/create-template-hugo/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to&amp;hellip;
&lt;/div>

&lt;div class="admonition relative overflow-hidden rounded-lg border-l-4 my-3 px-4 py-3 shadow-sm" data-type="note">
 &lt;div class="flex items-center gap-2 font-semibold text-inherit">
 &lt;div class="flex shrink-0 h-5 w-5 items-center justify-center text-lg">&lt;span class="relative block icon">&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">&lt;path fill="currentColor" d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z"/>&lt;/svg>
&lt;/span>&lt;/div>
 &lt;div class="grow">
 Note
 &lt;/div>
 &lt;/div>&lt;div class="admonition-content mt-3 text-base leading-relaxed text-inherit">&lt;p>This tutorial targets Hugo v0.100+. The layout system changed significantly from older versions. If you are using Hugo before v0.90, expect differences in template lookup rules, configuration syntax, and the way partials are resolved.&lt;/p></description></item><item><title>Poetry No Module Seed via App Data</title><link>https://manuelfedele.github.io/posts/poetry-no-module-seed-via-app-data/</link><pubDate>Mon, 01 Nov 2021 15:15:47 +0100</pubDate><guid>https://manuelfedele.github.io/posts/poetry-no-module-seed-via-app-data/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 For my last project, I used &lt;strong>poetry&lt;/strong> to manage dependencies and package my code. Poetry comes with all the tools you might need to manage your projects in a deterministic way.
&lt;/div>

&lt;p>For my last project, I used &lt;strong>poetry&lt;/strong> to manage dependencies and package my code.
Poetry comes with all the tools you might need to manage your projects in a deterministic way.&lt;/p>
&lt;p>Anyway, after running poetry init in an existing project, I tried to let poetry create a virtuale environment, by adding the first dependecy, but when I did poetry add twisted it suddenly hang out, printing:&lt;/p></description></item><item><title>Amazon Echo Plus as bluetooth speaker on Ubuntu 20.04</title><link>https://manuelfedele.github.io/posts/ubuntu-echo-plus-alexa-workaround-bluetooth-speaker/</link><pubDate>Tue, 14 Apr 2020 09:37:07 +0100</pubDate><guid>https://manuelfedele.github.io/posts/ubuntu-echo-plus-alexa-workaround-bluetooth-speaker/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I just unpaired the devices, then started a YouTube video on my Ubuntu machine and then repeated the steps below (pairing) while the audio was playing. At that point I’ve been able to send audio to my Echo Plus.
&lt;/div>


&lt;h3 class="relative group">TLDR;
 &lt;div id="tldr" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#tldr" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h3>
&lt;p>I just unpaired the devices, then started a YouTube video on my Ubuntu machine and then repeated the steps below (pairing) while the audio was playing. At that point I’ve been able to send audio to my Echo Plus.&lt;/p></description></item></channel></rss>