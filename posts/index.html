<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Git Push and Run</title><meta name=keywords content><meta name=description content="Posts - Git Push and Run"><meta name=author content><link rel=canonical href=https://manuelfedele.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.c2189e7d36d72767de292f8b9d897e4a464aa5bc7eb692cda50064f5eb9eeece.css integrity="sha256-whiefTbXJ2feKS+LnYl+SkZKpbx+tpLNpQBk9eue7s4=" rel="preload stylesheet" as=style><link rel=icon href=https://manuelfedele.github.io/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://manuelfedele.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://manuelfedele.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/img/apple-touch-icon-144-precomposed.png><link rel=mask-icon href=https://manuelfedele.github.io/img/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://manuelfedele.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://manuelfedele.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta name=google-site-verification content="bNHRtbwz1iqFFQ60i1jOBm2U7WHWMc8LgejU7wLaDSs"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><meta property="og:url" content="https://manuelfedele.github.io/posts/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:title" content="Posts"><meta property="og:description" content="A simple blog about software engineering"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://manuelfedele.github.io/img/card-pillow.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://manuelfedele.github.io/img/card-pillow.jpg"><meta name=twitter:title content="Posts"><meta name=twitter:description content="A simple blog about software engineering"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://manuelfedele.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://manuelfedele.github.io/ accesskey=h title="Git Push and Run (Alt + H)"><img src=https://manuelfedele.github.io/img/apple-touch-icon-144-precomposed.png alt aria-label=logo height=25>Git Push and Run</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://manuelfedele.github.io/ title=Home><span>Home</span></a></li><li><a href=https://manuelfedele.github.io/search/ title=Search><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://manuelfedele.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator</h2></header><div class=entry-content><p>Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator What if your on-call engineer never slept, had instant access to every repository and every AWS account, and could trace a production issue from DNS to database in under a minute?
That’s the question that led me to build TARS, an AI-powered SRE assistant that autonomously investigates infrastructure issues by combining LLM reasoning with deep integrations into GitLab and AWS. Named after the robot from Interstellar (because every good internal tool needs a movie reference), TARS is a full-stack application where engineers interact with an AI agent through a chat interface. The agent doesn’t just answer questions. It investigates. It clones repos, greps code, reads CloudWatch logs, traces DNS chains, inspects ECS services, and synthesizes findings into structured reports.
...</p></div><footer class=entry-footer><span title='2026-02-22 09:30:00 +0100 +0100'>February 22, 2026</span>&nbsp;·&nbsp;<span>22 min</span>&nbsp;·&nbsp;<span>4501 words</span></footer><a class=entry-link aria-label="post link to Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator" href=https://manuelfedele.github.io/posts/building-ai-sre-assistant-from-scratch/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Building an AI-Powered Platform Operations Agent</h2></header><div class=entry-content><p>Building an AI-Powered Platform Operations Agent Platform engineering teams handle a constant stream of repetitive requests: onboarding users, managing API keys, checking service health, rotating credentials. Most of these tasks follow well-defined procedures that a human executes step by step. What if an AI agent could handle them instead?
In this post, I’ll walk through the architecture of an AI-powered operations agent that automates common platform tasks by giving an LLM access to your internal tools through a structured tool-calling interface.
...</p></div><footer class=entry-footer><span title='2026-02-15 11:00:00 +0100 +0100'>February 15, 2026</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>1729 words</span></footer><a class=entry-link aria-label="post link to Building an AI-Powered Platform Operations Agent" href=https://manuelfedele.github.io/posts/building-ai-powered-platform-operations-agent/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ECS Fargate Production Patterns That Actually Work</h2></header><div class=entry-content><p>ECS Fargate Production Patterns That Actually Work I’ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.
The Standard Architecture Every service I deploy follows the same high-level architecture:
Internet/VPC -> ALB (HTTPS, TLS 1.3) -> ECS Fargate -> Aurora PostgreSQL Serverless v2 | WAF (rate limiting + AWS managed rules) Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS.
...</p></div><footer class=entry-footer><span title='2026-01-08 14:20:00 +0100 +0100'>January 8, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1250 words</span></footer><a class=entry-link aria-label="post link to ECS Fargate Production Patterns That Actually Work" href=https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Building an AI-Powered Document Processing Pipeline on AWS</h2></header><div class=entry-content><p>Building an AI-Powered Document Processing Pipeline on AWS Insurance companies process millions of documents every year: police reports, medical records, invoices, repair estimates. Traditionally, human operators read each document, classify it, extract the relevant fields, and enter the data into the claims system. This is slow, expensive, and error-prone.
In this post I’ll describe the architecture of a production document processing pipeline I helped build. The system ingests claim documents, extracts text using vision-based LLMs, clusters and classifies document sections, extracts structured data, and generates vector embeddings for semantic search. All of this runs on a fully serverless AWS architecture with no idle infrastructure costs.
...</p></div><footer class=entry-footer><span title='2025-12-03 16:45:00 +0100 +0100'>December 3, 2025</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>2120 words</span></footer><a class=entry-link aria-label="post link to Building an AI-Powered Document Processing Pipeline on AWS" href=https://manuelfedele.github.io/posts/building-ai-document-processing-pipeline-aws/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Building Interactive CLI Tools in Go with Bubbletea</h2></header><div class=entry-content><p>Building Interactive CLI Tools in Go with Bubbletea If you’ve ever wanted to build a terminal application that feels more like a proper UI than a wall of text, the charmbracelet ecosystem is the way to go. I’ve been using it to build internal DevOps tools, and the developer experience is excellent. In this post, I’ll walk through building an interactive CLI tool using Bubbletea and Huh, the same libraries behind tools like gum and soft-serve.
...</p></div><footer class=entry-footer><span title='2025-11-14 10:30:00 +0100 +0100'>November 14, 2025</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1230 words</span></footer><a class=entry-link aria-label="post link to Building Interactive CLI Tools in Go with Bubbletea" href=https://manuelfedele.github.io/posts/building-interactive-cli-tools-in-go-with-bubbletea/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Managing Multi-Account AWS Infrastructure with Terraform Workspaces</h2></header><div class=entry-content><p>Managing Multi-Account AWS Infrastructure with Terraform Workspaces When you’re managing infrastructure across dozens of AWS accounts, you need patterns that scale. In this post I’ll share the approach I use to manage multi-account, multi-environment AWS infrastructure using Terraform workspaces, modular code, and a consistent tagging strategy.
The Problem Imagine this setup: you have multiple organizational scopes (teams, business units, projects), each with their own AWS accounts for non-production and production. On top of that, your non-production account hosts multiple environments (dev, integration, certification). Multiply this by several countries or regions, and you’re looking at a lot of infrastructure to manage.
...</p></div><footer class=entry-footer><span title='2025-09-22 09:15:00 +0200 +0200'>September 22, 2025</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1333 words</span></footer><a class=entry-link aria-label="post link to Managing Multi-Account AWS Infrastructure with Terraform Workspaces" href=https://manuelfedele.github.io/posts/multi-account-aws-terraform-workspaces/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Building a Chess Engine - From Position Evaluation to Search Techniques</h2></header><div class=entry-content><p>Building a Chess Engine: From Position Evaluation to Search Techniques Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position evaluation and search strategies.
Part 1: Basic Position Representation First, let’s implement a basic board representation. While FEN (Forsyth–Edwards Notation) is the standard for chess positions, we’ll use a more computation-friendly format internally.
...</p></div><footer class=entry-footer><span title='2024-11-27 17:33:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;<span>13 min</span>&nbsp;·&nbsp;<span>2695 words</span></footer><a class=entry-link aria-label="post link to Building a Chess Engine - From Position Evaluation to Search Techniques" href=https://manuelfedele.github.io/posts/evaluate-chess-position/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Implementing a JWT Issuer in Go</h2></header><div class=entry-content><p>Building a Secure JWT Issuer in Go: A Complete Guide JSON Web Tokens (JWT) have become the de facto standard for implementing stateless authentication in modern web applications. In this guide, we’ll implement a secure JWT issuer in Go, covering both basic implementation and advanced security considerations.
Understanding JWT Basics A JWT consists of three parts: header, payload, and signature. These parts are Base64URL encoded and concatenated with dots. The signature ensures the token hasn’t been tampered with, while the payload carries the claims (data) we want to transmit securely.
...</p></div><footer class=entry-footer><span title='2024-11-27 17:18:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>906 words</span></footer><a class=entry-link aria-label="post link to Implementing a JWT Issuer in Go" href=https://manuelfedele.github.io/posts/jwt-issuer-in-go/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Implementing Dijkstra’s Algorithm in Go</h2></header><div class=entry-content><p>A Beginner’s Guide and Optimization Techniques Graphs are fundamental data structures in computer science, representing relationships between entities. One of the most common problems involving graphs is finding the shortest path between nodes. Dijkstra’s algorithm is a classic solution to this problem for graphs with non-negative edge weights. In this guide, we’ll implement Dijkstra’s algorithm in Go and explore ways to optimize it using advanced data structures.\
Basic Implementation of Dijkstra’s Algorithm Let’s begin by understanding the core concept. Dijkstra’s algorithm maintains a set of nodes whose shortest distance from the source is known and repeatedly selects the node with the minimum distance to explore its neighbors.
...</p></div><footer class=entry-footer><span title='2024-11-27 17:01:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1141 words</span></footer><a class=entry-link aria-label="post link to Implementing Dijkstra’s Algorithm in Go" href=https://manuelfedele.github.io/posts/implementing-djikstra-algorithm-in-go/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Clipboard Watch Remove Accidentally Typed Passwords</h2></header><div class=entry-content><p>Monitoring Clipboard in Golang: A Guide to Obscuring Passwords Introduction In this article, we explore creating a Go program that monitors the system clipboard, automatically substituting passwords with asterisks. Uniquely, the program leaves the last few characters (minimum 1, maximum 3) of the password visible when the password length exceeds 8 characters.
Understanding Clipboard Monitoring in Go The Clipboard Package Go lacks a built-in library for clipboard operations. We use atotto/clipboard, a third-party package offering simple clipboard interfaces.
...</p></div><footer class=entry-footer><span title='2023-11-26 11:29:46 +0100 +0100'>November 26, 2023</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>348 words</span></footer><a class=entry-link aria-label="post link to Clipboard Watch Remove Accidentally Typed Passwords" href=https://manuelfedele.github.io/posts/clipboard-watch-remove-accidentally-typed-passwords/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://manuelfedele.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://manuelfedele.github.io/>Git Push and Run</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>