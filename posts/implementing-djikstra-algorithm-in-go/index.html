<!doctype html><html lang=en><head><title>Implementing Dijkstra’s Algorithm in Go :: Git Push and Run</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A Beginner’s Guide and Optimization Techniques Graphs are fundamental data structures in computer science, representing relationships between entities. One of the most common problems involving graphs is finding the shortest path between nodes. Dijkstra’s algorithm is a classic solution to this problem for graphs with non-negative edge weights. In this guide, we’ll implement Dijkstra’s algorithm in Go and explore ways to optimize it using advanced data structures.\
Basic Implementation of Dijkstra’s Algorithm Let’s begin by understanding the core concept. Dijkstra’s algorithm maintains a set of nodes whose shortest distance from the source is known and repeatedly selects the node with the minimum distance to explore its neighbors.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://manuelfedele.github.io/posts/implementing-djikstra-algorithm-in-go/><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><link rel=stylesheet href=https://manuelfedele.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://manuelfedele.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://manuelfedele.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://manuelfedele.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://manuelfedele.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://manuelfedele.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://manuelfedele.github.io/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css><link rel=stylesheet href=https://manuelfedele.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css><link rel=stylesheet href=https://manuelfedele.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://manuelfedele.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css><link rel=stylesheet href=https://manuelfedele.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://manuelfedele.github.io/style.css><link rel="shortcut icon" href=https://manuelfedele.github.io/favicon.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Implementing Dijkstra’s Algorithm in Go"><meta property="og:description" content="A Beginner’s Guide and Optimization Techniques Graphs are fundamental data structures in computer science, representing relationships between entities. One of the most common problems involving graphs is finding the shortest path between nodes. Dijkstra’s algorithm is a classic solution to this problem for graphs with non-negative edge weights. In this guide, we’ll implement Dijkstra’s algorithm in Go and explore ways to optimize it using advanced data structures.\
Basic Implementation of Dijkstra’s Algorithm Let’s begin by understanding the core concept. Dijkstra’s algorithm maintains a set of nodes whose shortest distance from the source is known and repeatedly selects the node with the minimum distance to explore its neighbors.
"><meta property="og:url" content="https://manuelfedele.github.io/posts/implementing-djikstra-algorithm-in-go/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:image" content="https://manuelfedele.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2024-11-27 17:01:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>git push && run</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://manuelfedele.github.io/posts/implementing-djikstra-algorithm-in-go/>Implementing Dijkstra’s Algorithm in Go</a></h1><div class=post-meta><time class=post-date>2024-11-27</time><span class=post-reading-time>6 min read (1141 words)</span></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/golang/>“golang”</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/algorithms/>“algorithms”</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#basic-implementation-of-dijkstras-algorithm>Basic Implementation of Dijkstra’s Algorithm</a><ul><li><a href=#implementing-the-algorithm>Implementing the Algorithm</a></li><li><a href=#explanation>Explanation</a></li><li><a href=#example-usage>Example Usage</a></li></ul></li><li><a href=#optimizing-dijkstras-algorithm-with-a-priority-queue>Optimizing Dijkstra’s Algorithm with a Priority Queue</a></li><li><a href=#optimizing-dijkstras-algorithm-with-a-priority-queue-1>Optimizing Dijkstra’s Algorithm with a Priority Queue</a><ul><li><a href=#implementing-a-priority-queue>Implementing a Priority Queue</a></li><li><a href=#optimized-dijkstras-algorithm>Optimized Dijkstra’s Algorithm</a></li><li><a href=#explanation-1>Explanation</a></li><li><a href=#testing-the-optimized-algorithm>Testing the Optimized Algorithm</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#references>References</a></li></ul></nav></div><div class=post-content><div><h1 id=a-beginners-guide-and-optimization-techniques>A Beginner’s Guide and Optimization Techniques<a href=#a-beginners-guide-and-optimization-techniques class=hanchor arialabel=Anchor>#</a></h1><p>Graphs are fundamental data structures in computer science, representing relationships between entities. One of the most common problems involving graphs is finding the shortest path between nodes. Dijkstra’s algorithm is a classic solution to this problem for graphs with non-negative edge weights. In this guide, we’ll implement Dijkstra’s algorithm in Go and explore ways to optimize it using advanced data structures.\</p><h2 id=basic-implementation-of-dijkstras-algorithm>Basic Implementation of Dijkstra’s Algorithm<a href=#basic-implementation-of-dijkstras-algorithm class=hanchor arialabel=Anchor>#</a></h2><p>Let’s begin by understanding the core concept. Dijkstra’s algorithm maintains a set of nodes whose shortest distance from the source is known and repeatedly selects the node with the minimum distance to explore its neighbors.</p><p>First, we’ll represent our graph. In Go, a convenient way to represent a graph is with adjacency lists using maps.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Edge</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>node</span>   <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>weight</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Graph</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>nodes</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>Edge</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewGraph</span><span class=p>()</span> <span class=o>*</span><span class=nx>Graph</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>Graph</span><span class=p>{</span><span class=nx>nodes</span><span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>Edge</span><span class=p>)}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Graph</span><span class=p>)</span> <span class=nf>AddEdge</span><span class=p>(</span><span class=nx>from</span><span class=p>,</span> <span class=nx>to</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>weight</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>g</span><span class=p>.</span><span class=nx>nodes</span><span class=p>[</span><span class=nx>from</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>nodes</span><span class=p>[</span><span class=nx>from</span><span class=p>],</span> <span class=nx>Edge</span><span class=p>{</span><span class=nx>node</span><span class=p>:</span> <span class=nx>to</span><span class=p>,</span> <span class=nx>weight</span><span class=p>:</span> <span class=nx>weight</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=implementing-the-algorithm>Implementing the Algorithm<a href=#implementing-the-algorithm class=hanchor arialabel=Anchor>#</a></h3><p>Now, let’s implement the basic version of Dijkstra’s algorithm:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Dijkstra</span><span class=p>(</span><span class=nx>graph</span> <span class=o>*</span><span class=nx>Graph</span><span class=p>,</span> <span class=nx>start</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>distances</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>previous</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>distances</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>previous</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>unvisited</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Initialize distances and unvisited nodes</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>node</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>graph</span><span class=p>.</span><span class=nx>nodes</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>distances</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(^</span><span class=nb>uint</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>// Set to infinity</span>
</span></span><span class=line><span class=cl>        <span class=nx>unvisited</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>distances</span><span class=p>[</span><span class=nx>start</span><span class=p>]</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>unvisited</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Find the unvisited node with the smallest distance</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>currentNode</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>        <span class=nx>smallestDistance</span> <span class=o>:=</span> <span class=nb>int</span><span class=p>(^</span><span class=nb>uint</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>node</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>unvisited</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>distances</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=nx>smallestDistance</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>smallestDistance</span> <span class=p>=</span> <span class=nx>distances</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=nx>currentNode</span> <span class=p>=</span> <span class=nx>node</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Remove the node from unvisited set</span>
</span></span><span class=line><span class=cl>        <span class=nb>delete</span><span class=p>(</span><span class=nx>unvisited</span><span class=p>,</span> <span class=nx>currentNode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Update distances to neighbors</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>edge</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>graph</span><span class=p>.</span><span class=nx>nodes</span><span class=p>[</span><span class=nx>currentNode</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>alt</span> <span class=o>:=</span> <span class=nx>distances</span><span class=p>[</span><span class=nx>currentNode</span><span class=p>]</span> <span class=o>+</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>weight</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>alt</span> <span class=p>&lt;</span> <span class=nx>distances</span><span class=p>[</span><span class=nx>edge</span><span class=p>.</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>distances</span><span class=p>[</span><span class=nx>edge</span><span class=p>.</span><span class=nx>node</span><span class=p>]</span> <span class=p>=</span> <span class=nx>alt</span>
</span></span><span class=line><span class=cl>                <span class=nx>previous</span><span class=p>[</span><span class=nx>edge</span><span class=p>.</span><span class=nx>node</span><span class=p>]</span> <span class=p>=</span> <span class=nx>currentNode</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>distances</span><span class=p>,</span> <span class=nx>previous</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=explanation>Explanation<a href=#explanation class=hanchor arialabel=Anchor>#</a></h3><ul><li>Distances keeps track of the shortest distance from the start node to every other node.</li><li>Previous helps reconstruct the shortest path.</li><li>We iterate over all unvisited nodes, selecting the one with the smallest known distance.</li><li>For each neighbor of the current node, we check if a shorter path exists via the current node.</li></ul><h3 id=example-usage>Example Usage<a href=#example-usage class=hanchor arialabel=Anchor>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>graph</span> <span class=o>:=</span> <span class=nf>NewGraph</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>edges</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>from</span>   <span class=kt>string</span>
</span></span><span class=line><span class=cl>        <span class=nx>to</span>     <span class=kt>string</span>
</span></span><span class=line><span class=cl>        <span class=nx>weight</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=p>}{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;A&#34;</span><span class=p>,</span> <span class=s>&#34;B&#34;</span><span class=p>,</span> <span class=mi>7</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;A&#34;</span><span class=p>,</span> <span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=mi>9</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;A&#34;</span><span class=p>,</span> <span class=s>&#34;F&#34;</span><span class=p>,</span> <span class=mi>14</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;B&#34;</span><span class=p>,</span> <span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=mi>10</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;B&#34;</span><span class=p>,</span> <span class=s>&#34;D&#34;</span><span class=p>,</span> <span class=mi>15</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=s>&#34;D&#34;</span><span class=p>,</span> <span class=mi>11</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=s>&#34;F&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;D&#34;</span><span class=p>,</span> <span class=s>&#34;E&#34;</span><span class=p>,</span> <span class=mi>6</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;E&#34;</span><span class=p>,</span> <span class=s>&#34;F&#34;</span><span class=p>,</span> <span class=mi>9</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>edge</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>edges</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>graph</span><span class=p>.</span><span class=nf>AddEdge</span><span class=p>(</span><span class=nx>edge</span><span class=p>.</span><span class=nx>from</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>to</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>weight</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>graph</span><span class=p>.</span><span class=nf>AddEdge</span><span class=p>(</span><span class=nx>edge</span><span class=p>.</span><span class=nx>to</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>from</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>weight</span><span class=p>)</span> <span class=c1>// Assuming undirected graph</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>distances</span><span class=p>,</span> <span class=nx>previous</span> <span class=o>:=</span> <span class=nf>Dijkstra</span><span class=p>(</span><span class=nx>graph</span><span class=p>,</span> <span class=s>&#34;A&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Distances:&#34;</span><span class=p>,</span> <span class=nx>distances</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Previous nodes:&#34;</span><span class=p>,</span> <span class=nx>previous</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This code constructs a graph and finds the shortest paths from node &ldquo;A&rdquo; to all other nodes.</p><h2 id=optimizing-dijkstras-algorithm-with-a-priority-queue>Optimizing Dijkstra’s Algorithm with a Priority Queue<a href=#optimizing-dijkstras-algorithm-with-a-priority-queue class=hanchor arialabel=Anchor>#</a></h2><p>The basic implementation above has a time complexity of O(N²) due to the selection of the minimum node using a linear search. We can optimize this by using a priority queue (min-heap) to select the node with the smallest distance in logarithmic time.</p><p>Implementing a Priority Queue</p><p>Go’s standard library provides container/heap which can be used to implement a priority queue.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>graph</span> <span class=o>:=</span> <span class=nf>NewGraph</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>edges</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>from</span>   <span class=kt>string</span>
</span></span><span class=line><span class=cl>        <span class=nx>to</span>     <span class=kt>string</span>
</span></span><span class=line><span class=cl>        <span class=nx>weight</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=p>}{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;A&#34;</span><span class=p>,</span> <span class=s>&#34;B&#34;</span><span class=p>,</span> <span class=mi>7</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;A&#34;</span><span class=p>,</span> <span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=mi>9</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;A&#34;</span><span class=p>,</span> <span class=s>&#34;F&#34;</span><span class=p>,</span> <span class=mi>14</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;B&#34;</span><span class=p>,</span> <span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=mi>10</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;B&#34;</span><span class=p>,</span> <span class=s>&#34;D&#34;</span><span class=p>,</span> <span class=mi>15</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=s>&#34;D&#34;</span><span class=p>,</span> <span class=mi>11</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=s>&#34;F&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;D&#34;</span><span class=p>,</span> <span class=s>&#34;E&#34;</span><span class=p>,</span> <span class=mi>6</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;E&#34;</span><span class=p>,</span> <span class=s>&#34;F&#34;</span><span class=p>,</span> <span class=mi>9</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>edge</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>edges</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>graph</span><span class=p>.</span><span class=nf>AddEdge</span><span class=p>(</span><span class=nx>edge</span><span class=p>.</span><span class=nx>from</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>to</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>weight</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>graph</span><span class=p>.</span><span class=nf>AddEdge</span><span class=p>(</span><span class=nx>edge</span><span class=p>.</span><span class=nx>to</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>from</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>weight</span><span class=p>)</span> <span class=c1>// Assuming undirected graph</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>distances</span><span class=p>,</span> <span class=nx>previous</span> <span class=o>:=</span> <span class=nf>Dijkstra</span><span class=p>(</span><span class=nx>graph</span><span class=p>,</span> <span class=s>&#34;A&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Distances:&#34;</span><span class=p>,</span> <span class=nx>distances</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Previous nodes:&#34;</span><span class=p>,</span> <span class=nx>previous</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This code constructs a graph and finds the shortest paths from node &ldquo;A&rdquo; to all other nodes.</p><h2 id=optimizing-dijkstras-algorithm-with-a-priority-queue-1>Optimizing Dijkstra’s Algorithm with a Priority Queue<a href=#optimizing-dijkstras-algorithm-with-a-priority-queue-1 class=hanchor arialabel=Anchor>#</a></h2><p>The basic implementation above has a time complexity of O(N²) due to the selection of the minimum node using a linear search. We can optimize this by using a priority queue (min-heap) to select the node with the smallest distance in logarithmic time.</p><h3 id=implementing-a-priority-queue>Implementing a Priority Queue<a href=#implementing-a-priority-queue class=hanchor arialabel=Anchor>#</a></h3><p>Go’s standard library provides container/heap which can be used to implement a priority queue.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;container/heap&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Item</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>node</span>     <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>priority</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>index</span>    <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>PriorityQueue</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Item</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>pq</span> <span class=nx>PriorityQueue</span><span class=p>)</span> <span class=nf>Len</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>pq</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>pq</span> <span class=nx>PriorityQueue</span><span class=p>)</span> <span class=nf>Less</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>pq</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>priority</span> <span class=p>&lt;</span> <span class=nx>pq</span><span class=p>[</span><span class=nx>j</span><span class=p>].</span><span class=nx>priority</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>pq</span> <span class=nx>PriorityQueue</span><span class=p>)</span> <span class=nf>Swap</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>pq</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>pq</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>pq</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>pq</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>pq</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>index</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>    <span class=nx>pq</span><span class=p>[</span><span class=nx>j</span><span class=p>].</span><span class=nx>index</span> <span class=p>=</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>pq</span> <span class=o>*</span><span class=nx>PriorityQueue</span><span class=p>)</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>x</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=o>*</span><span class=nx>pq</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>item</span> <span class=o>:=</span> <span class=nx>x</span><span class=p>.(</span><span class=o>*</span><span class=nx>Item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>item</span><span class=p>.</span><span class=nx>index</span> <span class=p>=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>pq</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>pq</span><span class=p>,</span> <span class=nx>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>pq</span> <span class=o>*</span><span class=nx>PriorityQueue</span><span class=p>)</span> <span class=nf>Pop</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>old</span> <span class=o>:=</span> <span class=o>*</span><span class=nx>pq</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>old</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>item</span> <span class=o>:=</span> <span class=nx>old</span><span class=p>[</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>old</span><span class=p>[</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=kc>nil</span>  <span class=c1>// Avoid memory leak</span>
</span></span><span class=line><span class=cl>    <span class=nx>item</span><span class=p>.</span><span class=nx>index</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span> <span class=c1>// For safety</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>pq</span> <span class=p>=</span> <span class=nx>old</span><span class=p>[</span><span class=mi>0</span> <span class=p>:</span> <span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>item</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>pq</span> <span class=o>*</span><span class=nx>PriorityQueue</span><span class=p>)</span> <span class=nf>update</span><span class=p>(</span><span class=nx>item</span> <span class=o>*</span><span class=nx>Item</span><span class=p>,</span> <span class=nx>priority</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>item</span><span class=p>.</span><span class=nx>priority</span> <span class=p>=</span> <span class=nx>priority</span>
</span></span><span class=line><span class=cl>    <span class=nx>heap</span><span class=p>.</span><span class=nf>Fix</span><span class=p>(</span><span class=nx>pq</span><span class=p>,</span> <span class=nx>item</span><span class=p>.</span><span class=nx>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=optimized-dijkstras-algorithm>Optimized Dijkstra’s Algorithm<a href=#optimized-dijkstras-algorithm class=hanchor arialabel=Anchor>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DijkstraWithHeap</span><span class=p>(</span><span class=nx>graph</span> <span class=o>*</span><span class=nx>Graph</span><span class=p>,</span> <span class=nx>start</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>distances</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>previous</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>distances</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>previous</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>pq</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>PriorityQueue</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>heap</span><span class=p>.</span><span class=nf>Init</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pq</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>heap</span><span class=p>.</span><span class=nf>Push</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pq</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>Item</span><span class=p>{</span><span class=nx>node</span><span class=p>:</span> <span class=nx>start</span><span class=p>,</span> <span class=nx>priority</span><span class=p>:</span> <span class=mi>0</span><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>pq</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>item</span> <span class=o>:=</span> <span class=nx>heap</span><span class=p>.</span><span class=nf>Pop</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pq</span><span class=p>).(</span><span class=o>*</span><span class=nx>Item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>currentNode</span> <span class=o>:=</span> <span class=nx>item</span><span class=p>.</span><span class=nx>node</span>
</span></span><span class=line><span class=cl>        <span class=nx>currentDistance</span> <span class=o>:=</span> <span class=nx>item</span><span class=p>.</span><span class=nx>priority</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>distances</span><span class=p>[</span><span class=nx>currentNode</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span> <span class=c1>// Node already visited</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>distances</span><span class=p>[</span><span class=nx>currentNode</span><span class=p>]</span> <span class=p>=</span> <span class=nx>currentDistance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>edge</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>graph</span><span class=p>.</span><span class=nx>nodes</span><span class=p>[</span><span class=nx>currentNode</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>distances</span><span class=p>[</span><span class=nx>edge</span><span class=p>.</span><span class=nx>node</span><span class=p>];</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>alt</span> <span class=o>:=</span> <span class=nx>currentDistance</span> <span class=o>+</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>weight</span>
</span></span><span class=line><span class=cl>                <span class=nx>heap</span><span class=p>.</span><span class=nf>Push</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pq</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>Item</span><span class=p>{</span><span class=nx>node</span><span class=p>:</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>node</span><span class=p>,</span> <span class=nx>priority</span><span class=p>:</span> <span class=nx>alt</span><span class=p>})</span>
</span></span><span class=line><span class=cl>                <span class=nx>previous</span><span class=p>[</span><span class=nx>edge</span><span class=p>.</span><span class=nx>node</span><span class=p>]</span> <span class=p>=</span> <span class=nx>currentNode</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>distances</span><span class=p>,</span> <span class=nx>previous</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=explanation-1>Explanation<a href=#explanation-1 class=hanchor arialabel=Anchor>#</a></h3><ul><li>We use a priority queue pq to always select the node with the smallest distance.</li><li>When we pop a node from the heap, we check if it’s already visited to avoid redundant processing.</li><li>The overall time complexity reduces to O((E + V) log V), where E is the number of edges and V is the number of vertices.</li></ul><h3 id=testing-the-optimized-algorithm>Testing the Optimized Algorithm<a href=#testing-the-optimized-algorithm class=hanchor arialabel=Anchor>#</a></h3><p>Let’s test our optimized function with the same graph:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>graph</span> <span class=o>:=</span> <span class=nf>NewGraph</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>edges</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>from</span>   <span class=kt>string</span>
</span></span><span class=line><span class=cl>        <span class=nx>to</span>     <span class=kt>string</span>
</span></span><span class=line><span class=cl>        <span class=nx>weight</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=p>}{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;A&#34;</span><span class=p>,</span> <span class=s>&#34;B&#34;</span><span class=p>,</span> <span class=mi>7</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;A&#34;</span><span class=p>,</span> <span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=mi>9</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;A&#34;</span><span class=p>,</span> <span class=s>&#34;F&#34;</span><span class=p>,</span> <span class=mi>14</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;B&#34;</span><span class=p>,</span> <span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=mi>10</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;B&#34;</span><span class=p>,</span> <span class=s>&#34;D&#34;</span><span class=p>,</span> <span class=mi>15</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=s>&#34;D&#34;</span><span class=p>,</span> <span class=mi>11</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=s>&#34;F&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;D&#34;</span><span class=p>,</span> <span class=s>&#34;E&#34;</span><span class=p>,</span> <span class=mi>6</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;E&#34;</span><span class=p>,</span> <span class=s>&#34;F&#34;</span><span class=p>,</span> <span class=mi>9</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>edge</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>edges</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>graph</span><span class=p>.</span><span class=nf>AddEdge</span><span class=p>(</span><span class=nx>edge</span><span class=p>.</span><span class=nx>from</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>to</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>weight</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>graph</span><span class=p>.</span><span class=nf>AddEdge</span><span class=p>(</span><span class=nx>edge</span><span class=p>.</span><span class=nx>to</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>from</span><span class=p>,</span> <span class=nx>edge</span><span class=p>.</span><span class=nx>weight</span><span class=p>)</span> <span class=c1>// Assuming undirected graph</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>distances</span><span class=p>,</span> <span class=nx>previous</span> <span class=o>:=</span> <span class=nf>DijkstraWithHeap</span><span class=p>(</span><span class=nx>graph</span><span class=p>,</span> <span class=s>&#34;A&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Distances with heap:&#34;</span><span class=p>,</span> <span class=nx>distances</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Previous nodes with heap:&#34;</span><span class=p>,</span> <span class=nx>previous</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>You should observe the same results as before, but with improved efficiency, especially noticeable in larger graphs.</p><h2 id=conclusion>Conclusion<a href=#conclusion class=hanchor arialabel=Anchor>#</a></h2><p>Implementing Dijkstra’s algorithm provides valuable insights into graph traversal and optimization techniques. Starting with a basic implementation helps understand the core logic, while optimizing with a priority queue significantly improves performance. While further optimizations are possible, the heap-based approach offers a good balance between complexity and efficiency for most practical applications.</p><h2 id=references>References<a href=#references class=hanchor arialabel=Anchor>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm>Dijkstra’s Algorithm - Wikipedia</a></li><li><a href=https://pkg.go.dev/container/heap>container/heap Package Documentation</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://manuelfedele.github.io/posts/jwt-issuer-in-go/ class="button inline prev">&lt; [<span class=button__text>Implementing a JWT Issuer in Go</span>]
</a>::
<a href=https://manuelfedele.github.io/posts/clipboard-watch-remove-accidentally-typed-passwords/ class="button inline next">[<span class=button__text>Clipboard Watch Remove Accidentally Typed Passwords</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>