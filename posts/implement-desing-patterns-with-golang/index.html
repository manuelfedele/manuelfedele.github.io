<!doctype html><html lang=en><head><title>Implement Design Patterns With Golang :: Git Push and Run</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Design patterns are reusable solutions to common software design problems. They are a way to structure and organize code in a way that makes it easier to understand, maintain, and extend. In this article, we&rsquo;ll explore how to implement some popular design patterns in Go.
Singleton pattern The singleton pattern is a creational design pattern that ensures a class has only one instance and provides a global access point to it. In Go, we can implement the singleton pattern using the sync.Once type. Here&rsquo;s an example:
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://manuelfedele.github.io/posts/implement-desing-patterns-with-golang/><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><link rel=stylesheet href=https://manuelfedele.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://manuelfedele.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://manuelfedele.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://manuelfedele.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://manuelfedele.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://manuelfedele.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://manuelfedele.github.io/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css><link rel=stylesheet href=https://manuelfedele.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css><link rel=stylesheet href=https://manuelfedele.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://manuelfedele.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css><link rel=stylesheet href=https://manuelfedele.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://manuelfedele.github.io/favicon.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Implement Design Patterns With Golang"><meta property="og:description" content="Design patterns are reusable solutions to common software design problems. They are a way to structure and organize code in a way that makes it easier to understand, maintain, and extend. In this article, we&rsquo;ll explore how to implement some popular design patterns in Go.
Singleton pattern The singleton pattern is a creational design pattern that ensures a class has only one instance and provides a global access point to it. In Go, we can implement the singleton pattern using the sync.Once type. Here&rsquo;s an example:
"><meta property="og:url" content="https://manuelfedele.github.io/posts/implement-desing-patterns-with-golang/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:image" content="https://manuelfedele.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2023-02-21 13:16:06 +0100 +0100"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>git push && run</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://manuelfedele.github.io/posts/implement-desing-patterns-with-golang/>Implement Design Patterns With Golang</a></h1><div class=post-meta><time class=post-date>2023-02-21</time><span class=post-reading-time>4 min read (799 words)</span></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/design-patterns/>design patterns</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/golang/>golang</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#singleton-pattern>Singleton pattern</a></li><li><a href=#factory-pattern>Factory pattern</a></li><li><a href=#observer-pattern>Observer pattern</a></li><li><a href=#builder-pattern>Builder pattern</a></li></ul></nav></div><div class=post-content><div><p>Design patterns are reusable solutions to common software design problems. They are a way to structure and organize code in a way that makes it easier to understand, maintain, and extend. In this article, we&rsquo;ll explore how to implement some popular design patterns in Go.</p><h2 id=singleton-pattern>Singleton pattern<a href=#singleton-pattern class=hanchor arialabel=Anchor>#</a></h2><p>The singleton pattern is a creational design pattern that ensures a class has only one instance and provides a global access point to it. In Go, we can implement the singleton pattern using the sync.Once type. Here&rsquo;s an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Singleton</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// fields</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>instance</span> <span class=o>*</span><span class=nx>Singleton</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>once</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>GetInstance</span><span class=p>()</span> <span class=o>*</span><span class=nx>Singleton</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>once</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>instance</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Singleton</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>instance</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The sync.Once type has a Do method that ensures that a function is only called once. In this case, the function creates a new Singleton instance and assigns it to the instance variable. The GetInstance function returns the instance variable, which will always be the same instance created by the once.Do function.</p><h2 id=factory-pattern>Factory pattern<a href=#factory-pattern class=hanchor arialabel=Anchor>#</a></h2><p>The factory pattern is a creational design pattern that provides an interface for creating objects in a super class, but allows subclasses to alter the type of objects that will be created. In Go, we can implement the factory pattern using an interface and concrete types that implement the interface. Here&rsquo;s an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Shape</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Area</span><span class=p>()</span> <span class=kt>float64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Rectangle</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>width</span>  <span class=kt>float64</span>
</span></span><span class=line><span class=cl>	<span class=nx>height</span> <span class=kt>float64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=nx>Rectangle</span><span class=p>)</span> <span class=nf>Area</span><span class=p>()</span> <span class=kt>float64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nx>width</span> <span class=o>*</span> <span class=nx>r</span><span class=p>.</span><span class=nx>height</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Circle</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>radius</span> <span class=kt>float64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=nx>Circle</span><span class=p>)</span> <span class=nf>Area</span><span class=p>()</span> <span class=kt>float64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>math</span><span class=p>.</span><span class=nx>Pi</span> <span class=o>*</span> <span class=nx>c</span><span class=p>.</span><span class=nx>radius</span> <span class=o>*</span> <span class=nx>c</span><span class=p>.</span><span class=nx>radius</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ShapeFactory</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=nx>ShapeFactory</span><span class=p>)</span> <span class=nf>NewShape</span><span class=p>(</span><span class=nx>shapeType</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=nx>shapeType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;rectangle&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>Rectangle</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;circle&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>Circle</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The Shape interface defines a method for calculating the area of a shape. The Rectangle and Circle types both implement the Shape interface. The ShapeFactory type has a NewShape method that returns a new Shape of the specified type. This allows us to create different types of shapes using the same interface, without specifying the concrete type.</p><h2 id=observer-pattern>Observer pattern<a href=#observer-pattern class=hanchor arialabel=Anchor>#</a></h2><p>The observer pattern is a behavioral design pattern that allows an object to be notified of changes to another object. In Go, we can implement the observer pattern using channels and goroutines. Here&rsquo;s an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Observable</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>observers</span> <span class=p>[]</span><span class=kd>chan</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>Observable</span><span class=p>)</span> <span class=nf>AddObserver</span><span class=p>(</span><span class=nx>c</span> <span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>o</span><span class=p>.</span><span class=nx>observers</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>observers</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>Observable</span><span class=p>)</span> <span class=nf>Notify</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>c</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>o</span><span class=p>.</span><span class=nx>observers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>observable</span> <span class=o>:=</span> <span class=nx>Observable</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>observer1</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>observer2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>observable</span><span class=p>.</span><span class=nf>AddObserver</span><span class=p>(</span><span class=nx>observer1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>observable</span><span class=p>.</span><span class=nf>AddObserver</span><span class=p>(</span><span class=nx>observer2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>observer1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Observer 1 received:&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>observer2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Observer 2 received:&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>observable</span><span class=p>.</span><span class=nf>Notify</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>observable</span><span class=p>.</span><span class=nf>Notify</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>observable</span><span class=p>.</span><span class=nf>Notify</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nb>close</span><span class=p>(</span><span class=nx>observer1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nb>close</span><span class=p>(</span><span class=nx>observer2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The Observable type has a slice of channels to hold its observers, and methods to add and notify observers. In the main function, we create two channels and add them as observers to the Observable. We then start two goroutines that listen on the channels and print the values they receive. Finally, we call the Notify method on the Observable to send values to the observers.</p><h2 id=builder-pattern>Builder pattern<a href=#builder-pattern class=hanchor arialabel=Anchor>#</a></h2><p>The builder pattern is a creational design pattern that separates the construction of a complex object from its representation, allowing the same construction process to create different representations. In Go, we can implement the builder pattern using a builder interface and concrete builders that implement the interface. Here&rsquo;s an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Builder</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>SetType</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span> <span class=nx>Builder</span>
</span></span><span class=line><span class=cl>	<span class=nf>SetSize</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=nx>Builder</span>
</span></span><span class=line><span class=cl>	<span class=nf>SetColor</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span> <span class=nx>Builder</span>
</span></span><span class=line><span class=cl>	<span class=nf>Build</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>HouseBuilder</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>houseType</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>size</span>      <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>color</span>     <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>HouseBuilder</span><span class=p>)</span> <span class=nf>SetType</span><span class=p>(</span><span class=nx>t</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>Builder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>h</span><span class=p>.</span><span class=nx>houseType</span> <span class=p>=</span> <span class=nx>t</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>h</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>HouseBuilder</span><span class=p>)</span> <span class=nf>SetSize</span><span class=p>(</span><span class=nx>s</span> <span class=kt>int</span><span class=p>)</span> <span class=nx>Builder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>h</span><span class=p>.</span><span class=nx>size</span> <span class=p>=</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>h</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>HouseBuilder</span><span class=p>)</span> <span class=nf>SetColor</span><span class=p>(</span><span class=nx>c</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>Builder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>h</span><span class=p>.</span><span class=nx>color</span> <span class=p>=</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>h</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>HouseBuilder</span><span class=p>)</span> <span class=nf>Build</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>House</span><span class=p>{</span><span class=nx>Type</span><span class=p>:</span> <span class=nx>h</span><span class=p>.</span><span class=nx>houseType</span><span class=p>,</span> <span class=nx>Size</span><span class=p>:</span> <span class=nx>h</span><span class=p>.</span><span class=nx>size</span><span class=p>,</span> <span class=nx>Color</span><span class=p>:</span> <span class=nx>h</span><span class=p>.</span><span class=nx>color</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>House</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Type</span>  <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>Size</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>Color</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The Builder interface defines methods for setting the properties of the object being built and for building the object. The HouseBuilder type is a concrete builder that implements the Builder interface and has fields to store the properties of a House object. The Build method returns a House object with the stored properties. In the main function, we use the builder&rsquo;s methods to set the properties of the House and then call the Build method to create the House.</p><p>These are just a few examples of how to implement design patterns in Go. There are many more design patterns that can be useful in different situations, and Go provides a flexible and powerful toolset for implementing them.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://manuelfedele.github.io/posts/how-to-undo-most-recent-local-git-commit/ class="button inline prev">&lt; [<span class=button__text>How to Undo Most Recent Local Git Commit</span>]
</a>::
<a href=https://manuelfedele.github.io/posts/nats-messaging-with-golang/ class="button inline next">[<span class=button__text>Nats Messaging With Golang</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>