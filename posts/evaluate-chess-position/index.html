<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building a Chess Engine - From Position Evaluation to Search Techniques | Git Push and Run</title>
<meta name=keywords content="golang"><meta name=description content="Building a Chess Engine: From Position Evaluation to Search Techniques
Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position evaluation and search strategies.
Part 1: Basic Position Representation
First, let&rsquo;s implement a basic board representation. While FEN (Forsyth–Edwards Notation) is the standard for chess positions, we&rsquo;ll use a more computation-friendly format internally."><meta name=author content><link rel=canonical href=https://manuelfedele.github.io/posts/evaluate-chess-position/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://manuelfedele.github.io/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://manuelfedele.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://manuelfedele.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/img/apple-touch-icon-144-precomposed.png><link rel=mask-icon href=https://manuelfedele.github.io/img/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://manuelfedele.github.io/posts/evaluate-chess-position/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=google-site-verification content="bNHRtbwz1iqFFQ60i1jOBm2U7WHWMc8LgejU7wLaDSs"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><meta property="og:url" content="https://manuelfedele.github.io/posts/evaluate-chess-position/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:title" content="Building a Chess Engine - From Position Evaluation to Search Techniques"><meta property="og:description" content="Building a Chess Engine: From Position Evaluation to Search Techniques Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position evaluation and search strategies.
Part 1: Basic Position Representation First, let’s implement a basic board representation. While FEN (Forsyth–Edwards Notation) is the standard for chess positions, we’ll use a more computation-friendly format internally."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-27T17:33:00+00:00"><meta property="article:modified_time" content="2024-11-27T17:33:00+00:00"><meta property="article:tag" content="Golang"><meta property="og:image" content="https://manuelfedele.github.io/img/card-pillow.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://manuelfedele.github.io/img/card-pillow.jpg"><meta name=twitter:title content="Building a Chess Engine - From Position Evaluation to Search Techniques"><meta name=twitter:description content="Building a Chess Engine: From Position Evaluation to Search Techniques
Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position evaluation and search strategies.
Part 1: Basic Position Representation
First, let&rsquo;s implement a basic board representation. While FEN (Forsyth–Edwards Notation) is the standard for chess positions, we&rsquo;ll use a more computation-friendly format internally."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://manuelfedele.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Building a Chess Engine - From Position Evaluation to Search Techniques","item":"https://manuelfedele.github.io/posts/evaluate-chess-position/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building a Chess Engine - From Position Evaluation to Search Techniques","name":"Building a Chess Engine - From Position Evaluation to Search Techniques","description":"Building a Chess Engine: From Position Evaluation to Search Techniques Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position evaluation and search strategies.\nPart 1: Basic Position Representation First, let\u0026rsquo;s implement a basic board representation. While FEN (Forsyth–Edwards Notation) is the standard for chess positions, we\u0026rsquo;ll use a more computation-friendly format internally.\n","keywords":["golang"],"articleBody":"Building a Chess Engine: From Position Evaluation to Search Techniques Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position evaluation and search strategies.\nPart 1: Basic Position Representation First, let’s implement a basic board representation. While FEN (Forsyth–Edwards Notation) is the standard for chess positions, we’ll use a more computation-friendly format internally.\npackage chess // Piece constants const ( Empty = iota Pawn Knight Bishop Rook Queen King ) // Color constants const ( White = 1 Black = -1 ) // Position represents a chess position type Position struct { Board [64]int // Piece type (0-6) Colors [64]int // Piece color (1 for white, -1 for black) ToMove int // Side to move CastlingRights int // Castling availability EnPassant int // En passant target square HalfMoveClock int // Halfmove clock for fifty-move rule FullMoveNumber int // Fullmove number } // Square converts file (a-h) and rank (1-8) to board index func Square(file byte, rank int) int { return (rank-1)*8 + int(file-'a') } // NewPosition creates a starting chess position func NewPosition() *Position { pos := \u0026Position{ ToMove: White, CastlingRights: 0xF, // All castling rights available } // Initialize starting position // Back rank pieces backRank := []int{Rook, Knight, Bishop, Queen, King, Bishop, Knight, Rook} for i, piece := range backRank { // White pieces pos.Board[i] = piece pos.Colors[i] = White // Black pieces pos.Board[i+56] = piece pos.Colors[i+56] = Black } // Pawns for i := 0; i \u003c 8; i++ { // White pawns pos.Board[i+8] = Pawn pos.Colors[i+8] = White // Black pawns pos.Board[i+48] = Pawn pos.Colors[i+48] = Black } return pos } Part 2: Position Evaluation Position evaluation is crucial for a chess engine. We’ll implement several evaluation components:\nMaterial count Piece position tables Pawn structure evaluation King safety Mobility evaluation // Piece values in centipawns var pieceValues = map[int]int{ Pawn: 100, Knight: 320, Bishop: 330, Rook: 500, Queen: 900, King: 20000, } // Piece-Square tables for position evaluation var pawnTable = [64]int{ 0, 0, 0, 0, 0, 0, 0, 0, 50, 50, 50, 50, 50, 50, 50, 50, 10, 10, 20, 30, 30, 20, 10, 10, 5, 5, 10, 25, 25, 10, 5, 5, 0, 0, 0, 20, 20, 0, 0, 0, 5, -5,-10, 0, 0,-10, -5, 5, 5, 10, 10,-20,-20, 10, 10, 5, 0, 0, 0, 0, 0, 0, 0, 0, } // Similar tables for other pieces... type Evaluator struct { pos *Position stage GameStage } // Evaluate returns a position score in centipawns // Positive scores favor White, negative scores favor Black func (e *Evaluator) Evaluate() int { score := 0 // Material evaluation score += e.evaluateMaterial() // Piece-square table evaluation score += e.evaluatePiecePositions() // Pawn structure evaluation score += e.evaluatePawnStructure() // King safety score += e.evaluateKingSafety() // Mobility score += e.evaluateMobility() return score * e.pos.ToMove } func (e *Evaluator) evaluateMaterial() int { score := 0 for sq := 0; sq \u003c 64; sq++ { if piece := e.pos.Board[sq]; piece != Empty { score += pieceValues[piece] * e.pos.Colors[sq] } } return score } func (e *Evaluator) evaluatePawnStructure() int { score := 0 // Evaluate doubled pawns for file := 0; file \u003c 8; file++ { whitePawns := 0 blackPawns := 0 for rank := 0; rank \u003c 8; rank++ { sq := rank*8 + file if e.pos.Board[sq] == Pawn { if e.pos.Colors[sq] == White { whitePawns++ } else { blackPawns++ } } } // Penalty for doubled pawns if whitePawns \u003e 1 { score -= 20 * (whitePawns - 1) } if blackPawns \u003e 1 { score += 20 * (blackPawns - 1) } } // Evaluate isolated pawns for file := 0; file \u003c 8; file++ { hasWhitePawn := false hasBlackPawn := false for rank := 0; rank \u003c 8; rank++ { sq := rank*8 + file if e.pos.Board[sq] == Pawn { if e.pos.Colors[sq] == White { hasWhitePawn = true } else { hasBlackPawn = true } } } if hasWhitePawn { isIsolated := true if file \u003e 0 { // Check left file for pawns for rank := 0; rank \u003c 8; rank++ { sq := rank*8 + (file-1) if e.pos.Board[sq] == Pawn \u0026\u0026 e.pos.Colors[sq] == White { isIsolated = false break } } } if file \u003c 7 \u0026\u0026 isIsolated { // Check right file for pawns for rank := 0; rank \u003c 8; rank++ { sq := rank*8 + (file+1) if e.pos.Board[sq] == Pawn \u0026\u0026 e.pos.Colors[sq] == White { isIsolated = false break } } } if isIsolated { score -= 15 // Penalty for isolated pawn } } // Similar check for black pawns... } return score } func (e *Evaluator) evaluateKingSafety() int { score := 0 // Find king positions var whiteKingSq, blackKingSq int for sq := 0; sq \u003c 64; sq++ { if e.pos.Board[sq] == King { if e.pos.Colors[sq] == White { whiteKingSq = sq } else { blackKingSq = sq } } } // Evaluate pawn shield score += e.evaluatePawnShield(whiteKingSq, White) score -= e.evaluatePawnShield(blackKingSq, Black) // Evaluate king tropism (enemy pieces' distance to king) score += e.evaluateKingTropism(whiteKingSq, blackKingSq) return score } func (e *Evaluator) evaluatePawnShield(kingSq, color int) int { score := 0 rank := kingSq / 8 file := kingSq % 8 // Check pawns in front of king pawnShieldSquares := []int{ Square(byte('a'+file-1), rank+1), Square(byte('a'+file), rank+1), Square(byte('a'+file+1), rank+1), } for _, sq := range pawnShieldSquares { if sq \u003e= 0 \u0026\u0026 sq \u003c 64 { if e.pos.Board[sq] == Pawn \u0026\u0026 e.pos.Colors[sq] == color { score += 10 // Bonus for each pawn shield } } } return score } Part 3: Search Implementation Now let’s implement the search algorithm. We’ll use alpha-beta pruning with various enhancements:\nPrincipal Variation Search Quiescence Search Move Ordering Transposition Table type SearchInfo struct { Depth int NodesSearched int64 StartTime time.Time StopTime time.Time Stopped bool } type TranspositionEntry struct { Hash uint64 Depth int Score int Type int // EXACT, ALPHA, or BETA Move Move } const ( EXACT = iota ALPHA BETA ) func (e *Engine) Search(pos *Position, depth int) (bestMove Move, score int) { info := \u0026SearchInfo{ Depth: depth, StartTime: time.Now(), StopTime: time.Now().Add(5 * time.Second), // 5 second time control } alpha := -infinity beta := infinity // Iterative deepening for currentDepth := 1; currentDepth \u003c= depth; currentDepth++ { score = e.alphaBeta(pos, currentDepth, alpha, beta, info) // Check if search should be stopped if info.Stopped { break } // Get best move from transposition table bestMove = e.tt.GetMove(pos.Hash()) } return bestMove, score } func (e *Engine) alphaBeta(pos *Position, depth, alpha, beta int, info *SearchInfo) int { info.NodesSearched++ // Check for time if time.Now().After(info.StopTime) { info.Stopped = true return 0 } // Check transposition table if entry, found := e.tt.Get(pos.Hash()); found { if entry.Depth \u003e= depth { if entry.Type == EXACT { return entry.Score } if entry.Type == ALPHA \u0026\u0026 entry.Score \u003c= alpha { return alpha } if entry.Type == BETA \u0026\u0026 entry.Score \u003e= beta { return beta } } } // Base case: evaluate position if depth == 0 { return e.quiescence(pos, alpha, beta, info) } moves := e.generateMoves(pos) moves = e.orderMoves(pos, moves) // Order moves for better pruning bestScore := -infinity for _, move := range moves { newPos := pos.MakeMove(move) score := -e.alphaBeta(newPos, depth-1, -beta, -alpha, info) if score \u003e bestScore { bestScore = score // Update transposition table e.tt.Store(pos.Hash(), TranspositionEntry{ Hash: pos.Hash(), Depth: depth, Score: score, Type: EXACT, Move: move, }) } alpha = max(alpha, score) if alpha \u003e= beta { break // Beta cutoff } } return bestScore } func (e *Engine) quiescence(pos *Position, alpha, beta int, info *SearchInfo) int { info.NodesSearched++ standPat := e.evaluate(pos) if standPat \u003e= beta { return beta } if alpha \u003c standPat { alpha = standPat } // Generate capturing moves only captures := e.generateCaptures(pos) captures = e.orderMoves(pos, captures) for _, move := range captures { newPos := pos.MakeMove(move) score := -e.quiescence(newPos, -beta, -alpha, info) if score \u003e= beta { return beta } if score \u003e alpha { alpha = score } } return alpha } func (e *Engine) orderMoves(pos *Position, moves []Move) []Move { // Score moves for ordering type ScoredMove struct { move Move score int } scoredMoves := make([]ScoredMove, len(moves)) for i, move := range moves { score := 0 // TTMove bonus if ttMove, found := e.tt.GetMove(pos.Hash()); found \u0026\u0026 move == ttMove { score += 10000 } // MVV/LVA (Most Valuable Victim / Least Valuable Attacker) if move.IsCapture() { victim := pos.Board[move.To()] attacker := pos.Board[move.From()] score += pieceValues[victim] - pieceValues[attacker]/10 } // Killer move bonus if e.isKillerMove(move, pos.Ply()) { score += 900 } // History heuristic score += e.history[move.From()][move.To()] scoredMoves[i] = ScoredMove{move, score} } // Sort moves by score sort.Slice(scoredMoves, func(i, j int) bool { return scoredMoves[i].score \u003e scoredMoves[j].score }) // Extract sorted moves sortedMoves := make([]Move, len(moves)) for i, sm := range scoredMoves { sortedMoves[i] = sm.move } return sortedMoves } Part 4: Advanced Evaluation Features Let’s enhance our evaluation with more sophisticated features:\nfunc (e *Evaluator) evaluateMobility() int { score := 0 // Piece mobility bonuses/penalties func (e *Evaluator) evaluateMobility() int { score := 0 // Mobility weights for each piece type mobilityWeights := map[int]int{ Knight: 4, Bishop: 5, Rook: 2, Queen: 1, } // Calculate mobility for both sides for sq := 0; sq \u003c 64; sq++ { piece := e.pos.Board[sq] color := e.pos.Colors[sq] if piece == Empty || piece == Pawn || piece == King { continue } moves := e.generatePieceMoves(sq) mobilityScore := len(moves) * mobilityWeights[piece] score += mobilityScore * color } return score } // Helper function to check piece attacks func (e *Evaluator) isSquareAttacked(sq, byColor int) bool { // Check pawn attacks pawnDir := -byColor // Pawns move in opposite direction of their color for _, offset := range []int{7, 9} { attackSq := sq + pawnDir*8 + offset if attackSq \u003e= 0 \u0026\u0026 attackSq \u003c 64 { if e.pos.Board[attackSq] == Pawn \u0026\u0026 e.pos.Colors[attackSq] == byColor { return true } } } // Check knight attacks knightOffsets := []int{-17, -15, -10, -6, 6, 10, 15, 17} for _, offset := range knightOffsets { attackSq := sq + offset if attackSq \u003e= 0 \u0026\u0026 attackSq \u003c 64 { if e.pos.Board[attackSq] == Knight \u0026\u0026 e.pos.Colors[attackSq] == byColor { return true } } } // Check sliding piece attacks (Bishop, Rook, Queen) directions := [][]int{ {-1, -1}, {-1, 1}, {1, -1}, {1, 1}, // Bishop/Queen directions {-1, 0}, {1, 0}, {0, -1}, {0, 1}, // Rook/Queen directions } for _, dir := range directions { dx, dy := dir[0], dir[1] x, y := sq%8, sq/8 for i := 1; i \u003c 8; i++ { newX, newY := x+dx*i, y+dy*i if newX \u003c 0 || newX \u003e= 8 || newY \u003c 0 || newY \u003e= 8 { break } attackSq := newY*8 + newX piece := e.pos.Board[attackSq] if piece != Empty { if e.pos.Colors[attackSq] == byColor { // Check if piece can move in this direction if piece == Queen || (piece == Rook \u0026\u0026 (dx == 0 || dy == 0)) || (piece == Bishop \u0026\u0026 dx != 0 \u0026\u0026 dy != 0) { return true } } break } } } return false } Part 5: Advanced Search Techniques Let’s implement some advanced search techniques to improve the engine’s strength:\n// Null Move Pruning func (e *Engine) alphaBetaWithNullMove(pos *Position, depth, alpha, beta int, info *SearchInfo) int { if depth \u003e= 3 \u0026\u0026 !pos.InCheck() \u0026\u0026 pos.HasNonPawnMaterial() { // Make null move newPos := pos.MakeNullMove() // Reduced depth for null move search R := 2 + depth/4 // Recursive search with reduced depth score := -e.alphaBeta(newPos, depth-R-1, -beta, -beta+1, info) if score \u003e= beta { return beta // Null move cutoff } } // Continue with regular alpha-beta search... return e.alphaBeta(pos, depth, alpha, beta, info) } // Late Move Reduction func (e *Engine) alphaBetaWithLMR(pos *Position, depth, alpha, beta int, moveCount int, info *SearchInfo) int { if depth \u003e= 3 \u0026\u0026 moveCount \u003e= 4 \u0026\u0026 !pos.InCheck() { // Reduce depth for late moves reduction := 1 if moveCount \u003e= 6 { reduction++ } // Reduced depth search score := -e.alphaBeta(pos, depth-reduction-1, -alpha-1, -alpha, info) // If reduced search fails high, do a full depth search if score \u003e alpha { return -e.alphaBeta(pos, depth-1, -beta, -alpha, info) } return score } // Continue with regular search... return -e.alphaBeta(pos, depth-1, -beta, -alpha, info) } // Aspiration Windows func (e *Engine) searchWithAspirationWindows(pos *Position, depth int, info *SearchInfo) int { score := 0 alpha := -infinity beta := infinity window := 50 // Initial window size in centipawns // First search with full window score = e.alphaBeta(pos, depth, alpha, beta, info) // Subsequent searches with aspiration windows for currentDepth := 2; currentDepth \u003c= depth; currentDepth++ { alpha = score - window beta = score + window score = e.alphaBeta(pos, currentDepth, alpha, beta, info) if score \u003c= alpha || score \u003e= beta { // Window failed, retry with larger window window *= 2 score = e.alphaBeta(pos, currentDepth, -infinity, infinity, info) } window = 50 // Reset window size for next iteration } return score } Part 6: Time Management Proper time management is crucial for tournament play:\ntype TimeManager struct { InitialTime time.Duration Increment time.Duration MovesToGo int MaxMoveTime time.Duration } func NewTimeManager(initialTime, increment time.Duration, movesToGo int) *TimeManager { return \u0026TimeManager{ InitialTime: initialTime, Increment: increment, MovesToGo: movesToGo, MaxMoveTime: initialTime / 20, // Don't use more than 5% of total time } } func (tm *TimeManager) allocateTime(pos *Position) time.Duration { // Basic time allocation baseTime := tm.InitialTime / time.Duration(tm.MovesToGo) // Adjust based on game phase gamePhase := evaluateGamePhase(pos) switch { case gamePhase \u003c 0.3: // Opening baseTime *= 8/10 case gamePhase \u003e 0.7: // Endgame baseTime *= 12/10 } // Add increment allocatedTime := baseTime + tm.Increment*8/10 // Never exceed maximum move time if allocatedTime \u003e tm.MaxMoveTime { allocatedTime = tm.MaxMoveTime } return allocatedTime } func evaluateGamePhase(pos *Position) float64 { // Count material to determine game phase totalMaterial := 0 maxMaterial := 0 for sq := 0; sq \u003c 64; sq++ { piece := pos.Board[sq] if piece != Empty \u0026\u0026 piece != King { totalMaterial += pieceValues[piece] maxMaterial += pieceValues[piece] } } // Return value between 0 (opening) and 1 (endgame) return 1.0 - float64(totalMaterial)/float64(maxMaterial) } Part 7: Opening Book and Endgame Tablebases For completeness, let’s add support for opening books and endgame tablebases:\ntype OpeningBook struct { positions map[uint64][]BookMove } type BookMove struct { Move Move Weight int } func (book *OpeningBook) GetBookMove(pos *Position) (Move, bool) { moves, exists := book.positions[pos.Hash()] if !exists { return Move{}, false } // Select move based on weights totalWeight := 0 for _, m := range moves { totalWeight += m.Weight } // Random selection weighted by frequency r := rand.Intn(totalWeight) currentWeight := 0 for _, m := range moves { currentWeight += m.Weight if r \u003c currentWeight { return m.Move, true } } return moves[0].Move, true } type Tablebase struct { cache map[uint64]TablebaseEntry } type TablebaseEntry struct { Score int BestMove Move DTM int // Distance to mate } func (tb *Tablebase) Probe(pos *Position) (TablebaseEntry, bool) { // Probe tablebase cache if entry, exists := tb.cache[pos.Hash()]; exists { return entry, true } // Only probe for positions with 6 or fewer pieces if pos.PieceCount() \u003e 6 { return TablebaseEntry{}, false } // Here you would implement actual tablebase probing // This typically involves accessing Syzygy or Gaviota tablebases return TablebaseEntry{}, false } Conclusion Building a chess engine involves multiple complex components working together:\nBoard Representation: Efficient position storage and move generation Evaluation: Material, piece placement, pawn structure, king safety, and mobility Search: Alpha-beta pruning with enhancements (null move, LMR, aspiration windows) Time Management: Adaptive time allocation based on position and game phase Opening/Endgame: Book moves and tablebase access for perfect play Future improvements could include:\nNeural network evaluation Multi-threaded search Supervised learning from master games NNUE (Efficiently Updatable Neural Network) evaluation Advanced pruning techniques (Futility pruning, SEE, etc.) Contempt factor for tournament play Remember that chess programming is an iterative process. Start with the basics and gradually add more sophisticated features while testing against other engines to measure improvement.\nReferences Chess Programming Wiki Stockfish GitHub Repository “How Computers Play Chess” by David Levy and Monty Newborn “Chess Programming” by François-Dominic Laramée ","wordCount":"2695","inLanguage":"en","image":"https://manuelfedele.github.io/img/card-pillow.jpg","datePublished":"2024-11-27T17:33:00Z","dateModified":"2024-11-27T17:33:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://manuelfedele.github.io/posts/evaluate-chess-position/"},"publisher":{"@type":"Organization","name":"Git Push and Run","logo":{"@type":"ImageObject","url":"https://manuelfedele.github.io/img/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://manuelfedele.github.io/ accesskey=h title="Git Push and Run (Alt + H)"><img src=https://manuelfedele.github.io/img/apple-touch-icon-144-precomposed.png alt aria-label=logo height=25>Git Push and Run</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://manuelfedele.github.io/ title=Home><span>Home</span></a></li><li><a href=https://manuelfedele.github.io/search/ title=Search><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://manuelfedele.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://manuelfedele.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Building a Chess Engine - From Position Evaluation to Search Techniques</h1><div class=post-meta><span title='2024-11-27 17:33:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2695 words</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#part-1-basic-position-representation>Part 1: Basic Position Representation</a></li><li><a href=#part-2-position-evaluation>Part 2: Position Evaluation</a></li><li><a href=#part-3-search-implementation>Part 3: Search Implementation</a></li><li><a href=#part-4-advanced-evaluation-features>Part 4: Advanced Evaluation Features</a></li><li><a href=#part-5-advanced-search-techniques>Part 5: Advanced Search Techniques</a></li><li><a href=#part-6-time-management>Part 6: Time Management</a></li><li><a href=#part-7-opening-book-and-endgame-tablebases>Part 7: Opening Book and Endgame Tablebases</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h1 id=building-a-chess-engine-from-position-evaluation-to-search-techniques>Building a Chess Engine: From Position Evaluation to Search Techniques<a hidden class=anchor aria-hidden=true href=#building-a-chess-engine-from-position-evaluation-to-search-techniques>#</a></h1><p>Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position evaluation and search strategies.</p><h2 id=part-1-basic-position-representation>Part 1: Basic Position Representation<a hidden class=anchor aria-hidden=true href=#part-1-basic-position-representation>#</a></h2><p>First, let&rsquo;s implement a basic board representation. While FEN (Forsyth–Edwards Notation) is the standard for chess positions, we&rsquo;ll use a more computation-friendly format internally.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>chess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Piece constants
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>Empty</span> <span class=p>=</span> <span class=kc>iota</span>
</span></span><span class=line><span class=cl>    <span class=nx>Pawn</span>
</span></span><span class=line><span class=cl>    <span class=nx>Knight</span>
</span></span><span class=line><span class=cl>    <span class=nx>Bishop</span>
</span></span><span class=line><span class=cl>    <span class=nx>Rook</span>
</span></span><span class=line><span class=cl>    <span class=nx>Queen</span>
</span></span><span class=line><span class=cl>    <span class=nx>King</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Color constants
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>White</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>Black</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Position represents a chess position
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Position</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Board</span>    <span class=p>[</span><span class=mi>64</span><span class=p>]</span><span class=kt>int</span>    <span class=c1>// Piece type (0-6)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Colors</span>   <span class=p>[</span><span class=mi>64</span><span class=p>]</span><span class=kt>int</span>    <span class=c1>// Piece color (1 for white, -1 for black)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ToMove</span>   <span class=kt>int</span>        <span class=c1>// Side to move
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>CastlingRights</span> <span class=kt>int</span>  <span class=c1>// Castling availability
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>EnPassant</span>    <span class=kt>int</span>    <span class=c1>// En passant target square
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>HalfMoveClock</span> <span class=kt>int</span>   <span class=c1>// Halfmove clock for fifty-move rule
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>FullMoveNumber</span> <span class=kt>int</span>  <span class=c1>// Fullmove number
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Square converts file (a-h) and rank (1-8) to board index
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Square</span><span class=p>(</span><span class=nx>file</span> <span class=kt>byte</span><span class=p>,</span> <span class=nx>rank</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=nx>rank</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=o>*</span><span class=mi>8</span> <span class=o>+</span> <span class=nb>int</span><span class=p>(</span><span class=nx>file</span><span class=o>-</span><span class=sc>&#39;a&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// NewPosition creates a starting chess position
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>NewPosition</span><span class=p>()</span> <span class=o>*</span><span class=nx>Position</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>pos</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Position</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ToMove</span><span class=p>:</span> <span class=nx>White</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>CastlingRights</span><span class=p>:</span> <span class=mh>0xF</span><span class=p>,</span> <span class=c1>// All castling rights available
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Initialize starting position
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Back rank pieces
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>backRank</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=nx>Rook</span><span class=p>,</span> <span class=nx>Knight</span><span class=p>,</span> <span class=nx>Bishop</span><span class=p>,</span> <span class=nx>Queen</span><span class=p>,</span> <span class=nx>King</span><span class=p>,</span> <span class=nx>Bishop</span><span class=p>,</span> <span class=nx>Knight</span><span class=p>,</span> <span class=nx>Rook</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>piece</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>backRank</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// White pieces
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>piece</span>
</span></span><span class=line><span class=cl>        <span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>White</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Black pieces
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>56</span><span class=p>]</span> <span class=p>=</span> <span class=nx>piece</span>
</span></span><span class=line><span class=cl>        <span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>56</span><span class=p>]</span> <span class=p>=</span> <span class=nx>Black</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Pawns
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// White pawns
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>8</span><span class=p>]</span> <span class=p>=</span> <span class=nx>Pawn</span>
</span></span><span class=line><span class=cl>        <span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>8</span><span class=p>]</span> <span class=p>=</span> <span class=nx>White</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Black pawns
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>48</span><span class=p>]</span> <span class=p>=</span> <span class=nx>Pawn</span>
</span></span><span class=line><span class=cl>        <span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>48</span><span class=p>]</span> <span class=p>=</span> <span class=nx>Black</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>pos</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=part-2-position-evaluation>Part 2: Position Evaluation<a hidden class=anchor aria-hidden=true href=#part-2-position-evaluation>#</a></h2><p>Position evaluation is crucial for a chess engine. We&rsquo;ll implement several evaluation components:</p><ol><li>Material count</li><li>Piece position tables</li><li>Pawn structure evaluation</li><li>King safety</li><li>Mobility evaluation</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Piece values in centipawns
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>pieceValues</span> <span class=p>=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Pawn</span><span class=p>:</span>   <span class=mi>100</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Knight</span><span class=p>:</span> <span class=mi>320</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Bishop</span><span class=p>:</span> <span class=mi>330</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Rook</span><span class=p>:</span>   <span class=mi>500</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Queen</span><span class=p>:</span>  <span class=mi>900</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>King</span><span class=p>:</span>   <span class=mi>20000</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Piece-Square tables for position evaluation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>pawnTable</span> <span class=p>=</span> <span class=p>[</span><span class=mi>64</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mi>50</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=mi>5</span><span class=p>,</span>  <span class=mi>5</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>25</span><span class=p>,</span> <span class=mi>25</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span>  <span class=mi>5</span><span class=p>,</span>  <span class=mi>5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=mi>5</span><span class=p>,</span> <span class=o>-</span><span class=mi>5</span><span class=p>,</span><span class=o>-</span><span class=mi>10</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span><span class=o>-</span><span class=mi>10</span><span class=p>,</span> <span class=o>-</span><span class=mi>5</span><span class=p>,</span>  <span class=mi>5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=mi>5</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span><span class=o>-</span><span class=mi>20</span><span class=p>,</span><span class=o>-</span><span class=mi>20</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span>  <span class=mi>5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Similar tables for other pieces...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Evaluator</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span>
</span></span><span class=line><span class=cl>    <span class=nx>stage</span> <span class=nx>GameStage</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Evaluate returns a position score in centipawns
</span></span></span><span class=line><span class=cl><span class=c1>// Positive scores favor White, negative scores favor Black
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Evaluator</span><span class=p>)</span> <span class=nf>Evaluate</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>score</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Material evaluation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>score</span> <span class=o>+=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>evaluateMaterial</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Piece-square table evaluation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>score</span> <span class=o>+=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>evaluatePiecePositions</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Pawn structure evaluation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>score</span> <span class=o>+=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>evaluatePawnStructure</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// King safety
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>score</span> <span class=o>+=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>evaluateKingSafety</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Mobility
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>score</span> <span class=o>+=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>evaluateMobility</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>score</span> <span class=o>*</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>ToMove</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Evaluator</span><span class=p>)</span> <span class=nf>evaluateMaterial</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>score</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>sq</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>sq</span> <span class=p>&lt;</span> <span class=mi>64</span><span class=p>;</span> <span class=nx>sq</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>piece</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>sq</span><span class=p>];</span> <span class=nx>piece</span> <span class=o>!=</span> <span class=nx>Empty</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>score</span> <span class=o>+=</span> <span class=nx>pieceValues</span><span class=p>[</span><span class=nx>piece</span><span class=p>]</span> <span class=o>*</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>score</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Evaluator</span><span class=p>)</span> <span class=nf>evaluatePawnStructure</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>score</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Evaluate doubled pawns
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>file</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>file</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>file</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>whitePawns</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=nx>blackPawns</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>rank</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>rank</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>rank</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>sq</span> <span class=o>:=</span> <span class=nx>rank</span><span class=o>*</span><span class=mi>8</span> <span class=o>+</span> <span class=nx>file</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>Pawn</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>White</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>whitePawns</span><span class=o>++</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>blackPawns</span><span class=o>++</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Penalty for doubled pawns
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>whitePawns</span> <span class=p>&gt;</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>score</span> <span class=o>-=</span> <span class=mi>20</span> <span class=o>*</span> <span class=p>(</span><span class=nx>whitePawns</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>blackPawns</span> <span class=p>&gt;</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>20</span> <span class=o>*</span> <span class=p>(</span><span class=nx>blackPawns</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Evaluate isolated pawns
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>file</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>file</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>file</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>hasWhitePawn</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=nx>hasBlackPawn</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>rank</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>rank</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>rank</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>sq</span> <span class=o>:=</span> <span class=nx>rank</span><span class=o>*</span><span class=mi>8</span> <span class=o>+</span> <span class=nx>file</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>Pawn</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>White</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>hasWhitePawn</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>hasBlackPawn</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>hasWhitePawn</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>isIsolated</span> <span class=o>:=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>file</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Check left file for pawns
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>for</span> <span class=nx>rank</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>rank</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>rank</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>sq</span> <span class=o>:=</span> <span class=nx>rank</span><span class=o>*</span><span class=mi>8</span> <span class=o>+</span> <span class=p>(</span><span class=nx>file</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>Pawn</span> <span class=o>&amp;&amp;</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>White</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>isIsolated</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>                        <span class=k>break</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>file</span> <span class=p>&lt;</span> <span class=mi>7</span> <span class=o>&amp;&amp;</span> <span class=nx>isIsolated</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Check right file for pawns
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>for</span> <span class=nx>rank</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>rank</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>rank</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>sq</span> <span class=o>:=</span> <span class=nx>rank</span><span class=o>*</span><span class=mi>8</span> <span class=o>+</span> <span class=p>(</span><span class=nx>file</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>Pawn</span> <span class=o>&amp;&amp;</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>White</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>isIsolated</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>                        <span class=k>break</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>isIsolated</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>score</span> <span class=o>-=</span> <span class=mi>15</span> <span class=c1>// Penalty for isolated pawn
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Similar check for black pawns...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>score</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Evaluator</span><span class=p>)</span> <span class=nf>evaluateKingSafety</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>score</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Find king positions
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>whiteKingSq</span><span class=p>,</span> <span class=nx>blackKingSq</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>sq</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>sq</span> <span class=p>&lt;</span> <span class=mi>64</span><span class=p>;</span> <span class=nx>sq</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>King</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>White</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>whiteKingSq</span> <span class=p>=</span> <span class=nx>sq</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>blackKingSq</span> <span class=p>=</span> <span class=nx>sq</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Evaluate pawn shield
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>score</span> <span class=o>+=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>evaluatePawnShield</span><span class=p>(</span><span class=nx>whiteKingSq</span><span class=p>,</span> <span class=nx>White</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>score</span> <span class=o>-=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>evaluatePawnShield</span><span class=p>(</span><span class=nx>blackKingSq</span><span class=p>,</span> <span class=nx>Black</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Evaluate king tropism (enemy pieces&#39; distance to king)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>score</span> <span class=o>+=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>evaluateKingTropism</span><span class=p>(</span><span class=nx>whiteKingSq</span><span class=p>,</span> <span class=nx>blackKingSq</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>score</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Evaluator</span><span class=p>)</span> <span class=nf>evaluatePawnShield</span><span class=p>(</span><span class=nx>kingSq</span><span class=p>,</span> <span class=nx>color</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>score</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nx>rank</span> <span class=o>:=</span> <span class=nx>kingSq</span> <span class=o>/</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl>    <span class=nx>file</span> <span class=o>:=</span> <span class=nx>kingSq</span> <span class=o>%</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check pawns in front of king
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pawnShieldSquares</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>Square</span><span class=p>(</span><span class=nb>byte</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=o>+</span><span class=nx>file</span><span class=o>-</span><span class=mi>1</span><span class=p>),</span> <span class=nx>rank</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=nf>Square</span><span class=p>(</span><span class=nb>byte</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=o>+</span><span class=nx>file</span><span class=p>),</span> <span class=nx>rank</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=nf>Square</span><span class=p>(</span><span class=nb>byte</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=o>+</span><span class=nx>file</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span> <span class=nx>rank</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>sq</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pawnShieldSquares</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>sq</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>sq</span> <span class=p>&lt;</span> <span class=mi>64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>Pawn</span> <span class=o>&amp;&amp;</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>score</span> <span class=o>+=</span> <span class=mi>10</span> <span class=c1>// Bonus for each pawn shield
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>score</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=part-3-search-implementation>Part 3: Search Implementation<a hidden class=anchor aria-hidden=true href=#part-3-search-implementation>#</a></h2><p>Now let&rsquo;s implement the search algorithm. We&rsquo;ll use alpha-beta pruning with various enhancements:</p><ol><li>Principal Variation Search</li><li>Quiescence Search</li><li>Move Ordering</li><li>Transposition Table</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SearchInfo</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Depth</span>      <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>NodesSearched</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>    <span class=nx>StartTime</span>  <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
</span></span><span class=line><span class=cl>    <span class=nx>StopTime</span>   <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
</span></span><span class=line><span class=cl>    <span class=nx>Stopped</span>    <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TranspositionEntry</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Hash</span>    <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>    <span class=nx>Depth</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Score</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Type</span>    <span class=kt>int</span> <span class=c1>// EXACT, ALPHA, or BETA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Move</span>    <span class=nx>Move</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>EXACT</span> <span class=p>=</span> <span class=kc>iota</span>
</span></span><span class=line><span class=cl>    <span class=nx>ALPHA</span>
</span></span><span class=line><span class=cl>    <span class=nx>BETA</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Engine</span><span class=p>)</span> <span class=nf>Search</span><span class=p>(</span><span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span><span class=p>,</span> <span class=nx>depth</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>bestMove</span> <span class=nx>Move</span><span class=p>,</span> <span class=nx>score</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>info</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>SearchInfo</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Depth</span><span class=p>:</span>     <span class=nx>depth</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>StartTime</span><span class=p>:</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=nx>StopTime</span><span class=p>:</span>  <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>5</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>),</span> <span class=c1>// 5 second time control
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>alpha</span> <span class=o>:=</span> <span class=o>-</span><span class=nx>infinity</span>
</span></span><span class=line><span class=cl>    <span class=nx>beta</span> <span class=o>:=</span> <span class=nx>infinity</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Iterative deepening
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>currentDepth</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>currentDepth</span> <span class=o>&lt;=</span> <span class=nx>depth</span><span class=p>;</span> <span class=nx>currentDepth</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>score</span> <span class=p>=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>alphaBeta</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>currentDepth</span><span class=p>,</span> <span class=nx>alpha</span><span class=p>,</span> <span class=nx>beta</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Check if search should be stopped
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>info</span><span class=p>.</span><span class=nx>Stopped</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Get best move from transposition table
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>bestMove</span> <span class=p>=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>tt</span><span class=p>.</span><span class=nf>GetMove</span><span class=p>(</span><span class=nx>pos</span><span class=p>.</span><span class=nf>Hash</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>bestMove</span><span class=p>,</span> <span class=nx>score</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Engine</span><span class=p>)</span> <span class=nf>alphaBeta</span><span class=p>(</span><span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span><span class=p>,</span> <span class=nx>depth</span><span class=p>,</span> <span class=nx>alpha</span><span class=p>,</span> <span class=nx>beta</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>info</span> <span class=o>*</span><span class=nx>SearchInfo</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>info</span><span class=p>.</span><span class=nx>NodesSearched</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check for time
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>After</span><span class=p>(</span><span class=nx>info</span><span class=p>.</span><span class=nx>StopTime</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>info</span><span class=p>.</span><span class=nx>Stopped</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check transposition table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>entry</span><span class=p>,</span> <span class=nx>found</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>tt</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>pos</span><span class=p>.</span><span class=nf>Hash</span><span class=p>());</span> <span class=nx>found</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>entry</span><span class=p>.</span><span class=nx>Depth</span> <span class=o>&gt;=</span> <span class=nx>depth</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>entry</span><span class=p>.</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>EXACT</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nx>entry</span><span class=p>.</span><span class=nx>Score</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>entry</span><span class=p>.</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>ALPHA</span> <span class=o>&amp;&amp;</span> <span class=nx>entry</span><span class=p>.</span><span class=nx>Score</span> <span class=o>&lt;=</span> <span class=nx>alpha</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nx>alpha</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>entry</span><span class=p>.</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>BETA</span> <span class=o>&amp;&amp;</span> <span class=nx>entry</span><span class=p>.</span><span class=nx>Score</span> <span class=o>&gt;=</span> <span class=nx>beta</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nx>beta</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Base case: evaluate position
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>depth</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>e</span><span class=p>.</span><span class=nf>quiescence</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>alpha</span><span class=p>,</span> <span class=nx>beta</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>moves</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>generateMoves</span><span class=p>(</span><span class=nx>pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>moves</span> <span class=p>=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>orderMoves</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>moves</span><span class=p>)</span> <span class=c1>// Order moves for better pruning
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=nx>bestScore</span> <span class=o>:=</span> <span class=o>-</span><span class=nx>infinity</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>move</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>moves</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>newPos</span> <span class=o>:=</span> <span class=nx>pos</span><span class=p>.</span><span class=nf>MakeMove</span><span class=p>(</span><span class=nx>move</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>score</span> <span class=o>:=</span> <span class=o>-</span><span class=nx>e</span><span class=p>.</span><span class=nf>alphaBeta</span><span class=p>(</span><span class=nx>newPos</span><span class=p>,</span> <span class=nx>depth</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=nx>beta</span><span class=p>,</span> <span class=o>-</span><span class=nx>alpha</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>score</span> <span class=p>&gt;</span> <span class=nx>bestScore</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>bestScore</span> <span class=p>=</span> <span class=nx>score</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1>// Update transposition table
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>e</span><span class=p>.</span><span class=nx>tt</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>pos</span><span class=p>.</span><span class=nf>Hash</span><span class=p>(),</span> <span class=nx>TranspositionEntry</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>Hash</span><span class=p>:</span>  <span class=nx>pos</span><span class=p>.</span><span class=nf>Hash</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>                <span class=nx>Depth</span><span class=p>:</span> <span class=nx>depth</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>Score</span><span class=p>:</span> <span class=nx>score</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>Type</span><span class=p>:</span>  <span class=nx>EXACT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>Move</span><span class=p>:</span>  <span class=nx>move</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nx>alpha</span> <span class=p>=</span> <span class=nb>max</span><span class=p>(</span><span class=nx>alpha</span><span class=p>,</span> <span class=nx>score</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>alpha</span> <span class=o>&gt;=</span> <span class=nx>beta</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span> <span class=c1>// Beta cutoff
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>bestScore</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Engine</span><span class=p>)</span> <span class=nf>quiescence</span><span class=p>(</span><span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span><span class=p>,</span> <span class=nx>alpha</span><span class=p>,</span> <span class=nx>beta</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>info</span> <span class=o>*</span><span class=nx>SearchInfo</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>info</span><span class=p>.</span><span class=nx>NodesSearched</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>standPat</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>evaluate</span><span class=p>(</span><span class=nx>pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>standPat</span> <span class=o>&gt;=</span> <span class=nx>beta</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>beta</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>alpha</span> <span class=p>&lt;</span> <span class=nx>standPat</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>alpha</span> <span class=p>=</span> <span class=nx>standPat</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Generate capturing moves only
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>captures</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>generateCaptures</span><span class=p>(</span><span class=nx>pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>captures</span> <span class=p>=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>orderMoves</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>captures</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>move</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>captures</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>newPos</span> <span class=o>:=</span> <span class=nx>pos</span><span class=p>.</span><span class=nf>MakeMove</span><span class=p>(</span><span class=nx>move</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>score</span> <span class=o>:=</span> <span class=o>-</span><span class=nx>e</span><span class=p>.</span><span class=nf>quiescence</span><span class=p>(</span><span class=nx>newPos</span><span class=p>,</span> <span class=o>-</span><span class=nx>beta</span><span class=p>,</span> <span class=o>-</span><span class=nx>alpha</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>score</span> <span class=o>&gt;=</span> <span class=nx>beta</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>beta</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>score</span> <span class=p>&gt;</span> <span class=nx>alpha</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>alpha</span> <span class=p>=</span> <span class=nx>score</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>alpha</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Engine</span><span class=p>)</span> <span class=nf>orderMoves</span><span class=p>(</span><span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span><span class=p>,</span> <span class=nx>moves</span> <span class=p>[]</span><span class=nx>Move</span><span class=p>)</span> <span class=p>[]</span><span class=nx>Move</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Score moves for ordering
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>type</span> <span class=nx>ScoredMove</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>move</span>  <span class=nx>Move</span>
</span></span><span class=line><span class=cl>        <span class=nx>score</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>scoredMoves</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>ScoredMove</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>moves</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>move</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>moves</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>score</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// TTMove bonus
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>ttMove</span><span class=p>,</span> <span class=nx>found</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>tt</span><span class=p>.</span><span class=nf>GetMove</span><span class=p>(</span><span class=nx>pos</span><span class=p>.</span><span class=nf>Hash</span><span class=p>());</span> <span class=nx>found</span> <span class=o>&amp;&amp;</span> <span class=nx>move</span> <span class=o>==</span> <span class=nx>ttMove</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>10000</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// MVV/LVA (Most Valuable Victim / Least Valuable Attacker)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>move</span><span class=p>.</span><span class=nf>IsCapture</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>victim</span> <span class=o>:=</span> <span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>move</span><span class=p>.</span><span class=nf>To</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>            <span class=nx>attacker</span> <span class=o>:=</span> <span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>move</span><span class=p>.</span><span class=nf>From</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>            <span class=nx>score</span> <span class=o>+=</span> <span class=nx>pieceValues</span><span class=p>[</span><span class=nx>victim</span><span class=p>]</span> <span class=o>-</span> <span class=nx>pieceValues</span><span class=p>[</span><span class=nx>attacker</span><span class=p>]</span><span class=o>/</span><span class=mi>10</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Killer move bonus
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nf>isKillerMove</span><span class=p>(</span><span class=nx>move</span><span class=p>,</span> <span class=nx>pos</span><span class=p>.</span><span class=nf>Ply</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>900</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// History heuristic
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>score</span> <span class=o>+=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>history</span><span class=p>[</span><span class=nx>move</span><span class=p>.</span><span class=nf>From</span><span class=p>()][</span><span class=nx>move</span><span class=p>.</span><span class=nf>To</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nx>scoredMoves</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>ScoredMove</span><span class=p>{</span><span class=nx>move</span><span class=p>,</span> <span class=nx>score</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Sort moves by score
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>sort</span><span class=p>.</span><span class=nf>Slice</span><span class=p>(</span><span class=nx>scoredMoves</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>scoredMoves</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>score</span> <span class=p>&gt;</span> <span class=nx>scoredMoves</span><span class=p>[</span><span class=nx>j</span><span class=p>].</span><span class=nx>score</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Extract sorted moves
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>sortedMoves</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>Move</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>moves</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>sm</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>scoredMoves</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>sortedMoves</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>sm</span><span class=p>.</span><span class=nx>move</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>sortedMoves</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=part-4-advanced-evaluation-features>Part 4: Advanced Evaluation Features<a hidden class=anchor aria-hidden=true href=#part-4-advanced-evaluation-features>#</a></h2><p>Let&rsquo;s enhance our evaluation with more sophisticated features:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Evaluator</span><span class=p>)</span> <span class=nf>evaluateMobility</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>score</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Piece mobility bonuses/penalties
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Evaluator</span><span class=p>)</span> <span class=nf>evaluateMobility</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>score</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Mobility weights for each piece type
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mobilityWeights</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Knight</span><span class=p>:</span> <span class=mi>4</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Bishop</span><span class=p>:</span> <span class=mi>5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Rook</span><span class=p>:</span>   <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Queen</span><span class=p>:</span>  <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate mobility for both sides
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>sq</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>sq</span> <span class=p>&lt;</span> <span class=mi>64</span><span class=p>;</span> <span class=nx>sq</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>piece</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>color</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>piece</span> <span class=o>==</span> <span class=nx>Empty</span> <span class=o>||</span> <span class=nx>piece</span> <span class=o>==</span> <span class=nx>Pawn</span> <span class=o>||</span> <span class=nx>piece</span> <span class=o>==</span> <span class=nx>King</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nx>moves</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>generatePieceMoves</span><span class=p>(</span><span class=nx>sq</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>mobilityScore</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>moves</span><span class=p>)</span> <span class=o>*</span> <span class=nx>mobilityWeights</span><span class=p>[</span><span class=nx>piece</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>score</span> <span class=o>+=</span> <span class=nx>mobilityScore</span> <span class=o>*</span> <span class=nx>color</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>score</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Helper function to check piece attacks
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Evaluator</span><span class=p>)</span> <span class=nf>isSquareAttacked</span><span class=p>(</span><span class=nx>sq</span><span class=p>,</span> <span class=nx>byColor</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Check pawn attacks
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pawnDir</span> <span class=o>:=</span> <span class=o>-</span><span class=nx>byColor</span> <span class=c1>// Pawns move in opposite direction of their color
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>offset</span> <span class=o>:=</span> <span class=k>range</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>7</span><span class=p>,</span> <span class=mi>9</span><span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>attackSq</span> <span class=o>:=</span> <span class=nx>sq</span> <span class=o>+</span> <span class=nx>pawnDir</span><span class=o>*</span><span class=mi>8</span> <span class=o>+</span> <span class=nx>offset</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>attackSq</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>attackSq</span> <span class=p>&lt;</span> <span class=mi>64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>attackSq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>Pawn</span> <span class=o>&amp;&amp;</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>attackSq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>byColor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check knight attacks
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>knightOffsets</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=o>-</span><span class=mi>17</span><span class=p>,</span> <span class=o>-</span><span class=mi>15</span><span class=p>,</span> <span class=o>-</span><span class=mi>10</span><span class=p>,</span> <span class=o>-</span><span class=mi>6</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span> <span class=mi>17</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>offset</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>knightOffsets</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>attackSq</span> <span class=o>:=</span> <span class=nx>sq</span> <span class=o>+</span> <span class=nx>offset</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>attackSq</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>attackSq</span> <span class=p>&lt;</span> <span class=mi>64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>attackSq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>Knight</span> <span class=o>&amp;&amp;</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>attackSq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>byColor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Check sliding piece attacks (Bishop, Rook, Queen)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>directions</span> <span class=o>:=</span> <span class=p>[][]</span><span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>},</span> <span class=p>{</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>},</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>  <span class=c1>// Bishop/Queen directions
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>},</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>    <span class=c1>// Rook/Queen directions
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>dir</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>directions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>dx</span><span class=p>,</span> <span class=nx>dy</span> <span class=o>:=</span> <span class=nx>dir</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>dir</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=o>:=</span> <span class=nx>sq</span><span class=o>%</span><span class=mi>8</span><span class=p>,</span> <span class=nx>sq</span><span class=o>/</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>newX</span><span class=p>,</span> <span class=nx>newY</span> <span class=o>:=</span> <span class=nx>x</span><span class=o>+</span><span class=nx>dx</span><span class=o>*</span><span class=nx>i</span><span class=p>,</span> <span class=nx>y</span><span class=o>+</span><span class=nx>dy</span><span class=o>*</span><span class=nx>i</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>newX</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>newX</span> <span class=o>&gt;=</span> <span class=mi>8</span> <span class=o>||</span> <span class=nx>newY</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>newY</span> <span class=o>&gt;=</span> <span class=mi>8</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=nx>attackSq</span> <span class=o>:=</span> <span class=nx>newY</span><span class=o>*</span><span class=mi>8</span> <span class=o>+</span> <span class=nx>newX</span>
</span></span><span class=line><span class=cl>            <span class=nx>piece</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>attackSq</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>piece</span> <span class=o>!=</span> <span class=nx>Empty</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>pos</span><span class=p>.</span><span class=nx>Colors</span><span class=p>[</span><span class=nx>attackSq</span><span class=p>]</span> <span class=o>==</span> <span class=nx>byColor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// Check if piece can move in this direction
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>if</span> <span class=nx>piece</span> <span class=o>==</span> <span class=nx>Queen</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                        <span class=p>(</span><span class=nx>piece</span> <span class=o>==</span> <span class=nx>Rook</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>dx</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>dy</span> <span class=o>==</span> <span class=mi>0</span><span class=p>))</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                        <span class=p>(</span><span class=nx>piece</span> <span class=o>==</span> <span class=nx>Bishop</span> <span class=o>&amp;&amp;</span> <span class=nx>dx</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>dy</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=part-5-advanced-search-techniques>Part 5: Advanced Search Techniques<a hidden class=anchor aria-hidden=true href=#part-5-advanced-search-techniques>#</a></h2><p>Let&rsquo;s implement some advanced search techniques to improve the engine&rsquo;s strength:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Null Move Pruning
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Engine</span><span class=p>)</span> <span class=nf>alphaBetaWithNullMove</span><span class=p>(</span><span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span><span class=p>,</span> <span class=nx>depth</span><span class=p>,</span> <span class=nx>alpha</span><span class=p>,</span> <span class=nx>beta</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>info</span> <span class=o>*</span><span class=nx>SearchInfo</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>depth</span> <span class=o>&gt;=</span> <span class=mi>3</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>pos</span><span class=p>.</span><span class=nf>InCheck</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=nx>pos</span><span class=p>.</span><span class=nf>HasNonPawnMaterial</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Make null move
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>newPos</span> <span class=o>:=</span> <span class=nx>pos</span><span class=p>.</span><span class=nf>MakeNullMove</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Reduced depth for null move search
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>R</span> <span class=o>:=</span> <span class=mi>2</span> <span class=o>+</span> <span class=nx>depth</span><span class=o>/</span><span class=mi>4</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Recursive search with reduced depth
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>score</span> <span class=o>:=</span> <span class=o>-</span><span class=nx>e</span><span class=p>.</span><span class=nf>alphaBeta</span><span class=p>(</span><span class=nx>newPos</span><span class=p>,</span> <span class=nx>depth</span><span class=o>-</span><span class=nx>R</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=nx>beta</span><span class=p>,</span> <span class=o>-</span><span class=nx>beta</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>score</span> <span class=o>&gt;=</span> <span class=nx>beta</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>beta</span> <span class=c1>// Null move cutoff
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Continue with regular alpha-beta search...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>e</span><span class=p>.</span><span class=nf>alphaBeta</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>depth</span><span class=p>,</span> <span class=nx>alpha</span><span class=p>,</span> <span class=nx>beta</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Late Move Reduction
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Engine</span><span class=p>)</span> <span class=nf>alphaBetaWithLMR</span><span class=p>(</span><span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span><span class=p>,</span> <span class=nx>depth</span><span class=p>,</span> <span class=nx>alpha</span><span class=p>,</span> <span class=nx>beta</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>moveCount</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>info</span> <span class=o>*</span><span class=nx>SearchInfo</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>depth</span> <span class=o>&gt;=</span> <span class=mi>3</span> <span class=o>&amp;&amp;</span> <span class=nx>moveCount</span> <span class=o>&gt;=</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>pos</span><span class=p>.</span><span class=nf>InCheck</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Reduce depth for late moves
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>reduction</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>moveCount</span> <span class=o>&gt;=</span> <span class=mi>6</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>reduction</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Reduced depth search
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>score</span> <span class=o>:=</span> <span class=o>-</span><span class=nx>e</span><span class=p>.</span><span class=nf>alphaBeta</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>depth</span><span class=o>-</span><span class=nx>reduction</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=nx>alpha</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=nx>alpha</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// If reduced search fails high, do a full depth search
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>score</span> <span class=p>&gt;</span> <span class=nx>alpha</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=nx>e</span><span class=p>.</span><span class=nf>alphaBeta</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>depth</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=nx>beta</span><span class=p>,</span> <span class=o>-</span><span class=nx>alpha</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>score</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Continue with regular search...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=o>-</span><span class=nx>e</span><span class=p>.</span><span class=nf>alphaBeta</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>depth</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=nx>beta</span><span class=p>,</span> <span class=o>-</span><span class=nx>alpha</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Aspiration Windows
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Engine</span><span class=p>)</span> <span class=nf>searchWithAspirationWindows</span><span class=p>(</span><span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span><span class=p>,</span> <span class=nx>depth</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>info</span> <span class=o>*</span><span class=nx>SearchInfo</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>score</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nx>alpha</span> <span class=o>:=</span> <span class=o>-</span><span class=nx>infinity</span>
</span></span><span class=line><span class=cl>    <span class=nx>beta</span> <span class=o>:=</span> <span class=nx>infinity</span>
</span></span><span class=line><span class=cl>    <span class=nx>window</span> <span class=o>:=</span> <span class=mi>50</span> <span class=c1>// Initial window size in centipawns
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// First search with full window
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>score</span> <span class=p>=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>alphaBeta</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>depth</span><span class=p>,</span> <span class=nx>alpha</span><span class=p>,</span> <span class=nx>beta</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Subsequent searches with aspiration windows
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>currentDepth</span> <span class=o>:=</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>currentDepth</span> <span class=o>&lt;=</span> <span class=nx>depth</span><span class=p>;</span> <span class=nx>currentDepth</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>alpha</span> <span class=p>=</span> <span class=nx>score</span> <span class=o>-</span> <span class=nx>window</span>
</span></span><span class=line><span class=cl>        <span class=nx>beta</span> <span class=p>=</span> <span class=nx>score</span> <span class=o>+</span> <span class=nx>window</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nx>score</span> <span class=p>=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>alphaBeta</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>currentDepth</span><span class=p>,</span> <span class=nx>alpha</span><span class=p>,</span> <span class=nx>beta</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>score</span> <span class=o>&lt;=</span> <span class=nx>alpha</span> <span class=o>||</span> <span class=nx>score</span> <span class=o>&gt;=</span> <span class=nx>beta</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Window failed, retry with larger window
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>window</span> <span class=o>*=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>            <span class=nx>score</span> <span class=p>=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>alphaBeta</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>currentDepth</span><span class=p>,</span> <span class=o>-</span><span class=nx>infinity</span><span class=p>,</span> <span class=nx>infinity</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nx>window</span> <span class=p>=</span> <span class=mi>50</span> <span class=c1>// Reset window size for next iteration
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>score</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=part-6-time-management>Part 6: Time Management<a hidden class=anchor aria-hidden=true href=#part-6-time-management>#</a></h2><p>Proper time management is crucial for tournament play:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TimeManager</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>InitialTime</span>  <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
</span></span><span class=line><span class=cl>    <span class=nx>Increment</span>    <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
</span></span><span class=line><span class=cl>    <span class=nx>MovesToGo</span>    <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>MaxMoveTime</span>  <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewTimeManager</span><span class=p>(</span><span class=nx>initialTime</span><span class=p>,</span> <span class=nx>increment</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>,</span> <span class=nx>movesToGo</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>TimeManager</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>TimeManager</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>InitialTime</span><span class=p>:</span> <span class=nx>initialTime</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Increment</span><span class=p>:</span>   <span class=nx>increment</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>MovesToGo</span><span class=p>:</span>   <span class=nx>movesToGo</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>MaxMoveTime</span><span class=p>:</span> <span class=nx>initialTime</span> <span class=o>/</span> <span class=mi>20</span><span class=p>,</span> <span class=c1>// Don&#39;t use more than 5% of total time
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>tm</span> <span class=o>*</span><span class=nx>TimeManager</span><span class=p>)</span> <span class=nf>allocateTime</span><span class=p>(</span><span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span><span class=p>)</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Basic time allocation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>baseTime</span> <span class=o>:=</span> <span class=nx>tm</span><span class=p>.</span><span class=nx>InitialTime</span> <span class=o>/</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>tm</span><span class=p>.</span><span class=nx>MovesToGo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Adjust based on game phase
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>gamePhase</span> <span class=o>:=</span> <span class=nf>evaluateGamePhase</span><span class=p>(</span><span class=nx>pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>gamePhase</span> <span class=p>&lt;</span> <span class=mf>0.3</span><span class=p>:</span> <span class=c1>// Opening
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>baseTime</span> <span class=o>*=</span> <span class=mi>8</span><span class=o>/</span><span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>gamePhase</span> <span class=p>&gt;</span> <span class=mf>0.7</span><span class=p>:</span> <span class=c1>// Endgame
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>baseTime</span> <span class=o>*=</span> <span class=mi>12</span><span class=o>/</span><span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Add increment
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>allocatedTime</span> <span class=o>:=</span> <span class=nx>baseTime</span> <span class=o>+</span> <span class=nx>tm</span><span class=p>.</span><span class=nx>Increment</span><span class=o>*</span><span class=mi>8</span><span class=o>/</span><span class=mi>10</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Never exceed maximum move time
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>allocatedTime</span> <span class=p>&gt;</span> <span class=nx>tm</span><span class=p>.</span><span class=nx>MaxMoveTime</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>allocatedTime</span> <span class=p>=</span> <span class=nx>tm</span><span class=p>.</span><span class=nx>MaxMoveTime</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>allocatedTime</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>evaluateGamePhase</span><span class=p>(</span><span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span><span class=p>)</span> <span class=kt>float64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Count material to determine game phase
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>totalMaterial</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nx>maxMaterial</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>sq</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>sq</span> <span class=p>&lt;</span> <span class=mi>64</span><span class=p>;</span> <span class=nx>sq</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>piece</span> <span class=o>:=</span> <span class=nx>pos</span><span class=p>.</span><span class=nx>Board</span><span class=p>[</span><span class=nx>sq</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>piece</span> <span class=o>!=</span> <span class=nx>Empty</span> <span class=o>&amp;&amp;</span> <span class=nx>piece</span> <span class=o>!=</span> <span class=nx>King</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>totalMaterial</span> <span class=o>+=</span> <span class=nx>pieceValues</span><span class=p>[</span><span class=nx>piece</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>maxMaterial</span> <span class=o>+=</span> <span class=nx>pieceValues</span><span class=p>[</span><span class=nx>piece</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Return value between 0 (opening) and 1 (endgame)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mf>1.0</span> <span class=o>-</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>totalMaterial</span><span class=p>)</span><span class=o>/</span><span class=nb>float64</span><span class=p>(</span><span class=nx>maxMaterial</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=part-7-opening-book-and-endgame-tablebases>Part 7: Opening Book and Endgame Tablebases<a hidden class=anchor aria-hidden=true href=#part-7-opening-book-and-endgame-tablebases>#</a></h2><p>For completeness, let&rsquo;s add support for opening books and endgame tablebases:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>OpeningBook</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>positions</span> <span class=kd>map</span><span class=p>[</span><span class=kt>uint64</span><span class=p>][]</span><span class=nx>BookMove</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>BookMove</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Move</span>   <span class=nx>Move</span>
</span></span><span class=line><span class=cl>    <span class=nx>Weight</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>book</span> <span class=o>*</span><span class=nx>OpeningBook</span><span class=p>)</span> <span class=nf>GetBookMove</span><span class=p>(</span><span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span><span class=p>)</span> <span class=p>(</span><span class=nx>Move</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>moves</span><span class=p>,</span> <span class=nx>exists</span> <span class=o>:=</span> <span class=nx>book</span><span class=p>.</span><span class=nx>positions</span><span class=p>[</span><span class=nx>pos</span><span class=p>.</span><span class=nf>Hash</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>exists</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>Move</span><span class=p>{},</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Select move based on weights
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>totalWeight</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>m</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>moves</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>totalWeight</span> <span class=o>+=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Weight</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Random selection weighted by frequency
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>r</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=nx>totalWeight</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>currentWeight</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>m</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>moves</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>currentWeight</span> <span class=o>+=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Weight</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>r</span> <span class=p>&lt;</span> <span class=nx>currentWeight</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Move</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>moves</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nx>Move</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Tablebase</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>cache</span> <span class=kd>map</span><span class=p>[</span><span class=kt>uint64</span><span class=p>]</span><span class=nx>TablebaseEntry</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TablebaseEntry</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Score</span>    <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>BestMove</span> <span class=nx>Move</span>
</span></span><span class=line><span class=cl>    <span class=nx>DTM</span>     <span class=kt>int</span> <span class=c1>// Distance to mate
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>tb</span> <span class=o>*</span><span class=nx>Tablebase</span><span class=p>)</span> <span class=nf>Probe</span><span class=p>(</span><span class=nx>pos</span> <span class=o>*</span><span class=nx>Position</span><span class=p>)</span> <span class=p>(</span><span class=nx>TablebaseEntry</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Probe tablebase cache
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>entry</span><span class=p>,</span> <span class=nx>exists</span> <span class=o>:=</span> <span class=nx>tb</span><span class=p>.</span><span class=nx>cache</span><span class=p>[</span><span class=nx>pos</span><span class=p>.</span><span class=nf>Hash</span><span class=p>()];</span> <span class=nx>exists</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>entry</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Only probe for positions with 6 or fewer pieces
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>pos</span><span class=p>.</span><span class=nf>PieceCount</span><span class=p>()</span> <span class=p>&gt;</span> <span class=mi>6</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>TablebaseEntry</span><span class=p>{},</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Here you would implement actual tablebase probing
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// This typically involves accessing Syzygy or Gaviota tablebases
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>TablebaseEntry</span><span class=p>{},</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Building a chess engine involves multiple complex components working together:</p><ol><li><strong>Board Representation</strong>: Efficient position storage and move generation</li><li><strong>Evaluation</strong>: Material, piece placement, pawn structure, king safety, and mobility</li><li><strong>Search</strong>: Alpha-beta pruning with enhancements (null move, LMR, aspiration windows)</li><li><strong>Time Management</strong>: Adaptive time allocation based on position and game phase</li><li><strong>Opening/Endgame</strong>: Book moves and tablebase access for perfect play</li></ol><p>Future improvements could include:</p><ul><li>Neural network evaluation</li><li>Multi-threaded search</li><li>Supervised learning from master games</li><li>NNUE (Efficiently Updatable Neural Network) evaluation</li><li>Advanced pruning techniques (Futility pruning, SEE, etc.)</li><li>Contempt factor for tournament play</li></ul><p>Remember that chess programming is an iterative process. Start with the basics and gradually add more sophisticated features while testing against other engines to measure improvement.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://www.chessprogramming.org>Chess Programming Wiki</a></li><li><a href=https://github.com/official-stockfish/Stockfish>Stockfish GitHub Repository</a></li><li>&ldquo;How Computers Play Chess&rdquo; by David Levy and Monty Newborn</li><li>&ldquo;Chess Programming&rdquo; by François-Dominic Laramée</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://manuelfedele.github.io/tags/golang/>Golang</a></li></ul><nav class=paginav><a class=next href=https://manuelfedele.github.io/posts/jwt-issuer-in-go/><span class=title>Next »</span><br><span>Implementing a JWT Issuer in Go</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Chess Engine - From Position Evaluation to Search Techniques on x" href="https://x.com/intent/tweet/?text=Building%20a%20Chess%20Engine%20-%20From%20Position%20Evaluation%20to%20Search%20Techniques&amp;url=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fevaluate-chess-position%2f&amp;hashtags=golang"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Chess Engine - From Position Evaluation to Search Techniques on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fevaluate-chess-position%2f&amp;title=Building%20a%20Chess%20Engine%20-%20From%20Position%20Evaluation%20to%20Search%20Techniques&amp;summary=Building%20a%20Chess%20Engine%20-%20From%20Position%20Evaluation%20to%20Search%20Techniques&amp;source=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fevaluate-chess-position%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Chess Engine - From Position Evaluation to Search Techniques on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fevaluate-chess-position%2f&title=Building%20a%20Chess%20Engine%20-%20From%20Position%20Evaluation%20to%20Search%20Techniques"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Chess Engine - From Position Evaluation to Search Techniques on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fevaluate-chess-position%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Chess Engine - From Position Evaluation to Search Techniques on whatsapp" href="https://api.whatsapp.com/send?text=Building%20a%20Chess%20Engine%20-%20From%20Position%20Evaluation%20to%20Search%20Techniques%20-%20https%3a%2f%2fmanuelfedele.github.io%2fposts%2fevaluate-chess-position%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Chess Engine - From Position Evaluation to Search Techniques on telegram" href="https://telegram.me/share/url?text=Building%20a%20Chess%20Engine%20-%20From%20Position%20Evaluation%20to%20Search%20Techniques&amp;url=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fevaluate-chess-position%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Building a Chess Engine - From Position Evaluation to Search Techniques on ycombinator" href="https://news.ycombinator.com/submitlink?t=Building%20a%20Chess%20Engine%20-%20From%20Position%20Evaluation%20to%20Search%20Techniques&u=https%3a%2f%2fmanuelfedele.github.io%2fposts%2fevaluate-chess-position%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//manuelfedele-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://manuelfedele.github.io/>Git Push and Run</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>