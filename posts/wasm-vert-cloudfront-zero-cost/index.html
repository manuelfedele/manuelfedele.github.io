<!doctype html><html lang=en><head><title>WASM in the Browser: Deploying VERT on CloudFront for Free :: Git Push and Run</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="What is WebAssembly? WebAssembly (WASM) is a binary instruction format that runs inside the browser at near-native speed. Think of it as a portable compilation target: you write code in Rust, C, C++, or Go, compile it to .wasm, and the browser executes it directly in a sandboxed VM alongside JavaScript.
The browser has always been able to run computation, but JavaScript is an interpreted, dynamically typed language. It is fast enough for most tasks, but there are workloads where it simply is not competitive: video encoding, image processing, cryptography, physics simulations. Before WASM, these had to live on a server. Now they can live in the browser tab.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://manuelfedele.github.io/posts/wasm-vert-cloudfront-zero-cost/><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><link rel=stylesheet href=https://manuelfedele.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://manuelfedele.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://manuelfedele.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://manuelfedele.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://manuelfedele.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://manuelfedele.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://manuelfedele.github.io/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css><link rel=stylesheet href=https://manuelfedele.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css><link rel=stylesheet href=https://manuelfedele.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://manuelfedele.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css><link rel=stylesheet href=https://manuelfedele.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://manuelfedele.github.io/style.css><link rel="shortcut icon" href=https://manuelfedele.github.io/favicon.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="WASM in the Browser: Deploying VERT on CloudFront for Free"><meta property="og:description" content="What is WebAssembly? WebAssembly (WASM) is a binary instruction format that runs inside the browser at near-native speed. Think of it as a portable compilation target: you write code in Rust, C, C++, or Go, compile it to .wasm, and the browser executes it directly in a sandboxed VM alongside JavaScript.
The browser has always been able to run computation, but JavaScript is an interpreted, dynamically typed language. It is fast enough for most tasks, but there are workloads where it simply is not competitive: video encoding, image processing, cryptography, physics simulations. Before WASM, these had to live on a server. Now they can live in the browser tab.
"><meta property="og:url" content="https://manuelfedele.github.io/posts/wasm-vert-cloudfront-zero-cost/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:image" content="https://manuelfedele.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2026-03-01 10:00:00 +0100 +0100"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>git push && run</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://manuelfedele.github.io/posts/wasm-vert-cloudfront-zero-cost/>WASM in the Browser: Deploying VERT on CloudFront for Free</a></h1><div class=post-meta><time class=post-date>2026-03-01</time><span class=post-reading-time>6 min read (1099 words)</span></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/wasm/>WASM</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/cloudfront/>CloudFront</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/s3/>S3</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/svelte/>Svelte</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/web/>web</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#what-is-webassembly>What is WebAssembly?</a><ul><li><a href=#how-it-works>How it works</a></li><li><a href=#the-practical-upside>The practical upside</a></li></ul></li><li><a href=#vert-250-format-conversions-fully-local>VERT: 250+ Format Conversions, Fully Local</a></li><li><a href=#hosting-it-on-cloudfront--s3-at-zero-cost>Hosting it on CloudFront + S3 at Zero Cost</a><ul><li><a href=#step-1-build-vert>Step 1: Build VERT</a></li><li><a href=#step-2-create-an-s3-bucket>Step 2: Create an S3 Bucket</a></li><li><a href=#step-3-upload-the-build>Step 3: Upload the Build</a></li><li><a href=#step-4-create-the-cloudfront-distribution>Step 4: Create the CloudFront Distribution</a></li><li><a href=#step-5-done>Step 5: Done</a></li></ul></li><li><a href=#why-this-pattern-works>Why This Pattern Works</a></li></ul></nav></div><div class=post-content><div><h2 id=what-is-webassembly>What is WebAssembly?<a href=#what-is-webassembly class=hanchor arialabel=Anchor>#</a></h2><p>WebAssembly (WASM) is a binary instruction format that runs inside the browser at near-native speed. Think of it as a portable compilation target: you write code in Rust, C, C++, or Go, compile it to <code>.wasm</code>, and the browser executes it directly in a sandboxed VM alongside JavaScript.</p><p>The browser has always been able to run <em>computation</em>, but JavaScript is an interpreted, dynamically typed language. It is fast enough for most tasks, but there are workloads where it simply is not competitive: video encoding, image processing, cryptography, physics simulations. Before WASM, these had to live on a server. Now they can live in the browser tab.</p><h3 id=how-it-works>How it works<a href=#how-it-works class=hanchor arialabel=Anchor>#</a></h3><p>WASM is not a language. It is a compilation target with four core types (<code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code>) and a stack-based virtual machine. When you load a <code>.wasm</code> module in the browser, the JS engine compiles it to native machine code via JIT, just like V8 does for hot JavaScript paths, but starting from a much lower-level representation that maps more directly to hardware.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Load and instantiate a WASM module from JavaScript
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=p>{</span> <span class=nx>instance</span> <span class=p>}</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>WebAssembly</span><span class=p>.</span><span class=nx>instantiateStreaming</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=nx>fetch</span><span class=p>(</span><span class=s1>&#39;/converter.wasm&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span> <span class=nx>env</span><span class=o>:</span> <span class=p>{</span> <span class=nx>memory</span><span class=o>:</span> <span class=k>new</span> <span class=nx>WebAssembly</span><span class=p>.</span><span class=nx>Memory</span><span class=p>({</span> <span class=nx>initial</span><span class=o>:</span> <span class=mi>256</span> <span class=p>})</span> <span class=p>}</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Call exported WASM functions directly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>instance</span><span class=p>.</span><span class=nx>exports</span><span class=p>.</span><span class=nx>convert_image</span><span class=p>(</span><span class=nx>inputPtr</span><span class=p>,</span> <span class=nx>inputLen</span><span class=p>,</span> <span class=nx>outputPtr</span><span class=p>);</span>
</span></span></code></pre></div><p>The memory model is explicit: WASM gets a linear memory buffer (a <code>WebAssembly.Memory</code>), and JS and WASM communicate by reading and writing into it. No garbage collection crossing boundaries, no serialization overhead. You pass a pointer, and the other side reads the bytes.</p><h3 id=the-practical-upside>The practical upside<a href=#the-practical-upside class=hanchor arialabel=Anchor>#</a></h3><p>The most important consequence is <strong>zero server round-trips for CPU-bound work</strong>. If you are converting an image, the file never leaves the browser. No upload latency, no server costs, no privacy concerns. The user&rsquo;s CPU does the work.</p><p>This changes the economics of entire categories of tools.</p><hr><h2 id=vert-250-format-conversions-fully-local>VERT: 250+ Format Conversions, Fully Local<a href=#vert-250-format-conversions-fully-local class=hanchor arialabel=Anchor>#</a></h2><p><a href=https://github.com/VERT-sh/VERT>VERT</a> is an open-source file converter built with SvelteKit and TypeScript. Under the hood it shells out to compiled WASM modules (FFmpeg, ImageMagick, and others) to convert images, audio, and documents entirely in the browser.</p><p>Key properties:</p><ul><li>No file size limits (the constraint is your RAM, not a server quota)</li><li>No uploads (files are read from disk into the browser&rsquo;s memory)</li><li>250+ supported formats</li><li>A companion daemon for video conversion (the one workload where in-browser FFmpeg is still too slow)</li></ul><p>The project publishes a pre-built static site that you can self-host. That is exactly what I did.</p><hr><h2 id=hosting-it-on-cloudfront--s3-at-zero-cost>Hosting it on CloudFront + S3 at Zero Cost<a href=#hosting-it-on-cloudfront--s3-at-zero-cost class=hanchor arialabel=Anchor>#</a></h2><p>VERT&rsquo;s build output is a standard static site: HTML, JS, CSS, and a pile of <code>.wasm</code> files. The WASM binaries are large (FFmpeg compiled to WASM weighs several megabytes), so the right hosting choice is a CDN that serves them from an edge cache close to the user.</p><p>CloudFront has a <strong>permanent free tier</strong>: 1 TB of data transfer per month, 10 million HTTP/S requests per month, and no expiry. For a personal self-hosted tool, this is more than enough. S3 storage for a few hundred megabytes of static assets costs cents per month, and within the first 12 months the 5 GB S3 free tier covers it entirely.</p><h3 id=step-1-build-vert>Step 1: Build VERT<a href=#step-1-build-vert class=hanchor arialabel=Anchor>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git clone https://github.com/VERT-sh/VERT.git
</span></span><span class=line><span class=cl><span class=nb>cd</span> VERT
</span></span><span class=line><span class=cl>npm install
</span></span><span class=line><span class=cl>npm run build
</span></span></code></pre></div><p>The output lands in <code>build/</code>. It is a fully self-contained static site.</p><h3 id=step-2-create-an-s3-bucket>Step 2: Create an S3 Bucket<a href=#step-2-create-an-s3-bucket class=hanchor arialabel=Anchor>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>aws s3 mb s3://my-vert-instance --region eu-central-1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Block all public access (CloudFront will be the only entry point)</span>
</span></span><span class=line><span class=cl>aws s3api put-public-access-block <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --bucket my-vert-instance <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --public-access-block-configuration <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=s2>&#34;BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true&#34;</span>
</span></span></code></pre></div><p>Do not enable static website hosting on the bucket. Serving via CloudFront with an Origin Access Control (OAC) is both more secure and cheaper.</p><h3 id=step-3-upload-the-build>Step 3: Upload the Build<a href=#step-3-upload-the-build class=hanchor arialabel=Anchor>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>aws s3 sync build/ s3://my-vert-instance/ <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --delete <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --cache-control <span class=s2>&#34;public, max-age=31536000, immutable&#34;</span>
</span></span></code></pre></div><p>The <code>immutable</code> directive tells CloudFront (and the browser) that hashed asset files like <code>_app/immutable/chunks/index.abc123.js</code> will never change for a given URL. This maximizes cache hit rate. For <code>index.html</code> and other entry points, override with a shorter TTL:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>aws s3 cp build/index.html s3://my-vert-instance/index.html <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --cache-control <span class=s2>&#34;public, max-age=0, must-revalidate&#34;</span>
</span></span></code></pre></div><h3 id=step-4-create-the-cloudfront-distribution>Step 4: Create the CloudFront Distribution<a href=#step-4-create-the-cloudfront-distribution class=hanchor arialabel=Anchor>#</a></h3><p>Create an OAC so CloudFront can read from S3 without making the bucket public:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>aws cloudfront create-origin-access-control <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --origin-access-control-config <span class=s1>&#39;{
</span></span></span><span class=line><span class=cl><span class=s1>    &#34;Name&#34;: &#34;vert-oac&#34;,
</span></span></span><span class=line><span class=cl><span class=s1>    &#34;OriginAccessControlOriginType&#34;: &#34;s3&#34;,
</span></span></span><span class=line><span class=cl><span class=s1>    &#34;SigningBehavior&#34;: &#34;always&#34;,
</span></span></span><span class=line><span class=cl><span class=s1>    &#34;SigningProtocol&#34;: &#34;sigv4&#34;
</span></span></span><span class=line><span class=cl><span class=s1>  }&#39;</span>
</span></span></code></pre></div><p>Note the <code>Id</code> from the response, then create the distribution:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;Origins&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Items&#34;</span><span class=p>:</span> <span class=p>[{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;Id&#34;</span><span class=p>:</span> <span class=s2>&#34;s3-vert&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;DomainName&#34;</span><span class=p>:</span> <span class=s2>&#34;my-vert-instance.s3.eu-central-1.amazonaws.com&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;S3OriginConfig&#34;</span><span class=p>:</span> <span class=p>{</span> <span class=nt>&#34;OriginAccessIdentity&#34;</span><span class=p>:</span> <span class=s2>&#34;&#34;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;OriginAccessControlId&#34;</span><span class=p>:</span> <span class=s2>&#34;&lt;OAC_ID&gt;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}]</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;DefaultCacheBehavior&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;ViewerProtocolPolicy&#34;</span><span class=p>:</span> <span class=s2>&#34;redirect-to-https&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;CachePolicyId&#34;</span><span class=p>:</span> <span class=s2>&#34;658327ea-f89d-4fab-a63d-7e88639e58f6&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Compress&#34;</span><span class=p>:</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;CustomErrorResponses&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Items&#34;</span><span class=p>:</span> <span class=p>[{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;ErrorCode&#34;</span><span class=p>:</span> <span class=mi>403</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;ResponsePagePath&#34;</span><span class=p>:</span> <span class=s2>&#34;/index.html&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;ResponseCode&#34;</span><span class=p>:</span> <span class=s2>&#34;200&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}]</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;DefaultRootObject&#34;</span><span class=p>:</span> <span class=s2>&#34;index.html&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>CustomErrorResponses</code> block is important. SvelteKit uses client-side routing, so any path that CloudFront does not find in S3 (e.g. <code>/about</code>) returns a 403. Mapping that to <code>index.html</code> with a 200 lets the SvelteKit router take over.</p><p>The <code>CachePolicyId</code> above is the AWS-managed <code>CachingOptimized</code> policy, which respects <code>Cache-Control</code> headers and compresses responses. WASM files compress well (often 3-4x), so Brotli or gzip compression at the edge meaningfully reduces transfer size.</p><p>Finally, update the S3 bucket policy to allow the CloudFront OAC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;Statement&#34;</span><span class=p>:</span> <span class=p>[{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Effect&#34;</span><span class=p>:</span> <span class=s2>&#34;Allow&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Principal&#34;</span><span class=p>:</span> <span class=p>{</span> <span class=nt>&#34;Service&#34;</span><span class=p>:</span> <span class=s2>&#34;cloudfront.amazonaws.com&#34;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Action&#34;</span><span class=p>:</span> <span class=s2>&#34;s3:GetObject&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Resource&#34;</span><span class=p>:</span> <span class=s2>&#34;arn:aws:s3:::my-vert-instance/*&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Condition&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;StringEquals&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;AWS:SourceArn&#34;</span><span class=p>:</span> <span class=s2>&#34;arn:aws:cloudfront::&lt;ACCOUNT_ID&gt;:distribution/&lt;DISTRIBUTION_ID&gt;&#34;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=step-5-done>Step 5: Done<a href=#step-5-done class=hanchor arialabel=Anchor>#</a></h3><p>Once the distribution is deployed (usually 5-10 minutes), VERT is reachable at the CloudFront domain (<code>*.cloudfront.net</code>), or at a custom domain if you wire up Route53 and an ACM certificate.</p><p>Total cost breakdown:</p><table><thead><tr><th>Resource</th><th>Free tier</th><th>Actual bill</th></tr></thead><tbody><tr><td>S3 storage (~300 MB)</td><td>5 GB/month free for 12 months</td><td>~$0.007/month after</td></tr><tr><td>CloudFront transfer</td><td>1 TB/month free (permanent)</td><td>$0</td></tr><tr><td>CloudFront requests</td><td>10M/month free (permanent)</td><td>$0</td></tr><tr><td>ACM certificate</td><td>Free</td><td>$0</td></tr></tbody></table><p>For personal use, it is effectively free indefinitely once the S3 free tier expires you are looking at less than a cent a month in storage.</p><hr><h2 id=why-this-pattern-works>Why This Pattern Works<a href=#why-this-pattern-works class=hanchor arialabel=Anchor>#</a></h2><p>The reason the cost is zero is the same reason WASM makes VERT possible in the first place: <strong>all computation is pushed to the client</strong>. The server (CloudFront + S3) only needs to serve static bytes once. After the first load, the browser caches the WASM modules aggressively. Subsequent visits are served from the local disk cache.</p><p>A traditional file converter would need a fleet of worker instances processing uploads 24/7. You would pay for compute, storage, egress, and the queue infrastructure tying it together. With WASM, your infrastructure cost collapses to &ldquo;store and deliver static files&rdquo;, which AWS essentially gives away at personal-use scale.</p><p>This is one of the more underappreciated things about WASM: it is not just a performance trick. It changes the infrastructure model entirely.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://manuelfedele.github.io/posts/leveraging-ai-as-a-platform-engineer/ class="button inline prev">&lt; [<span class=button__text>Leveraging AI as a Platform Engineer: What Actually Works</span>]
</a>::
<a href=https://manuelfedele.github.io/posts/building-ai-sre-assistant-from-scratch/ class="button inline next">[<span class=button__text>Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>