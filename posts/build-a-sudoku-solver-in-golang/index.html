<!doctype html><html lang=en><head><title>Build a Sudoku Solver in Golang :: Git Push and Run</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Sudoku Solver in Go: A Beginner&rsquo;s Guide and Optimization Techniques The game of Sudoku has always been a popular pastime for many. Whether you&rsquo;re an absolute novice or a seasoned veteran, the challenge of filling out a 9x9 grid with digits so that each column, each row, and each of the nine 3x3 subgrids contains all of the digits from 1 to 9, is an appealing task. Today, we&rsquo;re going to see how we can automate this process in Golang, and how we can optimize it using memoization techniques.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://manuelfedele.github.io/posts/build-a-sudoku-solver-in-golang/><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><link rel=stylesheet href=https://manuelfedele.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://manuelfedele.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://manuelfedele.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://manuelfedele.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://manuelfedele.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://manuelfedele.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://manuelfedele.github.io/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css><link rel=stylesheet href=https://manuelfedele.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css><link rel=stylesheet href=https://manuelfedele.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://manuelfedele.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css><link rel=stylesheet href=https://manuelfedele.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://manuelfedele.github.io/favicon.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Build a Sudoku Solver in Golang"><meta property="og:description" content="Sudoku Solver in Go: A Beginner&rsquo;s Guide and Optimization Techniques The game of Sudoku has always been a popular pastime for many. Whether you&rsquo;re an absolute novice or a seasoned veteran, the challenge of filling out a 9x9 grid with digits so that each column, each row, and each of the nine 3x3 subgrids contains all of the digits from 1 to 9, is an appealing task. Today, we&rsquo;re going to see how we can automate this process in Golang, and how we can optimize it using memoization techniques.
"><meta property="og:url" content="https://manuelfedele.github.io/posts/build-a-sudoku-solver-in-golang/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:image" content="https://manuelfedele.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2023-02-01 21:09:26 +0100 +0100"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>git push && run</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://manuelfedele.github.io/posts/build-a-sudoku-solver-in-golang/>Build a Sudoku Solver in Golang</a></h1><div class=post-meta><time class=post-date>2023-02-01</time><span class=post-reading-time>4 min read (830 words)</span></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/golang/>golang</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/algorithms/>algorithms</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#a-basic-sudoku-solver-in-golang>A Basic Sudoku Solver in Golang</a><ul><li><a href=#backtracking-algorithm>Backtracking Algorithm</a></li></ul></li><li><a href=#optimizing-sudoku-solver-with-memoization>Optimizing Sudoku Solver with Memoization</a></li></ul></nav></div><div class=post-content><div><h1 id=sudoku-solver-in-go-a-beginners-guide-and-optimization-techniques>Sudoku Solver in Go: A Beginner&rsquo;s Guide and Optimization Techniques<a href=#sudoku-solver-in-go-a-beginners-guide-and-optimization-techniques class=hanchor arialabel=Anchor>#</a></h1><p>The game of Sudoku has always been a popular pastime for many. Whether you&rsquo;re an absolute novice or a seasoned veteran, the challenge of filling out a 9x9 grid with digits so that each column, each row, and each of the nine 3x3 subgrids contains all of the digits from 1 to 9, is an appealing task. Today, we&rsquo;re going to see how we can automate this process in Golang, and how we can optimize it using memoization techniques.</p><h2 id=a-basic-sudoku-solver-in-golang>A Basic Sudoku Solver in Golang<a href=#a-basic-sudoku-solver-in-golang class=hanchor arialabel=Anchor>#</a></h2><p>Let&rsquo;s start with a basic approach. First, we need to represent our Sudoku grid in Go. A two-dimensional slice of integers fits the bill:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SudokuGrid</span> <span class=p>[</span><span class=mi>9</span><span class=p>][</span><span class=mi>9</span><span class=p>]</span><span class=kt>int</span>
</span></span></code></pre></div><h3 id=backtracking-algorithm>Backtracking Algorithm<a href=#backtracking-algorithm class=hanchor arialabel=Anchor>#</a></h3><p>The simplest approach to solving Sudoku programmatically is to use a backtracking algorithm. Backtracking is a trial and error based methodology used for problem solving. Let&rsquo;s implement a basic backtracking algorithm in Go:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>solveSudoku</span><span class=p>(</span><span class=nx>grid</span> <span class=o>*</span><span class=nx>SudokuGrid</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>9</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=mi>9</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>num</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>num</span> <span class=o>&lt;=</span> <span class=mi>9</span><span class=p>;</span> <span class=nx>num</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=nf>isValid</span><span class=p>(</span><span class=nx>grid</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>num</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>num</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nf>solveSudoku</span><span class=p>(</span><span class=nx>grid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=c1>// Undo current cell for backtracking</span>
</span></span><span class=line><span class=cl>              <span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>solveSudoku</code> function works by iterating through each cell in the grid, filling in empty cells (those that contain a zero), and checking if the number being inserted is valid for that cell. If the number is valid, the function recursively tries to solve the rest of the grid. If it can&rsquo;t, it backtracks by setting the cell back to zero and tries the next number.</p><p>The <code>isValid</code> function checks if a given number is valid for a particular cell:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>isValid</span><span class=p>(</span><span class=nx>grid</span> <span class=o>*</span><span class=nx>SudokuGrid</span><span class=p>,</span> <span class=nx>row</span><span class=p>,</span> <span class=nx>col</span><span class=p>,</span> <span class=nx>num</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Check the line</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>9</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>row</span><span class=p>][</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>num</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Check the column</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>9</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>col</span><span class=p>]</span> <span class=o>==</span> <span class=nx>num</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Check the box</span>
</span></span><span class=line><span class=cl>  <span class=nx>startRow</span><span class=p>,</span> <span class=nx>startCol</span> <span class=o>:=</span> <span class=nx>row</span><span class=o>-</span><span class=nx>row</span><span class=o>%</span><span class=mi>3</span><span class=p>,</span> <span class=nx>col</span><span class=o>-</span><span class=nx>col</span><span class=o>%</span><span class=mi>3</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=nx>startRow</span><span class=p>][</span><span class=nx>j</span><span class=o>+</span><span class=nx>startCol</span><span class=p>]</span> <span class=o>==</span> <span class=nx>num</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=optimizing-sudoku-solver-with-memoization>Optimizing Sudoku Solver with Memoization<a href=#optimizing-sudoku-solver-with-memoization class=hanchor arialabel=Anchor>#</a></h2><p>The standard backtracking approach works fine, but it can be slow, especially for larger or more complex Sudoku puzzles. One way to speed up the backtracking algorithm is by using memoization, a technique that stores the results of expensive function calls and reusing them when the same inputs occur again.</p><p>In our case, we can store the validity of each number for each cell in three maps, one for the rows, one for the columns, and one for the boxes.</p><p>Let&rsquo;s define our memoization maps:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SudokuGrid</span> <span class=p>[</span><span class=mi>9</span><span class=p>][</span><span class=mi>9</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MemoizationMap</span> <span class=p>[</span><span class=mi>9</span><span class=p>][</span><span class=mi>9</span><span class=p>][</span><span class=mi>10</span><span class=p>]</span><span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>rowsUsed</span><span class=p>,</span> <span class=nx>colsUsed</span><span class=p>,</span> <span class=nx>boxesUsed</span> <span class=nx>MemoizationMap</span>
</span></span></code></pre></div><p>We need to initialize our maps at the beginning of our program. We&rsquo;ll go through our Sudoku grid and for each cell that is not empty, we&rsquo;ll set the corresponding entry in our maps:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>initializeMemoizationMaps</span><span class=p>(</span><span class=nx>grid</span> <span class=o>*</span><span class=nx>SudokuGrid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>9</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=mi>9</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>num</span> <span class=o>:=</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>num</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>idx</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>i</span><span class=o>/</span><span class=mi>3</span><span class=p>)</span><span class=o>*</span><span class=mi>3</span> <span class=o>+</span> <span class=nx>j</span><span class=o>/</span><span class=mi>3</span>
</span></span><span class=line><span class=cl>        <span class=nx>rowsUsed</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=nx>colsUsed</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=nx>boxesUsed</span><span class=p>[</span><span class=nx>idx</span><span class=p>][</span><span class=nx>j</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now, we can modify our <code>solveSudoku</code> and <code>isValid</code> functions to make use of our memoization maps:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>solveSudoku</span><span class=p>(</span><span class=nx>grid</span> <span class=o>*</span><span class=nx>SudokuGrid</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>9</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=mi>9</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>num</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>num</span> <span class=o>&lt;=</span> <span class=mi>9</span><span class=p>;</span> <span class=nx>num</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=nf>isValid</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>num</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>placeNumber</span><span class=p>(</span><span class=nx>grid</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nf>solveSudoku</span><span class=p>(</span><span class=nx>grid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=nf>removeNumber</span><span class=p>(</span><span class=nx>grid</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>isValid</span><span class=p>(</span><span class=nx>row</span><span class=p>,</span> <span class=nx>col</span><span class=p>,</span> <span class=nx>num</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>idx</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>row</span> <span class=o>/</span> <span class=mi>3</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span> <span class=o>+</span> <span class=nx>col</span> <span class=o>/</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>!</span><span class=nx>rowsUsed</span><span class=p>[</span><span class=nx>row</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>colsUsed</span><span class=p>[</span><span class=nx>col</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>boxesUsed</span><span class=p>[</span><span class=nx>idx</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>placeNumber</span><span class=p>(</span><span class=nx>grid</span> <span class=o>*</span><span class=nx>SudokuGrid</span><span class=p>,</span> <span class=nx>row</span><span class=p>,</span> <span class=nx>col</span><span class=p>,</span> <span class=nx>num</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>idx</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>row</span> <span class=o>/</span> <span class=mi>3</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span> <span class=o>+</span> <span class=nx>col</span> <span class=o>/</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>grid</span><span class=p>[</span><span class=nx>row</span><span class=p>][</span><span class=nx>col</span><span class=p>]</span> <span class=p>=</span> <span class=nx>num</span>
</span></span><span class=line><span class=cl>  <span class=nx>rowsUsed</span><span class=p>[</span><span class=nx>row</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  <span class=nx>colsUsed</span><span class=p>[</span><span class=nx>col</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  <span class=nx>boxesUsed</span><span class=p>[</span><span class=nx>idx</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>removeNumber</span><span class=p>(</span><span class=nx>grid</span> <span class=o>*</span><span class=nx>SudokuGrid</span><span class=p>,</span> <span class=nx>row</span><span class=p>,</span> <span class=nx>col</span><span class=p>,</span> <span class=nx>num</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>idx</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>row</span> <span class=o>/</span> <span class=mi>3</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span> <span class=o>+</span> <span class=nx>col</span> <span class=o>/</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>grid</span><span class=p>[</span><span class=nx>row</span><span class=p>][</span><span class=nx>col</span><span class=p>]</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=nx>rowsUsed</span><span class=p>[</span><span class=nx>row</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>  <span class=nx>colsUsed</span><span class=p>[</span><span class=nx>col</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>  <span class=nx>boxesUsed</span><span class=p>[</span><span class=nx>idx</span><span class=p>][</span><span class=nx>num</span><span class=p>]</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>With this new approach, instead of repeatedly checking the validity of a number in a certain cell, we are directly accessing the stored value in constant time, leading to a substantial speed up in our program.</p><p>While both these approaches solve the Sudoku puzzle, using memoization significantly speeds up the process. Remember that while memoization uses more memory, it can drastically cut down the time complexity of our algorithm.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://manuelfedele.github.io/posts/nats-messaging-with-golang/ class="button inline prev">&lt; [<span class=button__text>Nats Messaging With Golang</span>]
</a>::
<a href=https://manuelfedele.github.io/posts/socket-messaging-with-golang/ class="button inline next">[<span class=button__text>Socket Messaging With Golang</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>