<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.147.6"><title>Git Push and Run</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://manuelfedele.github.io/><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><link rel=stylesheet href=https://manuelfedele.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://manuelfedele.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://manuelfedele.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://manuelfedele.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://manuelfedele.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://manuelfedele.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://manuelfedele.github.io/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css><link rel=stylesheet href=https://manuelfedele.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css><link rel=stylesheet href=https://manuelfedele.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://manuelfedele.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css><link rel=stylesheet href=https://manuelfedele.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://manuelfedele.github.io/favicon.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Git Push and Run"><meta property="og:description" content><meta property="og:url" content="https://manuelfedele.github.io/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:image" content="https://manuelfedele.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/index.xml rel=alternate type=application/rss+xml title="Git Push and Run"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>git push && run</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h2 class=post-title><a href=https://manuelfedele.github.io/posts/building-ai-sre-assistant-from-scratch/>Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator</a></h2><div class=post-meta><time class=post-date>2026-02-22</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/ai/>AI</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/django/>django</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/react/>react</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/gitlab/>GitLab</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/llm/>LLM</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/devops/>DevOps</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/sre/>SRE</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/architecture/>architecture</a>&nbsp;</span><div class=post-content><h1 id=building-an-ai-sre-assistant-from-scratch-architecture-of-an-autonomous-infrastructure-investigator>Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator</h1><p>What if your on-call engineer never slept, had instant access to every repository and every AWS account, and could trace a production issue from DNS to database in under a minute?</p><p>That&rsquo;s the question that led me to build TARS, an AI-powered SRE assistant that autonomously investigates infrastructure issues by combining LLM reasoning with deep integrations into GitLab and AWS. Named after the robot from Interstellar (because every good internal tool needs a movie reference), TARS is a full-stack application where engineers interact with an AI agent through a chat interface. The agent doesn&rsquo;t just answer questions. It investigates. It clones repos, greps code, reads CloudWatch logs, traces DNS chains, inspects ECS services, and synthesizes findings into structured reports.</p></div><div><a class="read-more button inline" href=/posts/building-ai-sre-assistant-from-scratch/>[]</a></div></article><article class="post on-list"><h2 class=post-title><a href=https://manuelfedele.github.io/posts/building-ai-powered-platform-operations-agent/>Building an AI-Powered Platform Operations Agent</a></h2><div class=post-meta><time class=post-date>2026-02-15</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/ai/>AI</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/devops/>DevOps</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/automation/>automation</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/llm/>LLM</a>&nbsp;</span><div class=post-content><h1 id=building-an-ai-powered-platform-operations-agent>Building an AI-Powered Platform Operations Agent</h1><p>Platform engineering teams handle a constant stream of repetitive requests: onboarding users, managing API keys, checking service health, rotating credentials. Most of these tasks follow well-defined procedures that a human executes step by step. What if an AI agent could handle them instead?</p><p>In this post, I&rsquo;ll walk through the architecture of an AI-powered operations agent that automates common platform tasks by giving an LLM access to your internal tools through a structured tool-calling interface.</p></div><div><a class="read-more button inline" href=/posts/building-ai-powered-platform-operations-agent/>[]</a></div></article><article class="post on-list"><h2 class=post-title><a href=https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/>ECS Fargate Production Patterns That Actually Work</a></h2><div class=post-meta><time class=post-date>2026-01-08</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/ecs/>ECS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/fargate/>Fargate</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/terraform/>Terraform</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/docker/>Docker</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/cloud/>cloud</a>&nbsp;</span><div class=post-content><h1 id=ecs-fargate-production-patterns-that-actually-work>ECS Fargate Production Patterns That Actually Work</h1><p>I&rsquo;ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.</p><h2 id=the-standard-architecture>The Standard Architecture</h2><p>Every service I deploy follows the same high-level architecture:</p><pre tabindex=0><code>Internet/VPC -&gt; ALB (HTTPS, TLS 1.3) -&gt; ECS Fargate -&gt; Aurora PostgreSQL Serverless v2
                 |
                WAF (rate limiting + AWS managed rules)
</code></pre><p>Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS.</p></div><div><a class="read-more button inline" href=/posts/ecs-fargate-production-patterns/>[]</a></div></article><article class="post on-list"><h2 class=post-title><a href=https://manuelfedele.github.io/posts/building-ai-document-processing-pipeline-aws/>Building an AI-Powered Document Processing Pipeline on AWS</a></h2><div class=post-meta><time class=post-date>2025-12-03</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/ai/>AI</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/llm/>LLM</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/step-functions/>Step Functions</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/lambda/>Lambda</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/serverless/>serverless</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/architecture/>architecture</a>&nbsp;</span><div class=post-content><h1 id=building-an-ai-powered-document-processing-pipeline-on-aws>Building an AI-Powered Document Processing Pipeline on AWS</h1><p>Insurance companies process millions of documents every year: police reports, medical records, invoices, repair estimates. Traditionally, human operators read each document, classify it, extract the relevant fields, and enter the data into the claims system. This is slow, expensive, and error-prone.</p><p>In this post I&rsquo;ll describe the architecture of a production document processing pipeline I helped build. The system ingests claim documents, extracts text using vision-based LLMs, clusters and classifies document sections, extracts structured data, and generates vector embeddings for semantic search. All of this runs on a fully serverless AWS architecture with no idle infrastructure costs.</p></div><div><a class="read-more button inline" href=/posts/building-ai-document-processing-pipeline-aws/>[]</a></div></article><article class="post on-list"><h2 class=post-title><a href=https://manuelfedele.github.io/posts/building-interactive-cli-tools-in-go-with-bubbletea/>Building Interactive CLI Tools in Go with Bubbletea</a></h2><div class=post-meta><time class=post-date>2025-11-14</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/golang/>golang</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/cli/>cli</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/bubbletea/>bubbletea</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/devops/>devops</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/tui/>tui</a>&nbsp;</span><div class=post-content><h1 id=building-interactive-cli-tools-in-go-with-bubbletea>Building Interactive CLI Tools in Go with Bubbletea</h1><p>If you&rsquo;ve ever wanted to build a terminal application that feels more like a proper UI than a wall of text, the <a href=https://github.com/charmbracelet>charmbracelet</a> ecosystem is the way to go. I&rsquo;ve been using it to build internal DevOps tools, and the developer experience is excellent. In this post, I&rsquo;ll walk through building an interactive CLI tool using <a href=https://github.com/charmbracelet/bubbletea>Bubbletea</a> and <a href=https://github.com/charmbracelet/huh>Huh</a>, the same libraries behind tools like <code>gum</code> and <code>soft-serve</code>.</p></div><div><a class="read-more button inline" href=/posts/building-interactive-cli-tools-in-go-with-bubbletea/>[]</a></div></article><article class="post on-list"><h2 class=post-title><a href=https://manuelfedele.github.io/posts/multi-account-aws-terraform-workspaces/>Managing Multi-Account AWS Infrastructure with Terraform Workspaces</a></h2><div class=post-meta><time class=post-date>2025-09-22</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/terraform/>Terraform</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/iac/>IaC</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/devops/>DevOps</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/cloud/>cloud</a>&nbsp;</span><div class=post-content><h1 id=managing-multi-account-aws-infrastructure-with-terraform-workspaces>Managing Multi-Account AWS Infrastructure with Terraform Workspaces</h1><p>When you&rsquo;re managing infrastructure across dozens of AWS accounts, you need patterns that scale. In this post I&rsquo;ll share the approach I use to manage multi-account, multi-environment AWS infrastructure using Terraform workspaces, modular code, and a consistent tagging strategy.</p><h2 id=the-problem>The Problem</h2><p>Imagine this setup: you have multiple organizational scopes (teams, business units, projects), each with their own AWS accounts for non-production and production. On top of that, your non-production account hosts multiple environments (dev, integration, certification). Multiply this by several countries or regions, and you&rsquo;re looking at a lot of infrastructure to manage.</p></div><div><a class="read-more button inline" href=/posts/multi-account-aws-terraform-workspaces/>[]</a></div></article><article class="post on-list"><h2 class=post-title><a href=https://manuelfedele.github.io/posts/evaluate-chess-position/>Building a Chess Engine - From Position Evaluation to Search Techniques</a></h2><div class=post-meta><time class=post-date>2024-11-27</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/golang/>golang</a>&nbsp;</span><div class=post-content><h1 id=building-a-chess-engine-from-position-evaluation-to-search-techniques>Building a Chess Engine: From Position Evaluation to Search Techniques</h1><p>Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position evaluation and search strategies.</p><h2 id=part-1-basic-position-representation>Part 1: Basic Position Representation</h2><p>First, let&rsquo;s implement a basic board representation. While FEN (Forsyth–Edwards Notation) is the standard for chess positions, we&rsquo;ll use a more computation-friendly format internally.</p></div><div><a class="read-more button inline" href=/posts/evaluate-chess-position/>[]</a></div></article><article class="post on-list"><h2 class=post-title><a href=https://manuelfedele.github.io/posts/jwt-issuer-in-go/>Implementing a JWT Issuer in Go</a></h2><div class=post-meta><time class=post-date>2024-11-27</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/golang/>golang</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/security/>security</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/jwt/>jwt</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/authentication/>authentication</a>&nbsp;</span><div class=post-content><h1 id=building-a-secure-jwt-issuer-in-go-a-complete-guide>Building a Secure JWT Issuer in Go: A Complete Guide</h1><p>JSON Web Tokens (JWT) have become the de facto standard for implementing stateless authentication in modern web applications. In this guide, we&rsquo;ll implement a secure JWT issuer in Go, covering both basic implementation and advanced security considerations.</p><h2 id=understanding-jwt-basics>Understanding JWT Basics</h2><p>A JWT consists of three parts: header, payload, and signature. These parts are Base64URL encoded and concatenated with dots. The signature ensures the token hasn&rsquo;t been tampered with, while the payload carries the claims (data) we want to transmit securely.</p></div><div><a class="read-more button inline" href=/posts/jwt-issuer-in-go/>[]</a></div></article><article class="post on-list"><h2 class=post-title><a href=https://manuelfedele.github.io/posts/implementing-djikstra-algorithm-in-go/>Implementing Dijkstra’s Algorithm in Go</a></h2><div class=post-meta><time class=post-date>2024-11-27</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/golang/>“golang”</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/algorithms/>“algorithms”</a>&nbsp;</span><div class=post-content><h1 id=a-beginners-guide-and-optimization-techniques>A Beginner’s Guide and Optimization Techniques</h1><p>Graphs are fundamental data structures in computer science, representing relationships between entities. One of the most common problems involving graphs is finding the shortest path between nodes. Dijkstra’s algorithm is a classic solution to this problem for graphs with non-negative edge weights. In this guide, we’ll implement Dijkstra’s algorithm in Go and explore ways to optimize it using advanced data structures.\</p><h2 id=basic-implementation-of-dijkstras-algorithm>Basic Implementation of Dijkstra’s Algorithm</h2><p>Let’s begin by understanding the core concept. Dijkstra’s algorithm maintains a set of nodes whose shortest distance from the source is known and repeatedly selects the node with the minimum distance to explore its neighbors.</p></div><div><a class="read-more button inline" href=/posts/implementing-djikstra-algorithm-in-go/>[]</a></div></article><article class="post on-list"><h2 class=post-title><a href=https://manuelfedele.github.io/posts/clipboard-watch-remove-accidentally-typed-passwords/>Clipboard Watch Remove Accidentally Typed Passwords</a></h2><div class=post-meta><time class=post-date>2023-11-26</time></div><div class=post-content><h1 id=monitoring-clipboard-in-golang-a-guide-to-obscuring-passwords>Monitoring Clipboard in Golang: A Guide to Obscuring Passwords</h1><h2 id=introduction>Introduction</h2><p>In this article, we explore creating a Go program that monitors the system clipboard, automatically substituting passwords with asterisks. Uniquely, the program leaves the last few characters (minimum 1, maximum 3) of the password visible when the password length exceeds 8 characters.</p><h2 id=understanding-clipboard-monitoring-in-go>Understanding Clipboard Monitoring in Go</h2><h3 id=the-clipboard-package>The Clipboard Package</h3><p>Go lacks a built-in library for clipboard operations. We use <code>atotto/clipboard</code>, a third-party package offering simple clipboard interfaces.</p></div><div><a class="read-more button inline" href=/posts/clipboard-watch-remove-accidentally-typed-passwords/>[]</a></div></article><div class=pagination><div class=pagination__buttons><a href=/page/2/ class="button inline next">[<span class=button__text>Older posts</span>] ></a></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>