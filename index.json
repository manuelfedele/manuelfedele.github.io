[{"content":"Tracking pixels, also known as web beacons, are small transparent images that are used to track the effectiveness of emails. They work by including a unique image in the email that is hosted on a server, and when the email is opened and the image is loaded, it sends a request to the server with information about the email opening. This information can be used to track the effectiveness of the email and see how many people have opened it.\nTo use tracking pixels with Golang, we can follow these steps:\nCreate a unique image to use as the tracking pixel. This image should be hosted on a server that you control.\nInclude the tracking pixel in the email. This can be done by using an tag in the HTML of the email and setting the src attribute to the URL of the tracking pixel image.\nSet up a server to handle the tracking pixel requests. When the email is opened and the image is loaded, it will send a request to the server with information about the email opening. The server can then log this information for later analysis.\nHere is an example of how the tracking pixel could be implemented in Golang:\nimport ( \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) func main() { // Set up a handler for the tracking pixel http.HandleFunc(\u0026#34;/pixel.png\u0026#34;, func(w http.ResponseWriter, r *http.Request) { // Log the request information log.Printf(\u0026#34;Tracking pixel request from %s\u0026#34;, r.RemoteAddr) // Set the content type to image/png w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;image/png\u0026#34;) // Set the cache control headers to prevent caching w.Header().Set(\u0026#34;Cache-Control\u0026#34;, \u0026#34;no-cache, no-store, must-revalidate\u0026#34;) w.Header().Set(\u0026#34;Expires\u0026#34;, time.Now().UTC().Format(http.TimeFormat)) // Serve the transparent 1x1 PNG image http.ServeFile(w, r, \u0026#34;pixel.png\u0026#34;) } // Start the server log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } This example sets up a handler for the tracking pixel that logs the request information and serves a transparent 1x1 PNG image. It also sets the content type and cache control headers to ensure that the image is displayed correctly and not cached by the browser.\nWith this approach, we can use tracking pixels to track the effectiveness of emails in Golang.\n","permalink":"https://manuelfedele.github.io/posts/tracking-pixel-technology-email-golang/","summary":"Tracking pixels, also known as web beacons, are small transparent images that are used to track the effectiveness of emails. They work by including a unique image in the email that is hosted on a server, and when the email is opened and the image is loaded, it sends a request to the server with information about the email opening. This information can be used to track the effectiveness of the email and see how many people have opened it.","title":"Tracking Pixel Technology with Golang"},{"content":"Evaluating chess positions is an important part of chess strategy and can help players make more informed decisions about which moves to make. In this blog post, we\u0026rsquo;ll look at how to use the powerful Stockfish chess engine and the Go programming language to evaluate chess positions.\nInstalling Stockfish Before we can start using Stockfish, we need to install it. On Linux and macOS, you can install Stockfish using the package manager of your choice (e.g., apt-get, Homebrew, etc.). On Windows, you can download a pre-compiled executable from the Stockfish website (https://stockfishchess.org/download/).\nUsing Stockfish with Go To use Stockfish with Go, we\u0026rsquo;ll need to use a library that provides a Go interface to the engine. There are several options available, but we\u0026rsquo;ll be using the \u0026ldquo;github.com/notnil/chess\u0026rdquo; library in this example.\nTo install the library, run the following command:\ngo get github.com/notnil/chess Now we\u0026rsquo;re ready to start using Stockfish in our Go programs.\nEvaluating chess positions is an important part of chess strategy and can help players make more informed decisions about which moves to make. In this blog post, we\u0026rsquo;ll look at how to use the powerful Stockfish chess engine and the Go programming language to evaluate chess positions.\nInstalling Stockfish Before we can start using Stockfish, we need to install it. On Linux and macOS, you can install Stockfish using the package manager of your choice (e.g., apt-get, Homebrew, etc.). On Windows, you can download a pre-compiled executable from the Stockfish website (https://stockfishchess.org/download/).\nUsing Stockfish with Go To use Stockfish with Go, we\u0026rsquo;ll need to use a library that provides a Go interface to the engine. There are several options available, but we\u0026rsquo;ll be using the \u0026ldquo;github.com/notnil/chess\u0026rdquo; library in this example.\nTo install the library, run the following command:\ngo get github.com/notnil/chess Now we\u0026rsquo;re ready to start using Stockfish in our Go programs.\nEvaluating a Chess Position To get Stockfish\u0026rsquo;s evaluation of a chess position, we first need to create a new Stockfish instance:\nstockfish, err := chess.NewEngine(\u0026#34;stockfish\u0026#34;) if err != nil { panic(err) } Next, we can set the difficulty level, which controls how deep Stockfish will search for the best move. A higher difficulty level will result in more accurate evaluations, but will also take longer to compute.\nstockfish.SetDifficulty(20) Now we can set the position that we want to evaluate using standard chess notation (e.g., \u0026ldquo;rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\u0026rdquo; for the starting position).\nstockfish.SetPosition(\u0026#34;rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\u0026#34;) Finally, we can call the Evaluate() method to get Stockfish\u0026rsquo;s evaluation of the position:\nevaluation, err := stockfish.Evaluate() if err != nil { panic(err) } fmt.Println(evaluation) // Outputs: \u0026#34;0.00\u0026#34; The evaluation is returned as a string in centipawns, where a positive value indicates that White has an advantage and a negative value indicates that Black has an advantage. A value of \u0026ldquo;0.00\u0026rdquo; indicates a balanced position.\nComplete code import \u0026#34;github.com/notnil/chess\u0026#34; func main() { // Create a new Stockfish instance stockfish, err := chess.NewEngine(\u0026#34;stockfish\u0026#34;) if err != nil { panic(err) } // Set the difficulty level (this controls how deep Stockfish will search) stockfish.SetDifficulty(20) // Set the position to be evaluated stockfish.SetPosition(\u0026#34;rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\u0026#34;) // Get Stockfish\u0026#39;s evaluation of the position evaluation, err := stockfish.Evaluate() if err != nil { panic(err) } fmt.Println(evaluation) // Outputs: \u0026#34;0.00\u0026#34; } This is just a basic example, and there are many other things you can do with the library (e.g., make moves, get a list of legal moves, etc.). You can find more information about the library and its features in the documentation at https://godoc.org/github.com/notnil/chess.\nConclusion In this blog post, we\u0026rsquo;ve seen how to use the Stockfish chess engine and the Go programming language to evaluate chess positions. This can be a useful tool for chess players looking to improve their game, as well as for developers looking to build chess-related applications. With a little bit of Go code, it\u0026rsquo;s easy to get powerful evaluations of any chess position from Stockfish.\n","permalink":"https://manuelfedele.github.io/posts/evaluate-chess-position-with-golang/","summary":"Evaluating chess positions is an important part of chess strategy and can help players make more informed decisions about which moves to make. In this blog post, we\u0026rsquo;ll look at how to use the powerful Stockfish chess engine and the Go programming language to evaluate chess positions.\nInstalling Stockfish Before we can start using Stockfish, we need to install it. On Linux and macOS, you can install Stockfish using the package manager of your choice (e.","title":"Evaluate Chess Position With Golang"},{"content":"Memoization is a technique that is used to speed up the execution of a function by storing the results of expensive function calls and returning the cached result when the same input occurs again. This can be particularly useful for algorithms that have a large number of recursive calls or for functions that are called multiple times with the same input.\nIn Go, it is easy to implement memoization using a simple map. For example, consider the following function that calculates the nth number in the Fibonacci sequence:\nfunc fib(n int) int { if n == 0 || n == 1 { return n } return fib(n-1) + fib(n-2) } This function has a time complexity of O(2^n), which can be very slow for large values of n. We can use memoization to speed up the function by storing the results of each recursive call in a map:\nvar cache = make(map[int]int) func fib(n int) int { if n == 0 || n == 1 { return n } if v, ok := cache[n]; ok { return v } result := fib(n-1) + fib(n-2) cache[n] = result return result } Now, the time complexity of the function is O(n), which is much faster for large values of n.\nOne thing to note is that the map used for memoization should be declared as a global variable, since it needs to be accessible from all recursive calls. It is also a good idea to clear the map after each function call, to avoid using up too much memory.\nOverall, memoization is a simple but powerful technique for optimizing the performance of recursive functions in Go. It is especially useful for functions that are called multiple times with the same input, and can significantly improve the speed of your program.\n","permalink":"https://manuelfedele.github.io/posts/the-memoization-technique/","summary":"Memoization is a technique that is used to speed up the execution of a function by storing the results of expensive function calls and returning the cached result when the same input occurs again. This can be particularly useful for algorithms that have a large number of recursive calls or for functions that are called multiple times with the same input.\nIn Go, it is easy to implement memoization using a simple map.","title":"The Memoization Technique"},{"content":"Alpaca is a popular platform for automated trading, offering APIs for accessing real-time market data and placing trades. In this article, we will discuss how to use Alpaca\u0026rsquo;s APIs with Golang, a popular programming language known for its simplicity, performance, and concurrency support.\nBefore we dive into the details of using Alpaca\u0026rsquo;s APIs with Golang, let\u0026rsquo;s first understand the requirements of the application.\nRequirements The application should be able to connect to the Alpaca API and authenticate the user. The application should be able to retrieve real-time market data and place trades. The application should be able to retrieve the user\u0026rsquo;s account information and trade history.\nSetting up the Alpaca API To use the Alpaca API, you will need to sign up for an Alpaca account and obtain an API key. The API key is used to authenticate your requests to the API.\nOnce you have an API key, you can use the following Go libraries to access the Alpaca API:\nalpaca-trade-api-go: A Go client library for the Alpaca Trade API. alpaca-go: A Go wrapper for the Alpaca Trade API. Both libraries provide functions for accessing various types of data and placing trades, including real-time quotes, historical data, and account information.\nFor example, the following code snippet demonstrates how to place a market order using the alpaca-trade-api-go library:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; alpaca \u0026#34;github.com/alpacahq/alpaca-trade-api-go\u0026#34; ) func main() { // Set the API key and secret alpaca.SetAPIKey(\u0026#34;YOUR_API_KEY\u0026#34;) alpaca.SetAPISecret(\u0026#34;YOUR_API_SECRET\u0026#34;) // Place a market order to buy 100 shares of the stock \u0026#34;AAPL\u0026#34; order, err := alpaca.PlaceOrder(\u0026#34;AAPL\u0026#34;, 100, alpaca.MarketOrder, alpaca.Buy, \u0026#34;day\u0026#34;) if err != nil { log.Fatal(err) } // Print the order details fmt.Printf(\u0026#34;%+v\\n\u0026#34;, order) } This will place a market order to buy 100 shares of the stock \u0026ldquo;AAPL\u0026rdquo; and print the order details, including the order ID and status.\nRetrieving Market Data In addition to placing trades, you can also use the Alpaca API to retrieve real-time market data. The following code snippet demonstrates how to retrieve the real-time quote for the stock \u0026ldquo;AAPL\u0026rdquo; using the alpaca-trade-api-go library:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; alpaca \u0026#34;github.com/alpacahq/alpaca-trade-api-go\u0026#34; ) func main() { // Set the API key and secret alpaca.SetAPIKey(\u0026#34;YOUR_API_KEY\u0026#34;) alpaca.SetAPISecret(\u0026#34;YOUR_API_SECRET\u0026#34;) // Retrieve the real-time quote for the stock \u0026#34;AAPL\u0026#34; quote, err := alpaca.GetQuote(\u0026#34;AAPL\u0026#34;) if err != nil { log.Fatal(err) } // Print the quote fmt.Printf(\u0026#34;%+v\\n\u0026#34;, quote) } This will retrieve the real-time quote for the stock \u0026ldquo;AAPL\u0026rdquo; and print the quote, including the current price, volume, and other information.\nRetrieving Account Information and Trade History In addition to retrieving market data, you can also use the Alpaca API to retrieve information about your account and trade history. The following code snippet demonstrates how to retrieve your account balance and trade history using the alpaca-trade-api-go library:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; alpaca \u0026#34;github.com/alpacahq/alpaca-trade-api-go\u0026#34; ) func main() { // Set the API key and secret alpaca.SetAPIKey(\u0026#34;YOUR_API_KEY\u0026#34;) alpaca.SetAPISecret(\u0026#34;YOUR_API_SECRET\u0026#34;) // Retrieve the account balance balance, err := alpaca.GetAccount() if err != nil { log.Fatal(err) } // Print the account balance fmt.Printf(\u0026#34;Account balance: %+v\\n\u0026#34;, balance) // Retrieve the trade history trades, err := alpaca.ListTrades() if err != nil { log.Fatal(err) } // Print the trade history fmt.Printf(\u0026#34;Trade history: %+v\\n\u0026#34;, trades) } This will retrieve your account balance and trade history and print the information.\nConclusion In this tutorial, we have discussed how to use Alpaca\u0026rsquo;s APIs with Golang to automate trading. We have seen how to connect to the Alpaca API, place trades, retrieve market data, and retrieve account information and trade history. With these tools and techniques, you can create a powerful and efficient application for automated trading.\n","permalink":"https://manuelfedele.github.io/posts/trading-with-alpaca-and-golang/","summary":"Alpaca is a popular platform for automated trading, offering APIs for accessing real-time market data and placing trades. In this article, we will discuss how to use Alpaca\u0026rsquo;s APIs with Golang, a popular programming language known for its simplicity, performance, and concurrency support.\nBefore we dive into the details of using Alpaca\u0026rsquo;s APIs with Golang, let\u0026rsquo;s first understand the requirements of the application.\nRequirements The application should be able to connect to the Alpaca API and authenticate the user.","title":"Trading With Alpaca and Golang"},{"content":"Introduction Elastic, also known as Elasticsearch, is a powerful search and analytics engine that can be used to index, search, and analyze large volumes of data quickly and in near real-time. It is open-source and built on top of the Lucene library. In this blog post, we will go over the basics of Elastic and how to get started using it.\nInstallation The first step to using Elastic is to install it on your system. You can download the latest version of Elastic from the official website (https://www.elastic.co/downloads/elasticsearch) and install it according to the instructions provided. Once installed, you can start the Elastic service on your machine and access it through a web interface at http://localhost:9200.\nIndexing Data In Elastic, data is stored in indices, which are similar to tables in a relational database. To index data, you need to create an index and then add documents to it. You can create an index using the Elastic API, for example by sending a PUT request to the following endpoint: http://localhost:9200/index_name. Once the index is created, you can add documents to it by sending a POST request to the same endpoint with your JSON data.\nSearching Data Once you have indexed your data, you can search for it using the Elastic API. The most basic search is a match query, which returns all documents that match a specified term. You can perform a match query by sending a GET request to the following endpoint: http://localhost:9200/index_name/_search?q=your_search_term. You can also use more advanced search options such as filtering, aggregation, and highlighting.\nAnalyzing Data Elastic also provides a variety of tools for analyzing data, such as the ability to create visualizations and dashboards using Kibana. Kibana is a separate product from Elastic but it can be easily integrated with it. With Kibana, you can create charts, tables, and maps to visualize your data and gain insights from it.\nIndexing Data Creating an Index The most basic way to create an index in Elasticsearch is to send a PUT request to the Elasticsearch API endpoint for the index you want to create. For example, to create an index named \u0026ldquo;customers\u0026rdquo;, you can use the following command: curl -XPUT http://localhost:9200/customers This will create an index with the default settings and mapping. Customizing Mappings When you create an index, Elasticsearch automatically creates a mapping for it, which defines how the data in the index should be treated. You can customize the mapping for an index by sending a PUT request with a JSON document that defines the mappings you want to use. For example, to create an index named \u0026ldquo;customers\u0026rdquo; with mappings for the fields \u0026ldquo;name\u0026rdquo;, \u0026ldquo;age\u0026rdquo;, and \u0026ldquo;address\u0026rdquo;, you can use the following command: curl -XPUT http://localhost:9200/customers -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39; { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34; } } } }\u0026#39; Update Mappings If you have already created an index and want to update its mappings, you can use the _mapping endpoint and send a PUT request with the updated mappings. For example, to update the mappings for the \u0026ldquo;customers\u0026rdquo; index, you can use the following command: curl -XPUT http://localhost:9200/customers/_mapping -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39; { \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34; } } }\u0026#39; Deleting an Index If you no longer need an index, you can delete it by sending a DELETE request to the Elasticsearch API endpoint for the index. For example, to delete the \u0026ldquo;customers\u0026rdquo; index, you can use the following command: curl -XDELETE http://localhost:9200/customers Searching Data Basic Search The most basic search in Elasticsearch is the match query, which returns all documents that match a specified term. For example, to search for all documents in the \u0026ldquo;customers\u0026rdquo; index that have the term \u0026ldquo;John\u0026rdquo; in the \u0026ldquo;name\u0026rdquo; field, you can use the following command: curl -XGET http://localhost:9200/customers/_search -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39; { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34; } } }\u0026#39; Advanced Search Elasticsearch also offers a wide range of search options to customize your search queries, such as filtering, aggregation, and highlighting. For example, to search for all documents in the \u0026ldquo;customers\u0026rdquo; index that have the term \u0026ldquo;John\u0026rdquo; in the \u0026ldquo;name\u0026rdquo; field and are over the age of 30, you can use the following command: curl -XGET http://localhost:9200/customers/_search -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39; { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34; } }, \u0026#34;filter\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;gt\u0026#34;: 30 } } } } } }\u0026#39; Searching with Aggregations You can also perform data aggregations on your search results to gain insights into your data. For example, to search for all documents in the \u0026ldquo;customers\u0026rdquo; index and group them by the \u0026ldquo;age\u0026rdquo; field, you can use the following command: curl -XGET http://localhost:9200/customers/_search -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39; { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;aggs\u0026#34;: { \u0026#34;group_by_age\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;age\u0026#34; } } } }\u0026#39; Searching with Highlighting You can also use highlighting to highlight the matched search terms in the search results. For example, to search for all documents in the \u0026ldquo;customers\u0026rdquo; index that have the term \u0026ldquo;John\u0026rdquo; in the \u0026ldquo;name\u0026rdquo; field and highlight the matched term, you can use the following command: curl -XGET http://localhost:9200/customers/_search -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39; { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34; } }, \u0026#34;highlight\u0026#34;: { \u0026#34;fields\u0026#34;: { \u0026#34;name\u0026#34;: {} } } }\u0026#39; Aggregated Indexes Sometimes you need to perform aggregation and never use the \u0026ldquo;raw data\u0026rdquo;. In this cases, creating an aggregated index could improve the performance. An aggregation is a way to group, filter or calculate the statistics of your data. There are different types of aggregations in Elasticsearch, such as terms, range, date histogram, and more. For example, you can use the term aggregation to group your data by a specific field, like age, or use range aggregation to filter your data based on a specific range of values.\nCreating Aggregated Indexes You can create an index and perform aggregations on it by sending a PUT request to the Elasticsearch API endpoint for the index you want to create, and including the aggregations in the request body. For example, to create an index named \u0026ldquo;sales\u0026rdquo; with an aggregation on the \u0026ldquo;price\u0026rdquo; field, you can use the following command:\ncurl -XPUT http://localhost:9200/sales -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39; { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;double\u0026#34; }, \u0026#34;date\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;date\u0026#34; } } }, \u0026#34;aggs\u0026#34;: { \u0026#34;avg_price\u0026#34;: { \u0026#34;avg\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;price\u0026#34; } } } }\u0026#39; Using Aggregations Once you have created an aggregated index, you can use the Elasticsearch API to perform search queries on it and retrieve the aggregated results. For example, to retrieve the average price of all documents in the \u0026ldquo;sales\u0026rdquo; index, you can use the following command:\ncurl -XGET http://localhost:9200/sales/_search -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39; { \u0026#34;aggs\u0026#34;: { \u0026#34;avg_price\u0026#34;: { \u0026#34;avg\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;price\u0026#34; } } } }\u0026#39; Combining Aggregations You can also combine multiple aggregations to gain more insights from your data. For example, you can use a terms aggregation to group your data by a specific field, like product type, and then use a range aggregation to filter your data based on a specific range of values.\ncurl -XGET http://localhost:9200/sales/_search -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39; { \u0026#34;aggs\u0026#34;: { \u0026#34;product_type\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;product_type\u0026#34; }, \u0026#34;aggs\u0026#34;: { \u0026#34;price_range\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;price\u0026#34;, \u0026#34;ranges\u0026#34;: [ { \u0026#34;to\u0026#34;: 10 }, { \u0026#34;from\u0026#34;: 10, \u0026#34;to\u0026#34;: 20 }, { \u0026#34;from\u0026#34;: 20 } ] } } } } } }\u0026#39; In this example, the query is grouping the documents by \u0026ldquo;product_type\u0026rdquo; field and then filters them by price range. This way you can have a better understanding of how different product types are performing based on the price range.\nAnother example could be:\ncurl -XGET http://localhost:9200/sales/_search -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39; { \u0026#34;aggs\u0026#34;: { \u0026#34;by_customer_id\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;customer_id\u0026#34; }, \u0026#34;aggs\u0026#34;: { \u0026#34;avg_price\u0026#34;: { \u0026#34;avg\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;price\u0026#34; } } } } } }\u0026#39; This way you can have a better understanding of how different customers are performing based on the average price of their purchases.\nIn conclusion, Elastic is a powerful tool for indexing, searching, and analyzing large volumes of data. It is easy to get started with, and the possibilities are endless with the wide range of features it offers. This is just the tip of the iceberg, and there is a lot more to explore. Give Elastic a try and see how it can help you with your big data needs.\u0026quot;\n","permalink":"https://manuelfedele.github.io/posts/a-quick-overview-of-elasticsearch/","summary":"Introduction Elastic, also known as Elasticsearch, is a powerful search and analytics engine that can be used to index, search, and analyze large volumes of data quickly and in near real-time. It is open-source and built on top of the Lucene library. In this blog post, we will go over the basics of Elastic and how to get started using it.\nInstallation The first step to using Elastic is to install it on your system.","title":"A Quick Overview of Elasticsearch"},{"content":"Unit testing is a software testing technique in which individual units (smallest testable parts) of a software application are tested in isolation from the rest of the application. The goal of unit testing is to validate that each unit of the application is working as intended and meets the specified requirements.\nIn Go, the testing package provides support for writing unit tests. To write unit tests, you need to create a file with a name that ends in _test.go and place it in the same package as the code you want to test. The testing package also provides a testing.T type that represents a testing context and has methods for reporting test failures and logging messages.\nHere is an example of a unit test in Go:\nfunc TestSum(t *testing.T) { result := Sum(2, 3) expected := 5 if result != expected { t.Errorf(\u0026#34;Expected %d, got %d\u0026#34;, expected, result) } } In this example, we are testing a function called Sum that takes two integers as arguments and returns their sum. The test function uses the Errorf method of the testing.T type to report a test failure if the result of the Sum function does not match the expected value.\nTo run the unit tests in Go, you can use the go test command. This command will scan all the files in the current directory and its subdirectories for files with names that end in _test.go, and run the test functions in those files.\nIn Go, test functions have the following conventions:\nThey are always defined in a file with a name that ends in _test.go. They are always in the same package as the code they are testing. They have the name Test followed by the name of the function being tested, with the first letter of the function name in upper case. They take a single argument of type *testing.T, which represents the testing context. Assertion functions: The testing package provides a number of assertion functions that you can use to compare the actual result of a test with the expected result. For example, the Equal function can be used to compare two values for equality: func TestSum(t *testing.T) { result := Sum(2, 3) expected := 5 if result != expected { t.Errorf(\u0026#34;Expected %d, got %d\u0026#34;, expected, result) } } can be rewritten as:\nfunc TestSum(t *testing.T) { result := Sum(2, 3) expected := 5 if !reflect.DeepEqual(result, expected) { t.Errorf(\u0026#34;Expected %d, got %d\u0026#34;, expected, result) } } Test coverage: Go provides a tool called go test that can be used to measure the test coverage of your code. To see the test coverage of your code, you can use the -cover flag when running go test. This will output a report showing the percentage of your code that is covered by tests. It is generally considered good practice to aim for a high test coverage, as it helps ensure that all parts of the code are being tested.\nMocking dependencies: In some cases, you may need to test a function that depends on other functions or external resources, such as a database or a web service. In these cases, you can use a technique called \u0026ldquo;mocking\u0026rdquo; to isolate the function being tested from its dependencies. To mock a dependency, you can create a \u0026ldquo;fake\u0026rdquo; implementation of the dependency that the test function can use instead of the real implementation. This allows you to test the function being tested in isolation, without the need to set up the real dependencies.\nUnit testing is an important part of the software development process because it helps ensure that the application is working as intended and catches bugs early on. It is especially important in Go, where the emphasis on writing small, modular functions makes it easy to write unit tests for individual components of the application.\n","permalink":"https://manuelfedele.github.io/posts/unit-testing-in-golang/","summary":"Unit testing is a software testing technique in which individual units (smallest testable parts) of a software application are tested in isolation from the rest of the application. The goal of unit testing is to validate that each unit of the application is working as intended and meets the specified requirements.\nIn Go, the testing package provides support for writing unit tests. To write unit tests, you need to create a file with a name that ends in _test.","title":"Unit Testing in Golang"},{"content":"Git is a version control system that is widely used in software development to track and manage changes to source code. Two of the most common Git commands that developers use to retrieve updates from a remote repository are git pull and git fetch. While these two commands may seem similar at first glance, they have some important differences that are worth understanding.\nThe git pull command is a combination of git fetch and git merge. When you run git pull, Git first retrieves the latest version of the repository from the remote server. It then merges the changes into your local copy of the repository. This means that git pull not only downloads the changes from the remote repository, but it also integrates them into your local copy.\nOn the other hand, the git fetch command is used to download the latest version of a repository from a remote server, but it does not integrate the changes into the local copy. Instead, it stores the changes in a separate branch, called a \u0026ldquo;remote branch\u0026rdquo;, which can be inspected but not modified. This allows you to review the changes before deciding whether to integrate them into your local copy.\nSo, the main difference between git pull and git fetch is that git pull updates your local copy with the changes from the remote repository and merges the changes into your local copy, while git fetch only downloads the changes from the remote repository and stores them in a separate branch for you to review and merge manually.\nIt\u0026rsquo;s worth noting that git fetch is often used as the first step in a workflow that involves reviewing and merging changes from a remote repository. For example, you might use git fetch to download the latest changes from a remote repository, switch to a new branch to review the changes, and then use git merge to integrate the changes into your local copy.\nIn summary, git pull and git fetch are both useful commands for retrieving updates from a remote repository, but they have different purposes. git pull is used to update your local copy with the changes from a remote repository and merge the changes into your local copy, while git fetch is used to download the changes from the remote repository and store them in a separate branch for you to review and merge manually. Understanding the differences between these two commands can help you use Git more effectively in your workflow.\n","permalink":"https://manuelfedele.github.io/posts/what-is-the-difference-between-git-pull-and-git-fetch/","summary":"Git is a version control system that is widely used in software development to track and manage changes to source code. Two of the most common Git commands that developers use to retrieve updates from a remote repository are git pull and git fetch. While these two commands may seem similar at first glance, they have some important differences that are worth understanding.\nThe git pull command is a combination of git fetch and git merge.","title":"What Is the Difference Between Git Pull and Git Fetch"},{"content":"Streaming video with Go (Golang) is a popular choice for building efficient and scalable video streaming applications. In this blog post, we\u0026rsquo;ll discuss some of the key concepts and considerations for building a video streaming application with Go.\nOne of the first things to consider when building a video streaming application is the underlying video format. Go has built-in support for working with a variety of video formats, including MP4, FLV, and AVI. However, the most common format for streaming video is probably H.264, which is a popular choice due to its high compression ratio and wide compatibility with a variety of devices and platforms.\nAnother important consideration is the protocol used to deliver the video to the client. The most common protocol for streaming video is probably HTTP-based streaming, such as HLS (HTTP Live Streaming) or DASH (Dynamic Adaptive Streaming over HTTP). These protocols allow the video to be delivered over the HTTP protocol, which is widely supported by web browsers and other client devices.\nTo deliver the video using HTTP-based streaming, the server needs to be able to generate and serve the necessary video segments and playlists on-the-fly. Go has a number of libraries and frameworks available that can help with this, such as GStreamer and FFmpeg.\nIn addition to the video format and delivery protocol, there are a number of other considerations to keep in mind when building a video streaming application with Go. For example, you\u0026rsquo;ll need to think about things like scalability, reliability, and security. You may also need to consider issues like bandwidth limitations and network latency, which can have a big impact on the user experience.\nOverall, building a video streaming application with Go can be a great choice due to the language\u0026rsquo;s efficiency and scalability. By carefully considering the various factors involved and choosing the right tools and frameworks, it\u0026rsquo;s possible to build a high-quality and reliable video streaming application with Go.\nWhy is Go a good candidate?\nGo\u0026rsquo;s support for concurrency makes it a good choice for building scalable video streaming applications that can handle a large number of concurrent connections.\nGo\u0026rsquo;s built-in support for HTTP and other network protocols makes it easy to implement the server-side of a video streaming application. You can use the net/http package to build an HTTP server that serves the video segments and playlists to clients.\nTo generate the video segments and playlists on the fly, you can use a library or framework like GStreamer or FFmpeg. These tools provide a powerful set of APIs for working with video and audio streams, and can be used to transcode, mux, and demux video and audio as needed.\nWhen building a video streaming application, it\u0026rsquo;s important to consider issues like scalability, reliability, and security. You may want to use a load balancer to distribute incoming connections across a cluster of servers, and you may want to implement measures like rate limiting and authentication to protect against malicious users.\nFinally, keep in mind that video streaming applications can be resource-intensive, both in terms of CPU and bandwidth. It\u0026rsquo;s important to optimize your Go code and use tools like caching and compression to minimize the impact on your servers and network.\nHere is a simple example of how you might use Go to serve a video file over HTTP:\npackage main import ( \u0026#34;net/http\u0026#34; \u0026#34;log\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/video\u0026#34;, func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, \u0026#34;myvideo.mp4\u0026#34;) }) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } This code sets up an HTTP server that listens on port 8080, and serves the file myvideo.mp4 whenever a client makes a request to /video. The client can then play the video by opening a URL like http://localhost:8080/video in a web browser or media player.\nKeep in mind that this is just a very basic example, and there are many additional considerations to take into account when building a production-grade video streaming application. For example, you\u0026rsquo;ll likely want to use a more advanced server framework, implement streaming protocols like HLS or DASH, and handle issues like scalability and security.\nHere is an example of how you might use the GStreamer library to generate HLS segments on-the-fly in Go:\npackage main import ( \u0026#34;github.com/ziutek/gst\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { gst.Init() // Create a pipeline to read the video file and encode it to H.264 pipeline := gst.ParseLaunch(\u0026#34;filesrc location=myvideo.mp4 ! qtdemux ! h264parse ! mpegtsmux ! hlssink target-duration=10 playlist-length=3\u0026#34;) // Set up an HTTP server to serve the HLS segments and playlist http.HandleFunc(\u0026#34;/video\u0026#34;, func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, r.URL.Path[1:]) }) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) // Run the pipeline pipeline.SetState(gst.StatePlaying) // Wait for the pipeline to finish pipeline.Wait() } This code sets up an HTTP server that listens on port 8080, and serves the HLS segments and playlist generated by the GStreamer pipeline. The pipeline reads the input video file myvideo.mp4, transcodes it to H.264, and muxes it into MPEG-TS segments using the mpegtsmux element. It then uses the hlssink element to generate an HLS playlist and segments, with a target duration of 10 seconds and a playlist length of 3 segments.\nLast but not least, here is an example of how you might use the FFmpeg library to generate HLS segments on-the-fly in Go:\npackage main import ( \u0026#34;github.com/griffithsh/go-ffmpeg-cmd\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // Set up the FFmpeg command cmd := ffmpeg.Command(\u0026#34;ffmpeg\u0026#34;) // Set the input and output options cmd.Input(\u0026#34;myvideo.mp4\u0026#34;) cmd.Output(\u0026#34;video.m3u8\u0026#34;).Type(\u0026#34;hls\u0026#34;).HlsListSize(3).HlsSegmentDuration(10) // Start the command err := cmd.Start() if err != nil { log.Fatal(err) } // Set up an HTTP server to serve the HLS segments and playlist http.HandleFunc(\u0026#34;/video\u0026#34;, func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, r.URL.Path[1:]) }) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) // Wait for the command to finish err = cmd.Wait() if err != nil { log.Fatal(err) } } This code sets up an HTTP server that listens on port 8080, and serves the HLS segments and playlist generated by the FFmpeg command. The command reads the input video file myvideo.mp4 and transcodes it to H.264, generating an HLS playlist and segments with a target duration of 10 seconds and a playlist length of 3 segments.\nTo play the video, the client can open a URL like http://localhost:8080/video.m3u8 in a media player that supports HLS, such as VLC or QuickTime.\nAgain, keep in mind that this is just a basic example, and there are many additional options and configurations available for the GStreamer or for the FFmpeg command.\n","permalink":"https://manuelfedele.github.io/posts/streaming-video-with-golang/","summary":"Streaming video with Go (Golang) is a popular choice for building efficient and scalable video streaming applications. In this blog post, we\u0026rsquo;ll discuss some of the key concepts and considerations for building a video streaming application with Go.\nOne of the first things to consider when building a video streaming application is the underlying video format. Go has built-in support for working with a variety of video formats, including MP4, FLV, and AVI.","title":"Streaming Video With Golang"},{"content":"Protocol buffers, also known as Protobuf, are a popular data serialization format used for communication between services. They are efficient, easy to use, and language-agnostic. In this article, we will look at how to use Protobuf with FastAPI, a modern, high-performance web framework for building APIs with Python.\nFirst, let\u0026rsquo;s start by installing the necessary dependencies. You will need to install fastapi, google-protobuf, and grpcio. You can do this by running the following command:\npip install fastapi google-protobuf grpcio Next, you will need to define your Protobuf message. You can do this by creating a .proto file and defining your message using the Protobuf syntax. For example:\nsyntax = \u0026#34;proto3\u0026#34;; message User { string name = 1; int32 age = 2; string email = 3; } Once you have defined your message, you will need to compile it using the protoc compiler. This will generate Python code that you can use to encode and decode your message. You can do this by running the following command:\nprotoc -I=. --python_out=. path/to/your_message.proto Now that you have compiled your message, you can use it in your FastAPI application. First, you will need to create a FastAPI application and define an endpoint that accepts a Protobuf message. You can do this by using the Body and PROTOBUF parameters from FastAPI\u0026rsquo;s pydantic module:\nfrom fastapi import FastAPI from pydantic import BaseModel, PROTOBUF from path.to.your_message_pb2 import User # import the generated Protobuf message app = FastAPI() class UserRequest(BaseModel): user: PROTOBUF(User) @app.post(\u0026#34;/users\u0026#34;) def create_user(request: UserRequest): user = request.user # do something with the user object return {\u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;} Now, when you send a POST request to the /users endpoint with a Protobuf-encoded message as the request body, FastAPI will automatically decode it and pass the resulting User object to the endpoint handler.\nThe PROTOBUF parameter is used to specify that the request body is encoded using Protobuf. The User class is the compiled Protobuf message that you generated earlier using the protoc compiler.\nProtobuf is a powerful and efficient tool for communication between services, and FastAPI makes it easy to use in your Python applications. With just a few lines of code, you can add Protobuf support to your FastAPI application and start using it to efficiently transfer data between services.\n","permalink":"https://manuelfedele.github.io/posts/use-protobuf-with-fastapi/","summary":"Protocol buffers, also known as Protobuf, are a popular data serialization format used for communication between services. They are efficient, easy to use, and language-agnostic. In this article, we will look at how to use Protobuf with FastAPI, a modern, high-performance web framework for building APIs with Python.\nFirst, let\u0026rsquo;s start by installing the necessary dependencies. You will need to install fastapi, google-protobuf, and grpcio. You can do this by running the following command:","title":"Use Protobuf With Fastapi"},{"content":"Context in Go is a type that carries a request-scoped value across API boundaries. It is designed to be used in long-lived requests, such as an HTTP server handling multiple requests over the lifetime of a process.\nOne of the primary use cases of context is to cancel long-running operations. For example, if an HTTP server receives a request with a cancelation token, it can use that token to cancel the request if the client closes the connection. This helps to avoid resource leaks by freeing up resources that would have been used by the request.\nContext can also be used to store request-scoped values, such as a database connection or an authenticated user. This allows different parts of the codebase to share information about the request without relying on global state or passing the values through function parameters.\nTo use context in Go, you first need to import the \u0026ldquo;context\u0026rdquo; package. Then, you can create a context by calling the context.WithValue function, which takes a parent context and a key-value pair. You can then pass the context to functions that accept it as an argument.\nFor example, here\u0026rsquo;s how you might create a context with a cancelation token and pass it to an HTTP handler:\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) func handler(w http.ResponseWriter, r *http.Request) { ctx, cancel := context.WithTimeout(r.Context(), time.Minute) defer cancel() // Do some work with the request. // If the client closes the connection, // the cancel function is called and the work is stopped. } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } In this example, the context is created with a timeout of one minute. If the client closes the connection before the handler finishes, the cancel function is called and the work is stopped.\nIt\u0026rsquo;s important to note that context is not intended to be used as a means of communication between goroutines. While it is possible to use context to pass values between goroutines, it is generally better to use channels for this purpose.\nThe context package also provides several functions for creating and manipulating contexts. These include:\ncontext.Background: Returns a background context. This is the root of the context tree and is typically used as the parent of a context created with context.WithValue. context.WithValue: Returns a new context with the given key-value pair. The new context is derived from the parent context and carries the value across API boundaries. context.WithCancel: Returns a new context and a cancel function. The cancel function can be called to cancel the context and all contexts derived from it. context.WithTimeout: Returns a new context and a cancel function. The cancel function is called when the timeout elapses or when the parent context is canceled, whichever occurs first. context.WithDeadline: Returns a new context and a cancel function. The cancel function is called when the deadline elapses or when the parent context is canceled, whichever occurs first. Here\u0026rsquo;s an example of how you might use these functions to create a context with a cancelation token and a request-scoped value: package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // Create a background context with a cancelation token. ctx, cancel := context.WithCancel(context.Background()) defer cancel() // Create a new context with a request-scoped value. valueCtx := context.WithValue(ctx, \u0026#34;user_id\u0026#34;, 123) // Create a new context with a deadline. deadline, _ := time.Parse(time.RFC3339, \u0026#34;2022-01-01T00:00:00Z\u0026#34;) deadlineCtx, _ := context.WithDeadline(valueCtx, deadline) // Print the values from all three contexts. fmt.Println(\u0026#34;Background:\u0026#34;, ctx.Value(\u0026#34;user_id\u0026#34;)) fmt.Println(\u0026#34;Value:\u0026#34;, valueCtx.Value(\u0026#34;user_id\u0026#34;)) fmt.Println(\u0026#34;Deadline:\u0026#34;, deadlineCtx.Value(\u0026#34;user_id\u0026#34;)) } In this example, we create a background context with a cancelation token and a request-scoped value using the context.WithCancel and context.WithValue functions. We then create a new context with a deadline using the context.WithDeadline function.\nWhen we print the values from the contexts, we can see that the values are propagated down the context tree. The background context has the cancelation token, the value context has both the cancelation token and the request-scoped value, and the deadline context has all three.\nIt\u0026rsquo;s worth noting that the context package is designed to be used with long-lived requests, such as an HTTP server handling multiple requests over the lifetime of a process. It is not intended to be used as a means of communication between goroutines or as a general-purpose synchronization mechanism.\nIn conclusion, the context package in Go is a powerful tool for carrying request-scoped values and cancelation tokens across API boundaries. It allows you to cancel long-running operations, store request-scoped values, and share information between parts of the codebase without relying on global state. If you\u0026rsquo;re building an application in Go, chances are you\u0026rsquo;ll find context to be an indispensable tool in your toolkit.\n","permalink":"https://manuelfedele.github.io/posts/the-context-package/","summary":"Context in Go is a type that carries a request-scoped value across API boundaries. It is designed to be used in long-lived requests, such as an HTTP server handling multiple requests over the lifetime of a process.\nOne of the primary use cases of context is to cancel long-running operations. For example, if an HTTP server receives a request with a cancelation token, it can use that token to cancel the request if the client closes the connection.","title":"The Context Package"},{"content":"Async/await is a powerful programming construct that allows you to write asynchronous code in a synchronous-like style. It was introduced in Python 3.5 as part of the asyncio module and has become a popular choice for writing concurrent and parallel code in Python.\nIn this post, we\u0026rsquo;ll take a look at what async/await is and how it works, as well as some of the benefits and drawbacks of using it. We\u0026rsquo;ll also see some examples of how to use async/await in Python to write efficient and scalable code.\nWhat is async/await? Async/await is a way of writing asynchronous code that looks and feels like synchronous code. It allows you to write code that can run concurrently with other tasks, without the overhead and complexity of using threads or processes.\nTo use async/await in Python, you need to use the async and await keywords. An async function is defined using the async def syntax, and it can contain one or more await expressions. An await expression is used to suspend the execution of the async function until the result of a call to an async function is available.\nHere\u0026rsquo;s an example of an async function that uses an await expression to wait for the result of a call to an async function:\nimport asyncio async def foo(): result = await asyncio.sleep(1) print(result) async def main(): await foo() asyncio.run(main()) In this example, the foo function uses the await keyword to suspend its execution until the asyncio.sleep function completes. The asyncio.sleep function is an async function that returns after a specified number of seconds, and it\u0026rsquo;s often used as a placeholder for more complex async operations.\nBenefits of async/await Async/await has several benefits compared to other approaches for writing concurrent and parallel code in Python:\nSimplicity: Async/await is easy to understand and use, especially for developers who are familiar with synchronous programming. It allows you to write asynchronous code in a linear, procedural style, without the need for complex control structures or callback functions.\nEfficiency: Async/await can lead to more efficient code, as it allows you to use fewer resources and avoid the overhead of using threads or processes. Async functions are implemented using coroutines, which are lightweight and can be scheduled and switched between efficiently.\nScalability: Async/await can help you write scalable code that can handle a large number of concurrent tasks. By using async/await, you can take advantage of Python\u0026rsquo;s event loop and avoid blocking the main thread, which can lead to better performance and higher throughput.\nDrawbacks of async/await Async/await is not a silver bullet and has some drawbacks that you should be aware of:\nComplexity: Async/await can make your code more complex, as it introduces new concepts and syntax that you need to learn and understand. Debugging async code can also be more challenging, as you need to deal with concurrency and the event loop. Performance: Async/await can lead to lower performance in some cases, especially when used with I/O-bound tasks that involve a lot of context switching between async functions. The overhead of scheduling and switching between coroutines can add up, leading to slower performance compared to other approaches like multithreading or multiprocessing. Not always the best choice: Async/await is not the best choice for every situation. It\u0026rsquo;s particularly well-suited for tasks that involve waiting for I/O operations, but it\u0026rsquo;s not as efficient for CPU-bound tasks that require a lot of computation. In these cases, you might be better off using multiprocessing or multithreading to take advantage of multiple CPU cores Limited support: Async/await is not supported by all libraries and frameworks in Python, and you might encounter compatibility issues when trying to use it with certain libraries. This can limit the usefulness of async/await and make it more difficult to use in some cases. When to use async/await Async/await is a powerful tool for writing concurrent and parallel code in Python, but it\u0026rsquo;s not always the best choice for every situation. Here are some cases where you might consider using async/await:\nI/O-bound tasks: Async/await is particularly well-suited for tasks that involve waiting for input/output operations, such as reading from a database, making HTTP requests, or interacting with the file system. By using async/await, you can avoid blocking the main thread and allow other tasks to run concurrently.\nHigh-concurrency tasks: Async/await can also be useful for tasks that need to handle a large number of concurrent requests or connections, such as servers or real-time apps. By using async/await, you can take advantage of Python\u0026rsquo;s event loop and scale your code more easily.\nCPU-bound tasks: Async/await is not the best choice for tasks that are CPU-bound and require a lot of computation. In these cases, you might be better off using multiprocessing or multithreading to take advantage of multiple CPU cores.\nExample: Async HTTP client To see how async/await works in practice, let\u0026rsquo;s look at an example of an async HTTP client using the aiohttp library. Here\u0026rsquo;s the code for the client:\nimport aiohttp async def fetch(session, url): async with session.get(url) as response: return await response.text() async def main(): async with aiohttp.ClientSession() as session: html = await fetch(session, \u0026#34;https://www.example.com\u0026#34;) print(html) asyncio.run(main()) In this example, the fetch function is an async function that uses the aiohttp library to make an HTTP GET request to a specified URL. It uses the await keyword to suspend its execution until the response is available. The main function is another async function that uses the aiohttp library to create a client session and then calls the fetch function to get the HTML of a website.\nYou can run this code using the asyncio.run function, which will execute the async function and wait for it to complete.\nConclusion Async/await is a powerful programming construct that allows you to write asynchronous code in a synchronous-like style. It can lead to more efficient and scalable code, especially for tasks that involve I/O operations or high concurrency. However, it\u0026rsquo;s not always the best choice for every situation, and you should consider the trade-offs and drawbacks before using it.\nI hope this post gave you a good understanding of async/await and how it works in Python. If you have any questions or comments, feel free to leave them below!\n","permalink":"https://manuelfedele.github.io/posts/understand-async-await-in-python/","summary":"Async/await is a powerful programming construct that allows you to write asynchronous code in a synchronous-like style. It was introduced in Python 3.5 as part of the asyncio module and has become a popular choice for writing concurrent and parallel code in Python.\nIn this post, we\u0026rsquo;ll take a look at what async/await is and how it works, as well as some of the benefits and drawbacks of using it. We\u0026rsquo;ll also see some examples of how to use async/await in Python to write efficient and scalable code.","title":"Understand Async Await in Python"},{"content":" Install Rust Before you can start writing Rust code, you\u0026rsquo;ll need to install the Rust programming language on your computer. You can do this by following the instructions on the Rust website (https://www.rust-lang.org/tools/install).\nSet up a new Rust project Once you have Rust installed, you\u0026rsquo;ll need to create a new Rust project using the cargo command-line tool. Open a terminal and navigate to the directory where you want to store your project, then run the following command: cargo new telegram-bot \u0026ndash;bin. This will create a new Rust project called \u0026ldquo;telegram-bot\u0026rdquo; with a binary crate (executable).\nAdd dependencies In order to use the Telegram API and interact with the Telegram bot API, you\u0026rsquo;ll need to add some dependencies to your project. You can do this by adding the following to your Cargo.toml file:\n[dependencies] reqwest = \u0026#34;0.10.4\u0026#34; serde = { version = \u0026#34;1.0\u0026#34;, features = [\u0026#34;derive\u0026#34;] } serde_json = \u0026#34;1.0\u0026#34; Set up a bot In order to use the Telegram API, you\u0026rsquo;ll need to set up a bot and get an API token. To do this, follow the instructions on the Telegram API documentation (https://core.telegram.org/bots/api#authorizing-your-bot).\nCreate a function to send requests Once you have your API token, you can start interacting with the Telegram API by sending HTTP requests. To make it easier to send requests, you can create a function that takes care of all the details for you. Here\u0026rsquo;s an example of how you might do this:\nuse std::collections::HashMap; use reqwest::Client; fn send_request( client: \u0026amp;Client, api_token: \u0026amp;str, method: \u0026amp;str, params: \u0026amp;HashMap\u0026lt;\u0026amp;str, \u0026amp;str\u0026gt;, ) -\u0026gt; Result\u0026lt;serde_json::Value, reqwest::Error\u0026gt; { let mut url = String::new(); url.push_str(\u0026#34;https://api.telegram.org/bot\u0026#34;); url.push_str(api_token); url.push_str(\u0026#34;/\u0026#34;); url.push_str(method); let mut response = client.get(\u0026amp;url).query(params).send()?; let json: serde_json::Value = response.json()?; Ok(json) } This function takes a reqwest::Client, your API token, the name of the API method you want to call, and a HashMap of parameters. It constructs the URL for the API method, sends an HTTP GET request using reqwest, and returns the JSON response as a serde_json::Value.\nWrite your bot logic Now that you have the basic infrastructure in place, you can start writing the logic for your bot. There are many ways you can do this, but a common approach is to use a loop that listens for updates from the Telegram API and then responds to them appropriately. Here\u0026rsquo;s an example of how you might set this up:\nuse std::collections::HashMap; // Set up the client and API token let client = Client::new(); let api_token = \u0026#34;YOUR_API_TOKEN_HERE\u0026#34;; // Set the initial offset to 0 let mut offset = 0; // Set up a loop to listen for updates loop { // Set up the parameters for the getUpdates method let mut params = HashMap::new(); params.insert(\u0026#34;offset\u0026#34;, \u0026amp;offset.to_string()); params.insert(\u0026#34;timeout\u0026#34;, \u0026#34;30\u0026#34;); // Send the request and get the response let response = send_request(\u0026amp;client, \u0026amp;api_token, \u0026#34;getUpdates\u0026#34;, \u0026amp;params)?; // Check if there are any updates if let Some(updates) = response[\u0026#34;result\u0026#34;].as_array() { // Process each update for update in updates { // Increment the offset offset = update[\u0026#34;update_id\u0026#34;].as_u64().unwrap() + 1; // Do something with the update here... } } } This code sets up a loop that sends a request to the getUpdates method of the Telegram API every 30 seconds. If there are any updates, it processes them one by one and increments the offset variable to keep track of which updates have been processed.\nProcess the updates Inside the loop, you\u0026rsquo;ll need to write code to process each update and decide how to respond to it. Here\u0026rsquo;s an example of how you might do this:\nif let Some(message) = update[\u0026#34;message\u0026#34;].as_object() { // Get the chat ID and message text let chat_id = message[\u0026#34;chat\u0026#34;][\u0026#34;id\u0026#34;].as_i64().unwrap(); let text = message[\u0026#34;text\u0026#34;].as_str().unwrap(); // Check if the message is a command if text.starts_with(\u0026#34;/\u0026#34;) { let command = text[1..].split_whitespace().next().unwrap(); // Handle the command here... } else { // Send a message back to the chat let mut params = HashMap::new(); params.insert(\u0026#34;chat_id\u0026#34;, \u0026amp;chat_id.to_string()); params.insert(\u0026#34;text\u0026#34;, \u0026#34;You said: \u0026#34;); params.insert(\u0026#34;text\u0026#34;, text); let _response = send_request(\u0026amp;client, \u0026amp;api_token, \u0026#34;sendMessage\u0026#34;, \u0026amp;params)?; } } This code checks if the update contains a message, gets the chat ID and message text, and then checks if the message is a command (i.e., starts with a /). If it\u0026rsquo;s a command, you can handle it as you see fit. If it\u0026rsquo;s not a command, the code sends a message back to the chat with the original message text.\nI hope this gives you a good starting point for developing your own Telegram bot using Rust!\n","permalink":"https://manuelfedele.github.io/posts/create-a-telegram-bot-with-rust/","summary":"Install Rust Before you can start writing Rust code, you\u0026rsquo;ll need to install the Rust programming language on your computer. You can do this by following the instructions on the Rust website (https://www.rust-lang.org/tools/install).\nSet up a new Rust project Once you have Rust installed, you\u0026rsquo;ll need to create a new Rust project using the cargo command-line tool. Open a terminal and navigate to the directory where you want to store your project, then run the following command: cargo new telegram-bot \u0026ndash;bin.","title":"Create a Telegram Bot With Rust"},{"content":"FastAPI is a modern, fast, web framework for building APIs with Python 3.7 and above. It is built on top of Starlette, a lightweight ASGI framework, and uses the uvicorn ASGI server.\nHere is an example of how to create a web server with FastAPI and uvicorn:\nInstall FastAPI and uvicorn using pip: pip install fastapi uvicorn Create a file called main.py and import FastAPI: from fastapi import FastAPI app = FastAPI() Define a function that will be the endpoint for your API. This function should have a request parameter that specifies the HTTP request and a response parameter that specifies the HTTP response. You can use the @app.get decorator to define a function as a GET endpoint: @app.get(\u0026#34;/\u0026#34;) def read_root(request, response): response.status_code = 200 return {\u0026#34;Hello\u0026#34;: \u0026#34;World\u0026#34;} Run the web server using uvicorn: if __name__ == \u0026#34;__main__\u0026#34;: import uvicorn uvicorn.run(app, host=\u0026#34;0.0.0.0\u0026#34;, port=8000) This will start the web server on the specified host and port (in this case, 0.0.0.0 and 8000). You can then access the endpoint at http://0.0.0.0:8000/.\nYou can find more information about FastAPI and uvicorn in the FastAPI documentation and the Uvicorn documentation.\n","permalink":"https://manuelfedele.github.io/posts/create-webserver-with-fastapi-and-uvicorn/","summary":"FastAPI is a modern, fast, web framework for building APIs with Python 3.7 and above. It is built on top of Starlette, a lightweight ASGI framework, and uses the uvicorn ASGI server.\nHere is an example of how to create a web server with FastAPI and uvicorn:\nInstall FastAPI and uvicorn using pip: pip install fastapi uvicorn Create a file called main.py and import FastAPI: from fastapi import FastAPI app = FastAPI() Define a function that will be the endpoint for your API.","title":"Create a Webserver With Fastapi and Uvicorn"},{"content":"The keyword \u0026ldquo;yield\u0026rdquo; is a important part of the Python programming language, and it can be used in a number of different ways. In this article, we\u0026rsquo;ll take a closer look at what the yield keyword does in Python, and how it can be used to create more efficient and powerful programs.\nThe primary use of the yield keyword is to create a generator function. A generator function is a special type of function that produces a sequence of values, one at a time, when it is called. Unlike a regular function, which executes all of its code and returns a single value, a generator function can be paused at any point and resumed later, allowing it to produce a potentially infinite sequence of values.\nTo create a generator function in Python, you simply use the yield keyword in place of the return keyword. For example, here is a simple generator function that produces a sequence of numbers:\ndef count_up_to(max): count = 1 while count \u0026lt;= max: yield count count += 1 When this generator function is called, it will execute the code until it encounters the yield keyword, at which point it will pause and return the value of \u0026ldquo;count\u0026rdquo; to the caller. The generator function can then be resumed from where it left off the next time it is called, allowing it to produce the next value in the sequence.\nGenerator functions are particularly useful when you need to work with large sequences of data, as they allow you to process the data one piece at a time, rather than having to load it all into memory at once. They are also useful for creating infinite sequences, such as an infinite stream of random numbers.\nIn addition to creating generator functions, the yield keyword can also be used in the body of a regular function to produce a generator object. When a function contains a yield statement, it becomes a generator function, even if it does not use the \u0026ldquo;yield\u0026rdquo; keyword in its definition.\nHere is an example of a regular function that uses the yield keyword to produce a generator object:\ndef even_numbers(max): for num in range(max): if num % 2 == 0: yield num This function will produce a generator object that produces all of the even numbers up to the specified maximum value.\nIn summary, the yield keyword is a powerful tool in Python that allows you to create generator functions and generator objects. Generator functions and objects are useful for working with large sequences of data and for creating infinite sequences, and they can help you create more efficient and powerful programs in Python.\n","permalink":"https://manuelfedele.github.io/posts/what-does-yield-keyword-do-in-python/","summary":"The keyword \u0026ldquo;yield\u0026rdquo; is a important part of the Python programming language, and it can be used in a number of different ways. In this article, we\u0026rsquo;ll take a closer look at what the yield keyword does in Python, and how it can be used to create more efficient and powerful programs.\nThe primary use of the yield keyword is to create a generator function. A generator function is a special type of function that produces a sequence of values, one at a time, when it is called.","title":"What Does Yield Keyword Do in Python"},{"content":"Protocol Buffers (Protobuf) is a language- and platform-neutral data serialization format developed by Google. It allows you to define data structures in a .proto file and then use code generation tools to generate code in various languages for working with those data structures.\nTo use Protobuf with Go, you\u0026rsquo;ll need to do the following:\nInstall the Protobuf compiler (protoc) and the Go Protobuf plugin:\n# Install protoc wget https://github.com/protocolbuffers/protobuf/releases/download/v3.14.0/protoc-3.14.0-linux-x86_64.zip unzip protoc-3.14.0-linux-x86_64.zip -d protoc3 sudo mv protoc3/bin/* /usr/local/bin/ # Install the Go Protobuf plugin go get -u github.com/golang/protobuf/protoc-gen-go Define your data structures in a .proto file. For example:\nsyntax = \u0026#34;proto3\u0026#34;; package example; message Person { string name = 1; int32 age = 2; bool is_employee = 3; } message Address { string street = 1; string city = 2; string state = 3; string zip = 4; } Use the Protobuf compiler to generate Go code from your .proto file:\nprotoc --go_out=. example.proto This will generate a Go file named example.pb.go that contains code for working with the data structures you defined in your .proto file.\nImport the generated code and use it in your Go program. For example:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;example\u0026#34; ) func main() { // Create a new Person object p := example.Person{ Name: \u0026#34;John Smith\u0026#34;, Age: 30, IsEmployee: true, Addresses: []*example.Address{ \u0026amp;example.Address{ Street: \u0026#34;123 Main Street\u0026#34;, City: \u0026#34;New York\u0026#34;, State: \u0026#34;NY\u0026#34;, Zip: \u0026#34;10001\u0026#34;, }, \u0026amp;example.Address{ Street: \u0026#34;456 Market Street\u0026#34;, City: \u0026#34;San Francisco\u0026#34;, State: \u0026#34;CA\u0026#34;, Zip: \u0026#34;94111\u0026#34;, }, }, } // Serialize the object to a Protobuf-encoded byte slice data, err := p.Marshal() if err != nil { fmt.Println(err) return } // Deserialize the byte slice back into a new Person object var p2 example.Person if err := p2.Unmarshal(data); err != nil { fmt.Println(err) return } fmt.Println(p2.Name, p2.Age, p2.IsEmployee) for _, addr := range p2.Addresses { fmt.Println(addr.Street, addr.City, addr.State, addr.Zip) } } In this example, we define a Person data structure with a name, age, and a list of addresses in a .proto file. We then use the Protobuf compiler to generate Go code for working with these data structures. In the Go code, we create a new Person object and serialize it to a Protobuf-encoded byte slice using the Marshal method. We then deserialize the byte slice back into a new Person object using the Unmarshal method. Finally, we print the deserialized object\u0026rsquo;s name, age, and list of addresses to the console.\nI hope this helps give you an idea of how to use Protobuf with Go. You can find more detailed documentation and examples in the Protobuf documentation.\n","permalink":"https://manuelfedele.github.io/posts/use-protobuf-with-golang/","summary":"Protocol Buffers (Protobuf) is a language- and platform-neutral data serialization format developed by Google. It allows you to define data structures in a .proto file and then use code generation tools to generate code in various languages for working with those data structures.\nTo use Protobuf with Go, you\u0026rsquo;ll need to do the following:\nInstall the Protobuf compiler (protoc) and the Go Protobuf plugin:\n# Install protoc wget https://github.com/protocolbuffers/protobuf/releases/download/v3.14.0/protoc-3.14.0-linux-x86_64.zip unzip protoc-3.","title":"Use Protobuf With Golang"},{"content":"Creating a Command Line Application to Separate Files by Extension in Go If you have a folder with a large number of files and you want to organize them by file extension, you can create a command line application to do this automatically using Go. Go, also known as Golang, is a programming language developed by Google that is designed to be fast, statically-typed, and easy to learn. In this article, we\u0026rsquo;ll walk through the steps to create a Go program that separates files in a given folder into subfolders based on their extension.\nInstall Go Before you can start writing Go code, you\u0026rsquo;ll need to install the Go programming language on your machine. Go is available for Windows, macOS, and Linux, and you can download the latest release from the official Go website at https://golang.org/dl/. Once you\u0026rsquo;ve downloaded the installation package, follow the prompts to install Go on your system.\nSet Up Your Go Workspace Go uses a specific directory structure for organizing code, and it\u0026rsquo;s important to set this up correctly before you start writing your program. To set up your Go workspace, create a new directory called \u0026ldquo;go\u0026rdquo; in your home directory. Inside the \u0026ldquo;go\u0026rdquo; directory, create a subdirectory called \u0026ldquo;src\u0026rdquo; and another subdirectory called \u0026ldquo;bin\u0026rdquo;. Your Go workspace should now look like this:\n$HOME/go/ src/ bin/ Create a New Go Project Now that you have Go installed and your workspace set up, you can create a new Go project. To do this, open a terminal window and navigate to the \u0026ldquo;src\u0026rdquo; directory inside your Go workspace. From here, create a new directory for your project and navigate into it. For example, if your project is called \u0026ldquo;separate-files\u0026rdquo;, you might create a directory like this:\ncd $HOME/go/src mkdir separate-files cd separate-files Write the Go Code With your Go project set up, you can now start writing the code to separate the files by extension. Here\u0026rsquo;s a basic outline of what your program will do:\nParse the command line arguments to get the name of the folder to process. Read the list of files in the specified folder. Iterate over the list of files, creating a subfolder for each unique file extension. Move each file into the appropriate subfolder based on its extension. To start, create a new file called \u0026ldquo;main.go\u0026rdquo; in your project directory and add the following code: package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // Parse the command line arguments args := os.Args[1:] if len(args) != 1 { fmt.Println(\u0026#34;Usage: separate-files \u0026lt;folder\u0026gt;\u0026#34;) os.Exit(1) } folder := args[0] // Read the list of files in the specified folder files, err := ioutil.ReadDir(folder) if err != nil { fmt.Printf(\u0026#34;Error reading files in folder %s: %v\\n\u0026#34;, folder, err) os.Exit(1) } // Iterate over the list of files and create a subfolder for each unique extension extensions := make(map[string]bool) for _, file := range files { if file.IsDir() { continue } extension := filepath.Ext(file.Name()) extensions[extension] = true } for extension := range extensions { // Create a subfolder for each unique extension err := os.Mkdir(filepath.Join(folder, extension), 0700) if err != nil { fmt.Printf(\u0026#34;Error creating subfolder for extension %s: %v\\n\u0026#34;, extension, err) continue } } // Move each file into the appropriate subfolder based on its extension for _, file := range files { if file.IsDir() { continue } extension := filepath.Ext(file.Name()) src := filepath.Join(folder, file.Name()) dst := filepath.Join(folder, extension, file.Name()) err := os.Rename(src, dst) if err != nil { fmt.Printf(\u0026#34;Error moving file %s to subfolder %s: %v\\n\u0026#34;, src, extension, err) continue } } } This code reads the list of files in the specified folder, creates a subfolder for each unique file extension, and then moves each file into the appropriate subfolder based on its extension.\nTo use this program, save the file and run it from the command line with the name of the folder you want to process as an argument. For example:\ngo run main.go /path/to/folder This will separate the files in the specified folder into subfolders based on their extension.\nTo package and distribute your Go code, you have a few options:\nCompile the code into a standalone executable: You can use the go build command to compile your Go code into a standalone executable that you can distribute to users. For example, to build an executable called \u0026ldquo;separate-files\u0026rdquo; from the code above, you can run the following command: go build -o separate-files main.go This will create an executable file called \u0026ldquo;separate-files\u0026rdquo; in the current directory that you can distribute to users.\nUse a package manager: There are several package managers available for Go that you can use to distribute your code, including dep, glide, and godep. These tools allow you to manage the dependencies for your project and build a single package that includes all of the necessary code and libraries.\nUse a containerization tool: You can also use a containerization tool like Docker to package your code and its dependencies into a container image that can be easily distributed and run on any machine. This is a good option if you want to ensure that your code runs consistently across different environments.\nOnce you have packaged your code, you can distribute it to users in a variety of ways, such as uploading it to a package repository, hosting it on a website, or sharing it via email or file sharing services.\n","permalink":"https://manuelfedele.github.io/posts/create-command-line-application-with-golang/","summary":"Creating a Command Line Application to Separate Files by Extension in Go If you have a folder with a large number of files and you want to organize them by file extension, you can create a command line application to do this automatically using Go. Go, also known as Golang, is a programming language developed by Google that is designed to be fast, statically-typed, and easy to learn. In this article, we\u0026rsquo;ll walk through the steps to create a Go program that separates files in a given folder into subfolders based on their extension.","title":"Create Command Line Application With Golang"},{"content":"GitHub Pages is a free service that allows you to host your website directly from a GitHub repository. It is a great platform for developers to showcase their portfolio, document their projects, or create a personal blog. In this article, we will walk through the steps of creating a static website using GitHub Pages and Gatsby, a popular static site generator.\nInstall Gatsby First, you will need to install Gatsby by running the following command in your terminal: npm install -g gatsby-cli Create a new Gatsby project gatsby new my-website This will create a new directory called my-website with the necessary files and dependencies for your Gatsby project.\nTest your Gatsby project To test your Gatsby project, navigate to the project directory and run the following command: gatsby develop This will start a development server and you should see a message indicating that your site is running at http://localhost:8000. Open this URL in your browser to see your Gatsby site.\nCreate a repository on GitHub Next, you will need to create a new repository on GitHub to host your website. To do this, log in to your GitHub account and click on the \u0026ldquo;New\u0026rdquo; button in the top right corner. Give your repository a name (e.g. my-website) and click \u0026ldquo;Create repository\u0026rdquo;.\nConnect your local project to the GitHub repository Next, you will need to connect your local Gatsby project to the GitHub repository you just created. To do this, open a terminal window and navigate to your Gatsby project directory. Then, run the following commands:\ngit init git remote add origin https://github.com/YOUR_USERNAME/my-website.git Replace YOUR_USERNAME with your actual GitHub username.\nDeploy your Gatsby site to GitHub Pages To deploy your Gatsby site to GitHub Pages, you will need to build the site and push the built files to the gh-pages branch of your repository. To do this, run the following commands: gatsby build git add -A git commit -m \u0026#34;Initial commit\u0026#34; git push origin master:gh-pages This will build your Gatsby site and push the built files to the gh-pages branch of your repository.\nEnable GitHub Pages Finally, you will need to enable GitHub Pages for your repository. To do this, go to the settings page for your repository and scroll down to the \u0026ldquo;GitHub Pages\u0026rdquo; section. Select the gh-pages branch as the source and click \u0026ldquo;Save\u0026rdquo;. Your Gatsby site should now be live on GitHub Pages at the URL https://YOUR_USERNAME.github.io/my-website.\nThat\u0026rsquo;s it! You have successfully created a static website using GitHub Pages and Gatsby. You can now customize your site by editing the files in your Gatsby project and deploying the updates to GitHub Pages.\n","permalink":"https://manuelfedele.github.io/posts/create-website-with-gatsby-and-github-pages/","summary":"GitHub Pages is a free service that allows you to host your website directly from a GitHub repository. It is a great platform for developers to showcase their portfolio, document their projects, or create a personal blog. In this article, we will walk through the steps of creating a static website using GitHub Pages and Gatsby, a popular static site generator.\nInstall Gatsby First, you will need to install Gatsby by running the following command in your terminal: npm install -g gatsby-cli Create a new Gatsby project gatsby new my-website This will create a new directory called my-website with the necessary files and dependencies for your Gatsby project.","title":"Create Website With Gatsby and Github Pages"},{"content":"Using Golang and Redis Redis is an in-memory data structure store that can be used as a database, cache, and message broker. It is known for its speed, simplicity, and flexibility. In this article, we will discuss how to use Redis with Golang, a popular programming language known for its simplicity, performance, and concurrency support.\nBefore we dive into the details of using Redis with Golang, let\u0026rsquo;s first understand the requirements of the application.\nRequirements The application should be able to connect to a Redis server. The application should be able to store and retrieve data from Redis. The application should be able to perform basic operations on Redis data structures, such as strings, lists, sets, and hashes. Setting up Redis To use Redis with Golang, you will need to have a Redis server installed and running on your system. You can download the latest version of Redis from the official website and follow the instructions to install and run the server.\nOnce the Redis server is running, you can use the following Go libraries to connect to the server and perform various operations:\nredis: A low-level Redis client library for Go. radix: A higher-level Redis client library for Go that provides a more convenient API and additional features. Connecting to Redis To connect to the Redis server using the redis library, you can use the Dial function:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/gomodule/redigo/redis\u0026#34; ) func main() { // Connect to the Redis server conn, err := redis.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6379\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // Print the Redis version version, err := redis.String(conn.Do(\u0026#34;INFO\u0026#34;, \u0026#34;server\u0026#34;)) if err != nil { log.Fatal(err) } fmt.Println(version) } This will connect to the Redis server running on the local host at the default port (6379) and print the Redis version.\nTo connect to the Redis server using the radix library, you can use the Dial function:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mediocregopher/radix/v3\u0026#34; ) func main() { // Connect to the Redis server conn, err := radix.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6379\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // Print the Redis version var version string err = conn.Do(radix.Cmd(\u0026amp;version, \u0026#34;INFO\u0026#34;, \u0026#34;server\u0026#34;)) if err != nil { log.Fatal(err) } fmt.Println(version) } This will also connect to the Redis server running on the local host at the default port (6379).\nStoring and Retrieving Data Once you have connected to the Redis server, you can use various Redis commands to store and retrieve data.\nStrings To store and retrieve a string value using the redis library, you can use the Do function and the redis.String function:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/gomodule/redigo/redis\u0026#34; ) func main() { // Connect to the Redis server conn, err := redis.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6379\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // Set the key \u0026#34;message\u0026#34; to the value \u0026#34;Hello, Redis!\u0026#34; _, err = conn.Do(\u0026#34;SET\u0026#34;, \u0026#34;message\u0026#34;, \u0026#34;Hello, Redis!\u0026#34;) if err != nil { log.Fatal(err) } // Retrieve the value of the key \u0026#34;message\u0026#34; value, err := redis.String(conn.Do(\u0026#34;GET\u0026#34;, \u0026#34;message\u0026#34;)) if err != nil { log.Fatal(err) } // Print the value fmt.Println(value) } This will set the key \u0026ldquo;message\u0026rdquo; to the value \u0026ldquo;Hello, Redis!\u0026rdquo; and retrieve the value of the key \u0026ldquo;message\u0026rdquo;, printing \u0026ldquo;Hello, Redis!\u0026rdquo;.\nTo store and retrieve a string value using the radix library, you can use the Do function and the radix.String function:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mediocregopher/radix/v3\u0026#34; ) func main() { // Connect to the Redis server conn, err := radix.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6379\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // Set the key \u0026#34;message\u0026#34; to the value \u0026#34;Hello, Redis!\u0026#34; err = conn.Do(radix.FlatCmd(nil, \u0026#34;SET\u0026#34;, \u0026#34;message\u0026#34;, \u0026#34;Hello, Redis!\u0026#34;)) if err != nil { log.Fatal(err) } // Retrieve the value of the key \u0026#34;message\u0026#34; var value string err = conn.Do(radix.Cmd(\u0026amp;value, \u0026#34;GET\u0026#34;, \u0026#34;message\u0026#34;)) if err != nil { log.Fatal(err) } // Print the value fmt.Println(value) } This will also set the key \u0026ldquo;message\u0026rdquo; to the value \u0026ldquo;Hello, Redis!\u0026rdquo; and retrieve the value of the key \u0026ldquo;message\u0026rdquo;, printing \u0026ldquo;Hello, Redis!\u0026rdquo;.\nLists To store and retrieve a list using the redis library, you can use the Do function and the redis.Strings function:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/gomodule/redigo/redis\u0026#34; ) func main() { // Connect to the Redis server conn, err := redis.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6379\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // Store the list [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] in the key \u0026#34;fruits\u0026#34; _, err = conn.Do(\u0026#34;RPUSH\u0026#34;, \u0026#34;fruits\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) if err != nil { log.Fatal(err) } // Retrieve the list from the key \u0026#34;fruits\u0026#34; values, err := redis.Strings(conn.Do(\u0026#34;LRANGE\u0026#34;, \u0026#34;fruits\u0026#34;, 0, -1)) if err != nil { log.Fatal(err) } // Print the list fmt.Println(values) } This will store the list [\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;, \u0026ldquo;cherry\u0026rdquo;] in the key \u0026ldquo;fruits\u0026rdquo; and retrieve the list from the key \u0026ldquo;fruits\u0026rdquo;, printing [\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;, \u0026ldquo;cherry\u0026rdquo;].\nTo store and retrieve a list using the radix library, you can use the Do function and the radix.Strings function:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mediocregopher/radix/v3\u0026#34; ) func main() { // Connect to the Redis server conn, err := radix.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6379\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // Store the list [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] in the key \u0026#34;fruits\u0026#34; err = conn.Do(radix.FlatCmd(nil, \u0026#34;RPUSH\u0026#34;, \u0026#34;fruits\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;)) if err != nil { log.Fatal(err) } // Retrieve the list from the key \u0026#34;fruits\u0026#34; var values []string err = conn.Do(radix.Cmd(\u0026amp;values, \u0026#34;LRANGE\u0026#34;, \u0026#34;fruits\u0026#34;, 0, -1)) if err != nil { log.Fatal(err) } // Print the list fmt.Println(values) } This will also store the list [\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;, \u0026ldquo;cherry\u0026rdquo;] in the key \u0026ldquo;fruits\u0026rdquo; and retrieve the list from the key \u0026ldquo;fruits\u0026rdquo;, printing [\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;, \u0026ldquo;cherry\u0026rdquo;].\nSets To store and retrieve a set using the redis library, you can use the Do function and the redis.Strings function:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/gomodule/redigo/redis\u0026#34; ) func main() { // Connect to the Redis server conn, err := redis.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6379\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // Store the set {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} in the key \u0026#34;fruits\u0026#34; _, err = conn.Do(\u0026#34;SADD\u0026#34;, \u0026#34;fruits\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) if err != nil { log.Fatal(err) } // Retrieve the set from the key \u0026#34;fruits\u0026#34; values, err := redis.Strings(conn.Do(\u0026#34;SMEMBERS\u0026#34;, \u0026#34;fruits\u0026#34;)) if err != nil { log.Fatal(err) } // Print the set fmt.Println(values) } This will store the set {\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;, \u0026ldquo;cherry\u0026rdquo;} in the key \u0026ldquo;fruits\u0026rdquo; and retrieve the set from the key \u0026ldquo;fruits\u0026rdquo;, printing {\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;, \u0026ldquo;cherry\u0026rdquo;}.\nTo store and retrieve a set using the radix library, you can use the Do function and the radix.Strings function:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mediocregopher/radix/v3\u0026#34; ) func main() { // Connect to the Redis server conn, err := radix.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6379\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // Store the set {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} in the key \u0026#34;fruits\u0026#34; err = conn.Do(radix.FlatCmd(nil, \u0026#34;SADD\u0026#34;, \u0026#34;fruits\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;)) if err != nil { log.Fatal(err) } // Retrieve the set from the key \u0026#34;fruits\u0026#34; var values []string err = conn.Do(radix.Cmd(\u0026amp;values, \u0026#34;SMEMBERS\u0026#34;, \u0026#34;fruits\u0026#34;)) if err != nil { log.Fatal(err) } // Print the set fmt.Println(values) } This will also store the set {\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;, \u0026ldquo;cherry\u0026rdquo;} in the key \u0026ldquo;fruits\u0026rdquo; and retrieve the set from the key \u0026ldquo;fruits\u0026rdquo;, printing {\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;, \u0026ldquo;cherry\u0026rdquo;}.\nHashes To store and retrieve a hash using the redis library, you can use the Do function and the redis.Strings function:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/gomodule/redigo/redis\u0026#34; ) func main() { // Connect to the Redis server conn, err := redis.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6379\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // Store the hash {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;30\u0026#34;} in the key \u0026#34;person\u0026#34; _, err = conn.Do(\u0026#34;HMSET\u0026#34;, \u0026#34;person\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;30\u0026#34;) if err != nil { log.Fatal(err) } // Retrieve the hash from the key \u0026#34;person\u0026#34; values, err := redis.Strings(conn.Do(\u0026#34;HGETALL\u0026#34;, \u0026#34;person\u0026#34;)) if err != nil { log.Fatal(err) } // Print the hash fmt.Println(values) } This will store the hash {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;Alice\u0026rdquo;, \u0026ldquo;age\u0026rdquo;: \u0026ldquo;30\u0026rdquo;} in the key \u0026ldquo;person\u0026rdquo; and retrieve the hash from the key \u0026ldquo;person\u0026rdquo;, printing {\u0026ldquo;name\u0026rdquo;, \u0026ldquo;Alice\u0026rdquo;, \u0026ldquo;age\u0026rdquo;, \u0026ldquo;30\u0026rdquo;}.\nTo store and retrieve a hash using the radix library, you can use the Do function and the radix.Map function:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mediocregopher/radix/v3\u0026#34; ) func main() { // Connect to the Redis server conn, err := radix.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6379\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // Store the hash {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;30\u0026#34;} in the key \u0026#34;person\u0026#34; err = conn.Do(radix.FlatCmd(nil, \u0026#34;HMSET\u0026#34;, \u0026#34;person\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;30\u0026#34;)) if err != nil { log.Fatal(err) } // Retrieve the hash from the key \u0026#34;person\u0026#34; var values map[string]string err = conn.Do(radix.Cmd(\u0026amp;values, \u0026#34;HGETALL\u0026#34;, \u0026#34;person\u0026#34;)) if err != nil { log.Fatal(err) } // Print the hash fmt.Println(values) } Conclusion In this article, we have learned how to use the redis and radix libraries to connect to a Redis server and store and retrieve various data types in Go. Redis is a powerful and fast in-memory data store that can be used for a wide range of applications, and the redis and radix libraries make it easy to use Redis in Go.\n","permalink":"https://manuelfedele.github.io/posts/use-redis-with-golang/","summary":"Using Golang and Redis Redis is an in-memory data structure store that can be used as a database, cache, and message broker. It is known for its speed, simplicity, and flexibility. In this article, we will discuss how to use Redis with Golang, a popular programming language known for its simplicity, performance, and concurrency support.\nBefore we dive into the details of using Redis with Golang, let\u0026rsquo;s first understand the requirements of the application.","title":"Use Redis With Golang"},{"content":"Golang, also known as Go, is a popular programming language known for its simplicity, performance, and concurrency support. Fyne is an open-source cross-platform UI toolkit written in Go, which makes it an excellent choice for building desktop applications. In this article, we will discuss how to build a desktop application for stock market data using Golang and Fyne.\nBefore we dive into the details of building the application, let\u0026rsquo;s first understand the requirements of the application.\nRequirements The application should be able to fetch real-time stock market data from a reliable source. The user should be able to search for a specific stock by its ticker symbol. The application should display the following data for a selected stock: Current price Price change (in percentage and absolute terms) 52-week high and low Market capitalization Volume P/E ratio The application should also display a chart showing the price history of the selected stock. The application should be able to run on Windows, Mac, and Linux. Fetching Stock Market Data There are several APIs available that provide real-time stock market data. Some popular ones include Yahoo Finance, Alpha Vantage, and IEX Cloud. In this tutorial, we will use the IEX Cloud API, which provides a wide range of financial data, including stock market data.\nTo use the IEX Cloud API, you will need to sign up for an account and obtain an API key. The API key is used to authenticate your requests to the API.\nOnce you have an API key, you can use the following Go libraries to fetch the stock market data:\niexcloud-go: A Go client library for the IEX Cloud API. go-iex: A Go wrapper for the IEX Cloud API. Both libraries provide functions to fetch various types of data, including real-time stock quotes, historical prices, and company information. For example, the following code snippet fetches the real-time quote for a stock with the ticker symbol \u0026ldquo;AAPL\u0026rdquo; using the iexcloud-go library:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/santegoeds/iexcloud-go\u0026#34; ) func main() { // Set the API key iexcloud.SetAPIKey(\u0026#34;YOUR_API_KEY\u0026#34;) // Fetch the real-time quote for the stock \u0026#34;AAPL\u0026#34; quote, err := iexcloud.Quote(\u0026#34;AAPL\u0026#34;) if err != nil { log.Fatal(err) } // Print the quote fmt.Printf(\u0026#34;%+v\\n\u0026#34;, quote) } This will print the real-time quote for the stock \u0026ldquo;AAPL\u0026rdquo;, including the current price, price change, and volume.\nBuilding the User Interface Now that we have the ability to fetch the stock market data, let\u0026rsquo;s build the user interface for the application using Fyne. Fyne provides a wide range of UI elements, such as buttons, labels, text boxes, and tables, which can be used to build the layout and behavior of the application.\nHere is a rough outline of the steps involved in building the user interface:\nCreate a Go function to initialize the UI elements and layout of the application. This function will create the main window of the application and add the necessary UI elements, such as a search bar, stock data display, and chart.\nUse Fyne\u0026rsquo;s NewContainer function to create a container for the UI elements and specify the layout using Fyne\u0026rsquo;s layout management functions, such as NewHBox and NewVBox.\nFyne\u0026rsquo;s NewTextField and NewButton functions to create a search bar and bind the search functionality to the button\u0026rsquo;s OnTapped event.\nFyne\u0026rsquo;s NewLabel and NewTable functions to create a table for displaying the stock data. You can bind the data fetched from the IEX Cloud API to the table using Fyne\u0026rsquo;s SetCell function.\nFyne\u0026rsquo;s NewCanvas function to create a canvas for rendering the chart. You can use a JavaScript charting library such as Highcharts or D3.js to render the chart on the canvas.\nFyne\u0026rsquo;s Run function to launch the application and display the main window.\nPackaging the Application Once you have completed the development of the application, you can use the fyne-packager tool to package the application for distribution on Windows, Mac, and Linux. The fyne-packager tool will create a self-contained executable for each platform, which can be easily installed and run on any system.\nConclusion In this tutorial, we have discussed how to build a desktop application for stock market data using Golang and Fyne. We have seen how to fetch real-time stock market data from the IEX Cloud API and how to build the user interface using Fyne\u0026rsquo;s UI elements and layout management functions. With these tools and techniques, you can create a powerful and efficient application for tracking and analyzing stock market data.\n","permalink":"https://manuelfedele.github.io/posts/create-desktop-application-stock-market-data-golang/","summary":"Golang, also known as Go, is a popular programming language known for its simplicity, performance, and concurrency support. Fyne is an open-source cross-platform UI toolkit written in Go, which makes it an excellent choice for building desktop applications. In this article, we will discuss how to build a desktop application for stock market data using Golang and Fyne.\nBefore we dive into the details of building the application, let\u0026rsquo;s first understand the requirements of the application.","title":"Create Desktop Application to fetch Stock Market Data  with Golang"},{"content":"In PostgreSQL, the json data type can be used to store JSON data. You can use the -\u0026gt; operator to access elements of a JSON object, and the -\u0026raquo; operator to access values of a JSON object as text.\nFor example, consider the following table with a JSON field called data:\nCREATE TABLE documents ( id serial PRIMARY KEY, data json ); To insert a JSON object into the data field, you can use the json_build_object function:\nINSERT INTO documents (data) VALUES (json_build_object(\u0026#39;key1\u0026#39;, \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;, \u0026#39;value2\u0026#39;)); To query the values of a JSON object, you can use the -\u0026gt; operator:\nSELECT data-\u0026gt;\u0026#39;key1\u0026#39; FROM documents; This will return the value of the key1 field in the JSON object.\nYou can also use the -\u0026raquo; operator to access values as text:\nSELECT data-\u0026gt;\u0026gt;\u0026#39;key1\u0026#39; FROM documents; This will return the value of the key1 field as text.\nYou can also use the jsonb_each function to iterate over the key/value pairs of a JSON object:\nSELECT key, value FROM jsonb_each(data) WHERE key=\u0026#39;key1\u0026#39;; This will return a row for each key/value pair where the key is \u0026lsquo;key1\u0026rsquo;.\nYou can find more information about working with JSON data in PostgreSQL in the PostgreSQL documentation.\n","permalink":"https://manuelfedele.github.io/posts/work-with-json-postgresql/","summary":"In PostgreSQL, the json data type can be used to store JSON data. You can use the -\u0026gt; operator to access elements of a JSON object, and the -\u0026raquo; operator to access values of a JSON object as text.\nFor example, consider the following table with a JSON field called data:\nCREATE TABLE documents ( id serial PRIMARY KEY, data json ); To insert a JSON object into the data field, you can use the json_build_object function:","title":"Work with Json field on Postgresql"},{"content":"To create a web server in Go, you can use the http package provided by the standard library. This package includes the http.Server type, which represents an HTTP server, and the http.ListenAndServe() function, which listens for incoming HTTP requests on a specified port and serves responses to those requests.\nHere is an example of how you might create a simple web server in Go:\n// Import the http package import \u0026#34;net/http\u0026#34; // Define a function that will be called to handle incoming HTTP requests func handler(w http.ResponseWriter, r *http.Request) { // Write a response message to the client fmt.Fprintf(w, \u0026#34;Hello, World!\u0026#34;) } func main() { // Set up a route that will call the handler function for any requests to the root URL http.HandleFunc(\u0026#34;/\u0026#34;, handler) // Start the web server and listen for incoming requests on port 8080 http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } In this example, the handler() function is defined to handle incoming HTTP requests. This function receives a http.ResponseWriter and a *http.Request as arguments, which are used to write the response message and access information about the incoming request, respectively. The main() function sets up a route that will call the handler() function for any requests to the root URL (\u0026quot;/\u0026quot;) and then starts the web server using the http.ListenAndServe() function. This web server will listen for incoming requests on port 8080 and serve responses using the handler() function.\nThis is a very basic example of how to create a web server in Go. You can customize the handler() function and add additional routes to handle different URL paths and HTTP methods as needed. You can also configure the http.Server object to customize the behavior of the web server, such as setting timeouts or enabling TLS.\nMore often, if you are building microservices, you probably want to handle JSON input/output.\nTo handle JSON input and output in a web server in Go, you can use the encoding/json package to encode and decode JSON data. This package provides the json.Marshal() and json.Unmarshal() functions, which can be used to convert between JSON data and Go data types.\nHere is an example of how you might handle JSON input and output in a web server in Go:\n// Import the encoding/json and net/http packages import ( \u0026#34;encoding/json\u0026#34; \u0026#34;net/http\u0026#34; ) // Define a struct that will be used to hold the JSON data type Message struct { Text string `json:\u0026#34;text\u0026#34;` } // Define a function that will be called to handle incoming HTTP requests func handler(w http.ResponseWriter, r *http.Request) { // Check the HTTP method of the request switch r.Method { case \u0026#34;POST\u0026#34;: // If the request is a POST request, read the JSON data from the request body var m Message if err := json.NewDecoder(r.Body).Decode(\u0026amp;m); err != nil { // If there is an error decoding the JSON data, respond with an error message http.Error(w, err.Error(), http.StatusBadRequest) return } // Do something with the JSON data (in this case, just print it to the console) fmt.Println(m.Text) // Respond with a JSON message json.NewEncoder(w).Encode(\u0026amp;Message{Text: \u0026#34;Hello from the server!\u0026#34;}) default: // If the request is not a POST request, respond with an error message http.Error(w, \u0026#34;Invalid request method\u0026#34;, http.StatusMethodNotAllowed) } } func main() { // Set up a route that will call the handler function for any requests to the root URL http.HandleFunc(\u0026#34;/\u0026#34;, handler) // Start the web server and listen for incoming requests on port 8080 http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } In this example, the handler() function is defined to handle incoming HTTP requests. This function checks the HTTP method of the request and, if it is a POST request, it uses the json.NewDecoder() function to read the JSON data from the request body and decode it into a Message struct. The Message struct includes a json:\u0026ldquo;text\u0026rdquo; tag, which specifies the field name to use in the JSON data. This tag is used by the json package to map the JSON data to the corresponding fields in the Message struct.\nIf the request is a POST request, the handler() function does something with the JSON data (in this case, just printing it to the console) and then responds with a JSON message using the json.NewEncoder() function. This function encodes the Message struct as JSON and writes it to the http.ResponseWriter object, which sends the response to the client.\nThis is a simple example of how to handle JSON input and output in a web server in Go. You can customize the handling of the JSON data and the response message as needed, depending on the requirements of your application.\n","permalink":"https://manuelfedele.github.io/posts/how-to-create-a-webserver-in-golang/","summary":"To create a web server in Go, you can use the http package provided by the standard library. This package includes the http.Server type, which represents an HTTP server, and the http.ListenAndServe() function, which listens for incoming HTTP requests on a specified port and serves responses to those requests.\nHere is an example of how you might create a simple web server in Go:\n// Import the http package import \u0026#34;net/http\u0026#34; // Define a function that will be called to handle incoming HTTP requests func handler(w http.","title":"How to Create a Webserver in Golang"},{"content":"In Go, an interface is a type that defines a set of methods that a struct must implement in order to implement the interface. An interface defines the behavior or capabilities of a struct without specifying the implementation details. This allows different structs to implement the same interface in different ways, promoting loose coupling and flexibility in your code.\nHere is an example of an interface in Go:\n// Define an interface named Animal type Animal interface { // Define a method named Speak that takes no arguments and returns a string Speak() string } In this example, the Animal interface defines a single method named Speak(), which takes no arguments and returns a string. Any struct that wants to implement the Animal interface must implement this Speak() method.\nHere is an example of how a struct can implement the Animal interface:\n// Define a struct named Dog type Dog struct{} // Implement the Speak method for the Dog struct func (d *Dog) Speak() string { return \u0026#34;Woof!\u0026#34; } In this example, the Dog struct implements the Speak() method required by the Animal interface. This allows the Dog struct to be used wherever the Animal interface is expected.\nInterfaces in Go are similar to abstract classes in other programming languages. They define a common contract that structs must adhere to in order to implement the interface, but they do not provide any implementation details. This allows multiple structs to implement the same interface in different ways, providing flexibility and reuse in your code.\n","permalink":"https://manuelfedele.github.io/posts/how-to-use-interfaces-in-golang/","summary":"In Go, an interface is a type that defines a set of methods that a struct must implement in order to implement the interface. An interface defines the behavior or capabilities of a struct without specifying the implementation details. This allows different structs to implement the same interface in different ways, promoting loose coupling and flexibility in your code.\nHere is an example of an interface in Go:\n// Define an interface named Animal type Animal interface { // Define a method named Speak that takes no arguments and returns a string Speak() string } In this example, the Animal interface defines a single method named Speak(), which takes no arguments and returns a string.","title":"How to Use Interfaces in Golang"},{"content":"To implement the factory design pattern in Go, you can create a factory function that returns an object that implements a common interface. This function can take parameters to specify the type of object to be created. Here is an example of how you might implement the factory design pattern in Go:\n// Define an interface that the factory will create objects for type Animal interface { Speak() string } // Define a factory function that returns an object that implements the Animal interface func NewAnimal(animalType string) Animal { switch animalType { case \u0026#34;dog\u0026#34;: return \u0026amp;Dog{} case \u0026#34;cat\u0026#34;: return \u0026amp;Cat{} default: return nil } } // Define a struct for a dog that implements the Animal interface type Dog struct{} func (d *Dog) Speak() string { return \u0026#34;Woof!\u0026#34; } // Define a struct for a cat that implements the Animal interface type Cat struct{} func (c *Cat) Speak() string { return \u0026#34;Meow!\u0026#34; } // Use the factory function to create new Animal objects dog := NewAnimal(\u0026#34;dog\u0026#34;) cat := NewAnimal(\u0026#34;cat\u0026#34;) fmt.Println(dog.Speak()) // \u0026#34;Woof!\u0026#34; fmt.Println(cat.Speak()) // \u0026#34;Meow!\u0026#34; In this example, the NewAnimal() function is the factory function that returns objects of different types (Dog or Cat in this case) that implement the Animal interface. The factory function takes a string parameter that specifies the type of object to be created. The Dog and Cat structs both implement the Animal interface by implementing the Speak() method. The NewAnimal() function uses a switch statement to determine which type of object to return based on the animalType parameter.\nThis implementation of the factory design pattern allows you to easily create new objects of different types without having to specify the exact type of each object. It also promotes loose coupling between the different types of objects, as they only need to implement a common interface.\n","permalink":"https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/","summary":"To implement the factory design pattern in Go, you can create a factory function that returns an object that implements a common interface. This function can take parameters to specify the type of object to be created. Here is an example of how you might implement the factory design pattern in Go:\n// Define an interface that the factory will create objects for type Animal interface { Speak() string } // Define a factory function that returns an object that implements the Animal interface func NewAnimal(animalType string) Animal { switch animalType { case \u0026#34;dog\u0026#34;: return \u0026amp;Dog{} case \u0026#34;cat\u0026#34;: return \u0026amp;Cat{} default: return nil } } // Define a struct for a dog that implements the Animal interface type Dog struct{} func (d *Dog) Speak() string { return \u0026#34;Woof!","title":"Implement Factory Design Pattern in Golang"},{"content":"Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I\u0026rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won\u0026rsquo;t cover using CSS to style your theme.\nWe\u0026rsquo;ll start with creating a new site with a very basic template. Then we\u0026rsquo;ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the \u0026ldquo;$\u0026rdquo; prompt. The output will follow. Lines that start with \u0026ldquo;#\u0026rdquo; are comments that I\u0026rsquo;ve added to explain a point. When I show updates to a file, the \u0026ldquo;:wq\u0026rdquo; on the last line means to save the file.\nHere\u0026rsquo;s an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ## this is a comment $ echo this is a command this is a command ## edit the file $ vi foo.md +++ date = \u0026#34;2014-09-28\u0026#34; title = \u0026#34;creating a new theme\u0026#34; +++ bah and humbug :wq ## show it $ cat foo.md +++ date = \u0026#34;2014-09-28\u0026#34; title = \u0026#34;creating a new theme\u0026#34; +++ bah and humbug $ Some Definitions There are a few concepts that you need to understand before creating a theme.\nSkins Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.\nYou have two ways to create a skin. The simplest way is to create it in the layouts/ directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the layouts/ directory so it will always find the skin.\nYour second choice is to create it in a sub-directory of the themes/ directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?\nThe difference between creating a skin in layouts/ and creating it in themes/ is very subtle. A skin in layouts/ can’t be customized without updating the templates and static files that it is built from. A skin created in themes/, on the other hand, can be and that makes it easier for other people to use it.\nThe rest of this tutorial will call a skin created in the themes/ directory a theme.\nNote that you can use this tutorial to create a skin in the layouts/ directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.\nThe Home Page The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.\nSite Configuration File When Hugo runs, it looks for a configuration file that contains settings that override default values for the entire site. The file can use TOML, YAML, or JSON. I prefer to use TOML for my configuration files. If you prefer to use JSON or YAML, you’ll need to translate my examples. You’ll also need to change the name of the file since Hugo uses the extension to determine how to process it.\nHugo translates Markdown files into HTML. By default, Hugo expects to find Markdown files in your content/ directory and template files in your themes/ directory. It will create HTML files in your public/ directory. You can change this by specifying alternate locations in the configuration file.\nContent Content is stored in text files that contain two sections. The first section is the “front matter,” which is the meta-information on the content. The second section contains Markdown that will be converted to HTML.\nFront Matter The front matter is information about the content. Like the configuration file, it can be written in TOML, YAML, or JSON. Unlike the configuration file, Hugo doesn’t use the file’s extension to know the format. It looks for markers to signal the type. TOML is surrounded by “+++”, YAML by “---”, and JSON is enclosed in curly braces. I prefer to use TOML, so you’ll need to translate my examples if you prefer YAML or JSON.\nThe information in the front matter is passed into the template before the content is rendered into HTML.\nMarkdown Content is written in Markdown which makes it easier to create the content. Hugo runs the content through a Markdown engine to create the HTML which will be written to the output file.\nTemplate Files Hugo uses template files to render content into HTML. Template files are a bridge between the content and presentation. Rules in the template define what content is published, where it\u0026rsquo;s published to, and how it will rendered to the HTML file. The template guides the presentation by specifying the style to use.\nThere are three types of templates: single, list, and partial. Each type takes a bit of content as input and transforms it based on the commands in the template.\nHugo uses its knowledge of the content to find the template file used to render the content. If it can’t find a template that is an exact match for the content, it will shift up a level and search from there. It will continue to do so until it finds a matching template or runs out of templates to try. If it can’t find a template, it will use the default template for the site.\nPlease note that you can use the front matter to influence Hugo’s choice of templates.\nSingle Template A single template is used to render a single piece of content. For example, an article or post would be a single piece of content and use a single template.\nList Template A list template renders a group of related content. That could be a summary of recent postings or all articles in a category. List templates can contain multiple groups.\nThe homepage template is a special type of list template. Hugo assumes that the home page of your site will act as the portal for the rest of the content in the site.\nPartial Template A partial template is a template that can be included in other templates. Partial templates must be called using the “partial” template command. They are very handy for rolling up common behavior. For example, your site may have a banner that all pages use. Instead of copying the text of the banner into every single and list template, you could create a partial with the banner in it. That way if you decide to change the banner, you only have to change the partial template.\nCreate a New Site Let\u0026rsquo;s use Hugo to create a new web site. I\u0026rsquo;m a Mac user, so I\u0026rsquo;ll create mine in my home directory, in the Sites folder. If you\u0026rsquo;re using Linux, you might have to create the folder first.\nThe \u0026ldquo;new site\u0026rdquo; command will create a skeleton of a site. It will give you the basic directory structure and a useable configuration file.\n1 2 3 4 5 6 7 8 9 10 11 12 $ hugo new site ~/Sites/zafta $ cd ~/Sites/zafta $ ls -l total 8 drwxr-xr-x 7 quoha staff 238 Sep 29 16:49 . drwxr-xr-x 3 quoha staff 102 Sep 29 16:49 .. drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static $ Take a look in the content/ directory to confirm that it is empty.\nThe other directories (archetypes/, layouts/, and static/) are used when customizing a theme. That\u0026rsquo;s a topic for a different tutorial, so please ignore them for now.\nGenerate the HTML For the New Site Running the hugo command with no options will read all the available content and generate the HTML files. It will also copy all static files (that\u0026rsquo;s everything that\u0026rsquo;s not content). Since we have an empty site, it won\u0026rsquo;t do much, but it will do it very quickly.\n1 2 3 4 5 6 7 8 9 10 11 12 $ hugo --verbose INFO: 2014/09/29 Using config file: config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $ The \u0026ldquo;--verbose\u0026rdquo; flag gives extra information that will be helpful when we build the template. Every line of the output that starts with \u0026ldquo;INFO:\u0026rdquo; or \u0026ldquo;WARN:\u0026rdquo; is present because we used that flag. The lines that start with \u0026ldquo;WARN:\u0026rdquo; are warning messages. We\u0026rsquo;ll go over them later.\nWe can verify that the command worked by looking at the directory again.\n1 2 3 4 5 6 7 8 9 $ ls -l total 8 drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static $ See that new public/ directory? Hugo placed all generated content there. When you\u0026rsquo;re ready to publish your web site, that\u0026rsquo;s the place to start. For now, though, let\u0026rsquo;s just confirm that we have what we\u0026rsquo;d expect from a site with no content.\n1 2 3 4 5 $ ls -l public total 16 -rw-r--r-- 1 quoha staff 416 Sep 29 17:02 index.xml -rw-r--r-- 1 quoha staff 262 Sep 29 17:02 sitemap.xml $ Hugo created two XML files, which is standard, but there are no HTML files.\nTest the New Site Verify that you can run the built-in web server. It will dramatically shorten your development cycle if you do. Start it by running the \u0026ldquo;server\u0026rdquo; command. If it is successful, you will see output similar to the following:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ hugo server --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms Serving pages from /Users/quoha/Sites/zafta/public Web Server is available at http://localhost:1313 Press Ctrl+C to stop Connect to the listed URL (it\u0026rsquo;s on the line that starts with \u0026ldquo;Web Server\u0026rdquo;). If everything is working correctly, you should get a page that shows the following:\n1 2 index.xml sitemap.xml That\u0026rsquo;s a listing of your public/ directory. Hugo didn\u0026rsquo;t create a home page because our site has no content. When there\u0026rsquo;s no index.html file in a directory, the server lists the files in the directory, which is what you should see in your browser.\nLet’s go back and look at those warnings again.\n1 2 WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] That second warning is easier to explain. We haven’t created a template to be used to generate “page not found errors.” The 404 message is a topic for a separate tutorial.\nNow for the first warning. It is for the home page. You can tell because the first layout that it looked for was “index.html.” That’s only used by the home page.\nI like that the verbose flag causes Hugo to list the files that it\u0026rsquo;s searching for. For the home page, they are index.html, _default/list.html, and _default/single.html. There are some rules that we\u0026rsquo;ll cover later that explain the names and paths. For now, just remember that Hugo couldn\u0026rsquo;t find a template for the home page and it told you so.\nAt this point, you\u0026rsquo;ve got a working installation and site that we can build upon. All that’s left is to add some content and a theme to display it.\nCreate a New Theme Hugo doesn\u0026rsquo;t ship with a default theme. There are a few available (I counted a dozen when I first installed Hugo) and Hugo comes with a command to create new themes.\nWe\u0026rsquo;re going to create a new theme called \u0026ldquo;zafta.\u0026rdquo; Since the goal of this tutorial is to show you how to fill out the files to pull in your content, the theme will not contain any CSS. In other words, ugly but functional.\nAll themes have opinions on content and layout. For example, Zafta uses \u0026ldquo;post\u0026rdquo; over \u0026ldquo;blog\u0026rdquo;. Strong opinions make for simpler templates but differing opinions make it tougher to use themes. When you build a theme, consider using the terms that other themes do.\nCreate a Skeleton Use the hugo \u0026ldquo;new\u0026rdquo; command to create the skeleton of a theme. This creates the directory structure and places empty files for you to fill out.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ hugo new theme zafta $ ls -l total 8 drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static drwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes $ find themes -type f | xargs ls -l -rw-r--r-- 1 quoha staff 1081 Sep 29 17:31 themes/zafta/LICENSE.md -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/archetypes/default.md -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html -rw-r--r-- 1 quoha staff 93 Sep 29 17:31 themes/zafta/theme.toml $ The skeleton includes templates (the files ending in .html), license file, a description of your theme (the theme.toml file), and an empty archetype.\nPlease take a minute to fill out the theme.toml and LICENSE.md files. They\u0026rsquo;re optional, but if you\u0026rsquo;re going to be distributing your theme, it tells the world who to praise (or blame). It\u0026rsquo;s also nice to declare the license so that people will know how they can use the theme.\n1 2 3 4 5 6 7 8 9 10 11 $ vi themes/zafta/theme.toml author = \u0026#34;michael d henderson\u0026#34; description = \u0026#34;a minimal working template\u0026#34; license = \u0026#34;MIT\u0026#34; name = \u0026#34;zafta\u0026#34; source_repo = \u0026#34;\u0026#34; tags = [\u0026#34;tags\u0026#34;, \u0026#34;categories\u0026#34;] :wq ## also edit themes/zafta/LICENSE.md and change ## the bit that says \u0026#34;YOUR_NAME_HERE\u0026#34; Note that the the skeleton\u0026rsquo;s template files are empty. Don\u0026rsquo;t worry, we\u0026rsquo;ll be changing that shortly.\n1 2 3 4 5 6 7 $ find themes/zafta -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html $ Update the Configuration File to Use the Theme Now that we\u0026rsquo;ve got a theme to work with, it\u0026rsquo;s a good idea to add the theme name to the configuration file. This is optional, because you can always add \u0026ldquo;-t zafta\u0026rdquo; on all your commands. I like to put it the configuration file because I like shorter command lines. If you don\u0026rsquo;t put it in the configuration file or specify it on the command line, you won\u0026rsquo;t use the template that you\u0026rsquo;re expecting to.\nEdit the file to add the theme, add a title for the site, and specify that all of our content will use the TOML format.\n1 2 3 4 5 6 7 8 9 $ vi config.toml theme = \u0026#34;zafta\u0026#34; baseurl = \u0026#34;\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;zafta - totally refreshing\u0026#34; MetaDataFormat = \u0026#34;toml\u0026#34; :wq $ Generate the Site Now that we have an empty theme, let\u0026rsquo;s generate the site again.\n1 2 3 4 5 6 7 8 9 10 11 12 $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $ Did you notice that the output is different? The warning message for the home page has disappeared and we have an additional information line saying that Hugo is syncing from the theme\u0026rsquo;s directory.\nLet\u0026rsquo;s check the public/ directory to see what Hugo\u0026rsquo;s created.\n1 2 3 4 5 6 7 8 $ ls -l public total 16 drwxr-xr-x 2 quoha staff 68 Sep 29 17:56 css -rw-r--r-- 1 quoha staff 0 Sep 29 17:56 index.html -rw-r--r-- 1 quoha staff 407 Sep 29 17:56 index.xml drwxr-xr-x 2 quoha staff 68 Sep 29 17:56 js -rw-r--r-- 1 quoha staff 243 Sep 29 17:56 sitemap.xml $ Notice four things:\nHugo created a home page. This is the file public/index.html. Hugo created a css/ directory. Hugo created a js/ directory. Hugo claimed that it created 0 pages. It created a file and copied over static files, but didn\u0026rsquo;t create any pages. That\u0026rsquo;s because it considers a \u0026ldquo;page\u0026rdquo; to be a file created directly from a content file. It doesn\u0026rsquo;t count things like the index.html files that it creates automatically. The Home Page Hugo supports many different types of templates. The home page is special because it gets its own type of template and its own template file. The file, layouts/index.html, is used to generate the HTML for the home page. The Hugo documentation says that this is the only required template, but that depends. Hugo\u0026rsquo;s warning message shows that it looks for three different templates:\n1 WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] If it can\u0026rsquo;t find any of these, it completely skips creating the home page. We noticed that when we built the site without having a theme installed.\nWhen Hugo created our theme, it created an empty home page template. Now, when we build the site, Hugo finds the template and uses it to generate the HTML for the home page. Since the template file is empty, the HTML file is empty, too. If the template had any rules in it, then Hugo would have used them to generate the home page.\n1 2 3 4 $ find . -name index.html | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 20:21 ./public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 ./themes/zafta/layouts/index.html $ The Magic of Static Hugo does two things when generating the site. It uses templates to transform content into HTML and it copies static files into the site. Unlike content, static files are not transformed. They are copied exactly as they are.\nHugo assumes that your site will use both CSS and JavaScript, so it creates directories in your theme to hold them. Remember opinions? Well, Hugo\u0026rsquo;s opinion is that you\u0026rsquo;ll store your CSS in a directory named css/ and your JavaScript in a directory named js/. If you don\u0026rsquo;t like that, you can change the directory names in your theme directory or even delete them completely. Hugo\u0026rsquo;s nice enough to offer its opinion, then behave nicely if you disagree.\n1 2 3 4 5 6 7 8 9 10 $ find themes/zafta -type d | xargs ls -ld drwxr-xr-x 7 quoha staff 238 Sep 29 17:38 themes/zafta drwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes/zafta/archetypes drwxr-xr-x 5 quoha staff 170 Sep 29 17:31 themes/zafta/layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/_default drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/partials drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/static drwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/css drwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/js $ The Theme Development Cycle When you\u0026rsquo;re working on a theme, you will make changes in the theme\u0026rsquo;s directory, rebuild the site, and check your changes in the browser. Hugo makes this very easy:\nPurge the public/ directory. Run the built in web server in watch mode. Open your site in a browser. Update the theme. Glance at your browser window to see changes. Return to step 4. I’ll throw in one more opinion: never work on a theme on a live site. Always work on a copy of your site. Make changes to your theme, test them, then copy them up to your site. For added safety, use a tool like Git to keep a revision history of your content and your theme. Believe me when I say that it is too easy to lose both your mind and your changes.\nCheck the main Hugo site for information on using Git with Hugo.\nPurge the public/ Directory When generating the site, Hugo will create new files and update existing ones in the public/ directory. It will not delete files that are no longer used. For example, files that were created in the wrong directory or with the wrong title will remain. If you leave them, you might get confused by them later. I recommend cleaning out your site prior to generating it.\nNote: If you\u0026rsquo;re building on an SSD, you should ignore this. Churning on a SSD can be costly.\nHugo\u0026rsquo;s Watch Option Hugo\u0026rsquo;s \u0026ldquo;--watch\u0026rdquo; option will monitor the content/ and your theme directories for changes and rebuild the site automatically.\nLive Reload Hugo\u0026rsquo;s built in web server supports live reload. As pages are saved on the server, the browser is told to refresh the page. Usually, this happens faster than you can say, \u0026ldquo;Wow, that\u0026rsquo;s totally amazing.\u0026rdquo;\nDevelopment Commands Use the following commands as the basis for your workflow.\n1 2 3 4 5 6 7 ## purge old files. hugo will recreate the public directory. ## $ rm -rf public ## ## run hugo in watch mode ## $ hugo server --watch --verbose Here\u0026rsquo;s sample output showing Hugo detecting a change to the template for the home page. Once generated, the web browser automatically reloaded the page. I\u0026rsquo;ve said this before, it\u0026rsquo;s amazing.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $ rm -rf public $ hugo server --watch --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms Watching for changes in /Users/quoha/Sites/zafta/content Serving pages from /Users/quoha/Sites/zafta/public Web Server is available at http://localhost:1313 Press Ctrl+C to stop INFO: 2014/09/29 File System Event: [\u0026#34;/Users/quoha/Sites/zafta/themes/zafta/layouts/index.html\u0026#34;: MODIFY|ATTRIB] Change detected, rebuilding site WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 1 ms Update the Home Page Template The home page is one of a few special pages that Hugo creates automatically. As mentioned earlier, it looks for one of three files in the theme\u0026rsquo;s layout/ directory:\nindex.html _default/list.html _default/single.html We could update one of the default templates, but a good design decision is to update the most specific template available. That\u0026rsquo;s not a hard and fast rule (in fact, we\u0026rsquo;ll break it a few times in this tutorial), but it is a good generalization.\nMake a Static Home Page Right now, that page is empty because we don\u0026rsquo;t have any content and we don\u0026rsquo;t have any logic in the template. Let\u0026rsquo;s change that by adding some text to the template.\n1 2 3 4 5 6 7 8 9 10 $ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $ Build the web site and then verify the results.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 78 Sep 29 21:26 public/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/html\u0026gt; Live Reload Note: If you\u0026rsquo;re running the server with the --watch option, you\u0026rsquo;ll see different content in the file:\n1 2 3 4 5 6 7 8 9 10 $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt;document.write(\u0026#39;\u0026lt;script src=\u0026#34;http://\u0026#39; + (location.host || \u0026#39;localhost\u0026#39;).split(\u0026#39;:\u0026#39;)[0] + \u0026#39;:1313/livereload.js?mindelay=10\u0026#34;\u0026gt;\u0026lt;/\u0026#39; + \u0026#39;script\u0026gt;\u0026#39;)\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; When you use --watch, the Live Reload script is added by Hugo. Look for live reload in the documentation to see what it does and how to disable it.\nBuild a \u0026ldquo;Dynamic\u0026rdquo; Home Page \u0026ldquo;Dynamic home page?\u0026rdquo; Hugo\u0026rsquo;s a static web site generator, so this seems an odd thing to say. I mean let\u0026rsquo;s have the home page automatically reflect the content in the site every time Hugo builds it. We\u0026rsquo;ll use iteration in the template to do that.\nCreate New Posts Now that we have the home page generating static content, let\u0026rsquo;s add some content to the site. We\u0026rsquo;ll display these posts as a list on the home page and on their own page, too.\nHugo has a command to generate a skeleton post, just like it does for sites and themes.\n1 2 3 4 5 6 7 $ hugo --verbose new post/first.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/first.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/default.md ERROR: 2014/09/29 Unable to Cast \u0026lt;nil\u0026gt; to map[string]interface{} $ That wasn\u0026rsquo;t very nice, was it?\nThe \u0026ldquo;new\u0026rdquo; command uses an archetype to create the post file. Hugo created an empty default archetype file, but that causes an error when there\u0026rsquo;s a theme. For me, the workaround was to create an archetypes file specifically for the post type.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 $ vi themes/zafta/archetypes/post.md +++ Description = \u0026#34;\u0026#34; Tags = [] Categories = [] +++ :wq $ find themes/zafta/archetypes -type f | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 21:53 themes/zafta/archetypes/default.md -rw-r--r-- 1 quoha staff 51 Sep 29 21:54 themes/zafta/archetypes/post.md $ hugo --verbose new post/first.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/first.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/first.md /Users/quoha/Sites/zafta/content/post/first.md created $ hugo --verbose new post/second.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/second.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/second.md /Users/quoha/Sites/zafta/content/post/second.md created $ ls -l content/post total 16 -rw-r--r-- 1 quoha staff 104 Sep 29 21:54 first.md -rw-r--r-- 1 quoha staff 105 Sep 29 21:57 second.md $ cat content/post/first.md +++ Categories = [] Description = \u0026#34;\u0026#34; Tags = [] date = \u0026#34;2014-09-29T21:54:53-05:00\u0026#34; title = \u0026#34;first\u0026#34; +++ my first post $ cat content/post/second.md +++ Categories = [] Description = \u0026#34;\u0026#34; Tags = [] date = \u0026#34;2014-09-29T21:57:09-05:00\u0026#34; title = \u0026#34;second\u0026#34; +++ my second post $ Build the web site and then verify the results.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ The output says that it created 2 pages. Those are our new posts:\n1 2 3 4 5 6 $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 78 Sep 29 22:13 public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/second/index.html $ The new files are empty because because the templates used to generate the content are empty. The homepage doesn\u0026rsquo;t show the new content, either. We have to update the templates to add the posts.\nList and Single Templates In Hugo, we have three major kinds of templates. There\u0026rsquo;s the home page template that we updated previously. It is used only by the home page. We also have \u0026ldquo;single\u0026rdquo; templates which are used to generate output for a single content file. We also have \u0026ldquo;list\u0026rdquo; templates that are used to group multiple pieces of content before generating output.\nGenerally speaking, list templates are named \u0026ldquo;list.html\u0026rdquo; and single templates are named \u0026ldquo;single.html.\u0026rdquo;\nThere are three other types of templates: partials, content views, and terms. We will not go into much detail on these.\nAdd Content to the Homepage The home page will contain a list of posts. Let\u0026rsquo;s update its template to add the posts that we just created. The logic in the template will run every time we build the site.\n1 2 3 4 5 6 7 8 9 10 11 12 $ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; {{ range first 10 .Data.Pages }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $ Hugo uses the Go template engine. That engine scans the template files for commands which are enclosed between \u0026ldquo;{{\u0026rdquo; and \u0026ldquo;}}\u0026rdquo;. In our template, the commands are:\nrange .Title end The \u0026ldquo;range\u0026rdquo; command is an iterator. We\u0026rsquo;re going to use it to go through the first ten pages. Every HTML file that Hugo creates is treated as a page, so looping through the list of pages will look at every file that will be created.\nThe \u0026ldquo;.Title\u0026rdquo; command prints the value of the \u0026ldquo;title\u0026rdquo; variable. Hugo pulls it from the front matter in the Markdown file.\nThe \u0026ldquo;end\u0026rdquo; command signals the end of the range iterator. The engine loops back to the top of the iteration when it finds \u0026ldquo;end.\u0026rdquo; Everything between the \u0026ldquo;range\u0026rdquo; and \u0026ldquo;end\u0026rdquo; is evaluated every time the engine goes through the iteration. In this file, that would cause the title from the first ten pages to be output as heading level one.\nIt\u0026rsquo;s helpful to remember that some variables, like .Data, are created before any output files. Hugo loads every content file into the variable and then gives the template a chance to process before creating the HTML files.\nBuild the web site and then verify the results.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 $ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 94 Sep 29 22:23 public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/second/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ Congratulations, the home page shows the title of the two posts. The posts themselves are still empty, but let\u0026rsquo;s take a moment to appreciate what we\u0026rsquo;ve done. Your template now generates output dynamically. Believe it or not, by inserting the range command inside of those curly braces, you\u0026rsquo;ve learned everything you need to know to build a theme. All that\u0026rsquo;s really left is understanding which template will be used to generate each content file and becoming familiar with the commands for the template engine.\nAnd, if that were entirely true, this tutorial would be much shorter. There are a few things to know that will make creating a new template much easier. Don\u0026rsquo;t worry, though, that\u0026rsquo;s all to come.\nAdd Content to the Posts We\u0026rsquo;re working with posts, which are in the content/post/ directory. That means that their section is \u0026ldquo;post\u0026rdquo; (and if we don\u0026rsquo;t do something weird, their type is also \u0026ldquo;post\u0026rdquo;).\nHugo uses the section and type to find the template file for every piece of content. Hugo will first look for a template file that matches the section or type name. If it can\u0026rsquo;t find one, then it will look in the _default/ directory. There are some twists that we\u0026rsquo;ll cover when we get to categories and tags, but for now we can assume that Hugo will try post/single.html, then _default/single.html.\nNow that we know the search rule, let\u0026rsquo;s see what we actually have available:\n1 2 $ find themes/zafta -name single.html | xargs ls -l -rw-r--r-- 1 quoha staff 132 Sep 29 17:31 themes/zafta/layouts/_default/single.html We could create a new template, post/single.html, or change the default. Since we don\u0026rsquo;t know of any other content types, let\u0026rsquo;s start with updating the default.\nRemember, any content that we haven\u0026rsquo;t created a template for will end up using this template. That can be good or bad. Bad because I know that we\u0026rsquo;re going to be adding different types of content and we\u0026rsquo;re going to end up undoing some of the changes we\u0026rsquo;ve made. It\u0026rsquo;s good because we\u0026rsquo;ll be able to see immediate results. It\u0026rsquo;s also good to start here because we can start to build the basic layout for the site. As we add more content types, we\u0026rsquo;ll refactor this file and move logic around. Hugo makes that fairly painless, so we\u0026rsquo;ll accept the cost and proceed.\nPlease see the Hugo documentation on template rendering for all the details on determining which template to use. And, as the docs mention, if you\u0026rsquo;re building a single page application (SPA) web site, you can delete all of the other templates and work with just the default single page. That\u0026rsquo;s a refreshing amount of joy right there.\nUpdate the Template File 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ vi themes/zafta/layouts/_default/single.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $ Build the web site and verify the results.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 $ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 94 Sep 29 22:40 public/index.html -rw-r--r-- 1 quoha staff 125 Sep 29 22:40 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:40 public/post/index.html -rw-r--r-- 1 quoha staff 128 Sep 29 22:40 public/post/second/index.html $ cat public/post/first/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;first\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;my first post\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ cat public/post/second/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;second\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;my second post\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ Notice that the posts now have content. You can go to localhost:1313/post/first to verify.\nLinking to Content The posts are on the home page. Let\u0026rsquo;s add a link from there to the post. Since this is the home page, we\u0026rsquo;ll update its template.\n1 2 3 4 5 6 7 8 9 $ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; {{ range first 10 .Data.Pages }} \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Build the web site and verify the results.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 $ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 149 Sep 29 22:44 public/index.html -rw-r--r-- 1 quoha staff 125 Sep 29 22:44 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:44 public/post/index.html -rw-r--r-- 1 quoha staff 128 Sep 29 22:44 public/post/second/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;/post/second/\u0026#34;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;/post/first/\u0026#34;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ Create a Post Listing We have the posts displaying on the home page and on their own page. We also have a file public/post/index.html that is empty. Let\u0026rsquo;s make it show a list of all posts (not just the first ten).\nWe need to decide which template to update. This will be a listing, so it should be a list template. Let\u0026rsquo;s take a quick look and see which list templates are available.\n1 2 $ find themes/zafta -name list.html | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html As with the single post, we have to decide to update _default/list.html or create post/list.html. We still don\u0026rsquo;t have multiple content types, so let\u0026rsquo;s stay consistent and update the default list template.\nCreating Top Level Pages Let\u0026rsquo;s add an \u0026ldquo;about\u0026rdquo; page and display it at the top level (as opposed to a sub-level like we did with posts).\nThe default in Hugo is to use the directory structure of the content/ directory to guide the location of the generated html in the public/ directory. Let\u0026rsquo;s verify that by creating an \u0026ldquo;about\u0026rdquo; page at the top level:\n1 2 3 4 5 6 7 8 9 10 11 12 $ vi content/about.md +++ title = \u0026#34;about\u0026#34; description = \u0026#34;about this site\u0026#34; date = \u0026#34;2014-09-27\u0026#34; slug = \u0026#34;about time\u0026#34; +++ ## about us i\u0026#39;m speechless :wq Generate the web site and verify the results.\n1 2 3 4 5 6 $ find public -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-rw-r-- 1 mdhender staff 334 Sep 27 15:08 public/about-time/index.html -rw-rw-r-- 1 mdhender staff 527 Sep 27 15:08 public/index.html -rw-rw-r-- 1 mdhender staff 358 Sep 27 15:08 public/post/first-post/index.html -rw-rw-r-- 1 mdhender staff 0 Sep 27 15:08 public/post/index.html -rw-rw-r-- 1 mdhender staff 342 Sep 27 15:08 public/post/second-post/index.html Notice that the page wasn\u0026rsquo;t created at the top level. It was created in a sub-directory named \u0026lsquo;about-time/\u0026rsquo;. That name came from our slug. Hugo will use the slug to name the generated content. It\u0026rsquo;s a reasonable default, by the way, but we can learn a few things by fighting it for this file.\nOne other thing. Take a look at the home page.\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/post/theme/\u0026#34;\u0026gt;creating a new theme\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/about-time/\u0026#34;\u0026gt;about\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/post/second-post/\u0026#34;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/post/first-post/\u0026#34;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;script\u0026gt;document.write(\u0026#39;\u0026lt;script src=\u0026#34;http://\u0026#39; + (location.host || \u0026#39;localhost\u0026#39;).split(\u0026#39;:\u0026#39;)[0] + \u0026#39;:1313/livereload.js?mindelay=10\u0026#34;\u0026gt;\u0026lt;/\u0026#39; + \u0026#39;script\u0026gt;\u0026#39;)\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Notice that the \u0026ldquo;about\u0026rdquo; link is listed with the posts? That\u0026rsquo;s not desirable, so let\u0026rsquo;s change that first.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt; {{ range first 10 .Data.Pages }} {{ if eq .Type \u0026#34;post\u0026#34;}} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt; {{ range .Data.Pages }} {{ if eq .Type \u0026#34;page\u0026#34; }} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq Generate the web site and verify the results. The home page has two sections, posts and pages, and each section has the right set of headings and links in it.\nBut, that about page still renders to about-time/index.html.\n1 2 3 4 5 6 $ find public -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-rw-r-- 1 mdhender staff 334 Sep 27 15:33 public/about-time/index.html -rw-rw-r-- 1 mdhender staff 645 Sep 27 15:33 public/index.html -rw-rw-r-- 1 mdhender staff 358 Sep 27 15:33 public/post/first-post/index.html -rw-rw-r-- 1 mdhender staff 0 Sep 27 15:33 public/post/index.html -rw-rw-r-- 1 mdhender staff 342 Sep 27 15:33 public/post/second-post/index.html Knowing that hugo is using the slug to generate the file name, the simplest solution is to change the slug. Let\u0026rsquo;s do it the hard way and change the permalink in the configuration file.\n1 2 3 4 $ vi config.toml [permalinks] page = \u0026#34;/:title/\u0026#34; about = \u0026#34;/:filename/\u0026#34; Generate the web site and verify that this didn\u0026rsquo;t work. Hugo lets \u0026ldquo;slug\u0026rdquo; or \u0026ldquo;URL\u0026rdquo; override the permalinks setting in the configuration file. Go ahead and comment out the slug in content/about.md, then generate the web site to get it to be created in the right place.\nSharing Templates If you\u0026rsquo;ve been following along, you probably noticed that posts have titles in the browser and the home page doesn\u0026rsquo;t. That\u0026rsquo;s because we didn\u0026rsquo;t put the title in the home page\u0026rsquo;s template (layouts/index.html). That\u0026rsquo;s an easy thing to do, but let\u0026rsquo;s look at a different option.\nWe can put the common bits into a shared template that\u0026rsquo;s stored in the themes/zafta/layouts/partials/ directory.\nCreate the Header and Footer Partials In Hugo, a partial is a sugar-coated template. Normally a template reference has a path specified. Partials are different. Hugo searches for them along a TODO defined search path. This makes it easier for end-users to override the theme\u0026rsquo;s presentation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ vi themes/zafta/layouts/partials/header.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; :wq $ vi themes/zafta/layouts/partials/footer.html \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq Update the Home Page Template to Use the Partials The most noticeable difference between a template call and a partials call is the lack of path:\n{{ template \u0026#34;theme/partials/header.html\u0026#34; . }} versus\n{{ partial \u0026#34;header.html\u0026#34; . }} Both pass in the context.\nLet\u0026rsquo;s change the home page template to use these new partials.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ vi themes/zafta/layouts/index.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt; {{ range first 10 .Data.Pages }} {{ if eq .Type \u0026#34;post\u0026#34;}} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt; {{ range .Data.Pages }} {{ if or (eq .Type \u0026#34;page\u0026#34;) (eq .Type \u0026#34;about\u0026#34;) }} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Generate the web site and verify the results. The title on the home page is now \u0026ldquo;your title here\u0026rdquo;, which comes from the \u0026ldquo;title\u0026rdquo; variable in the config.toml file.\nUpdate the Default Single Template to Use the Partials 1 2 3 4 5 6 7 8 $ vi themes/zafta/layouts/_default/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Generate the web site and verify the results. The title on the posts and the about page should both reflect the value in the markdown file.\nAdd “Date Published” to Posts It\u0026rsquo;s common to have posts display the date that they were written or published, so let\u0026rsquo;s add that. The front matter of our posts has a variable named \u0026ldquo;date.\u0026rdquo; It\u0026rsquo;s usually the date the content was created, but let\u0026rsquo;s pretend that\u0026rsquo;s the value we want to display.\nAdd “Date Published” to the Template We\u0026rsquo;ll start by updating the template used to render the posts. The template code will look like:\n{{ .Date.Format \u0026#34;Mon, Jan 2, 2006\u0026#34; }} Posts use the default single template, so we\u0026rsquo;ll change that file.\n1 2 3 4 5 6 7 8 9 $ vi themes/zafta/layouts/_default/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;{{ .Date.Format \u0026#34;Mon, Jan 2, 2006\u0026#34; }}\u0026lt;/h2\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Generate the web site and verify the results. The posts now have the date displayed in them. There\u0026rsquo;s a problem, though. The \u0026ldquo;about\u0026rdquo; page also has the date displayed.\nAs usual, there are a couple of ways to make the date display only on posts. We could do an \u0026ldquo;if\u0026rdquo; statement like we did on the home page. Another way would be to create a separate template for posts.\nThe \u0026ldquo;if\u0026rdquo; solution works for sites that have just a couple of content types. It aligns with the principle of \u0026ldquo;code for today,\u0026rdquo; too.\nLet\u0026rsquo;s assume, though, that we\u0026rsquo;ve made our site so complex that we feel we have to create a new template type. In Hugo-speak, we\u0026rsquo;re going to create a section template.\nLet\u0026rsquo;s restore the default single template before we forget.\n1 2 3 4 5 6 7 8 9 $ mkdir themes/zafta/layouts/post $ vi themes/zafta/layouts/_default/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Now we\u0026rsquo;ll update the post\u0026rsquo;s version of the single template. If you remember Hugo\u0026rsquo;s rules, the template engine will use this version over the default.\n1 2 3 4 5 6 7 8 9 $ vi themes/zafta/layouts/post/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;{{ .Date.Format \u0026#34;Mon, Jan 2, 2006\u0026#34; }}\u0026lt;/h2\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Note that we removed the date logic from the default template and put it in the post template. Generate the web site and verify the results. Posts have dates and the about page doesn\u0026rsquo;t.\nDon\u0026rsquo;t Repeat Yourself DRY is a good design goal and Hugo does a great job supporting it. Part of the art of a good template is knowing when to add a new template and when to update an existing one. While you\u0026rsquo;re figuring that out, accept that you\u0026rsquo;ll be doing some refactoring. Hugo makes that easy and fast, so it\u0026rsquo;s okay to delay splitting up a template.\n","permalink":"https://manuelfedele.github.io/posts/create-template-hugo/","summary":"Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I\u0026rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won\u0026rsquo;t cover using CSS to style your theme.\nWe\u0026rsquo;ll start with creating a new site with a very basic template.","title":"Create a template for Hugo"},{"content":"For my last project, I used poetry to manage dependencies and package my code. Poetry comes with all the tools you might need to manage your projects in a deterministic way.\nAnyway, after running poetry init in an existing project, I tried to let poetry create a virtuale environment, by adding the first dependecy, but when I did poetry add twisted it suddenly hang out, printing:\nNo module named \u0026#39;virtualenv.seed.via_app_data\u0026#39; Why is that? Because poetry was using the wrong virtualenv instance, so to solve this:\nRemove all virtualenv istances sudo apt remove --purge python3-virtualenv virtualenv Remove unused dependencies sudo apt autoremove Install virtualenv pip3 install virtualenv Add dependencies with poetry poetry add \u0026lt;dependecy_name\u0026gt; Now it should work.\n","permalink":"https://manuelfedele.github.io/posts/poetry-no-module-seed-via-app-data/","summary":"For my last project, I used poetry to manage dependencies and package my code. Poetry comes with all the tools you might need to manage your projects in a deterministic way.\nAnyway, after running poetry init in an existing project, I tried to let poetry create a virtuale environment, by adding the first dependecy, but when I did poetry add twisted it suddenly hang out, printing:\nNo module named \u0026#39;virtualenv.seed.via_app_data\u0026#39; Why is that?","title":"Poetry No Module Seed via App Data"},{"content":"TLDR; I just unpaired the devices, then started a YouTube video on my Ubuntu machine and then repeated the steps below (pairing) while the audio was playing. At that point I’ve been able to send audio to my Echo Plus.\nYesterday, I tried to use my Amazon Echo Plus as bluetooth speaker on my media center Running Ubuntu 20.04.\nI paired the Echo Plus using Alexa app on my phone following these steps:\nOpen Alexa app on your phone and go to devices tab, then Echo \u0026amp; Alexa. Choose your Echo Plus from list and then the gear icon on top left. Under Wireless tab, choose Bluetooth Devices and then Pair new device.` Now the Echo Plus is in Pairing Mode. On Ubuntu, discover devices with Bluetooth and then pair Echo-s5u. Following these steps, paired was successful but I couldn’t send any audio to Echo Plus.\nWhy? Because the Echo was recognized as microphone instead of a speaker.\nThe only workaround I found at the moment to avoid this, is to pair the Echo Plus while you’re playing some audio on your Ubuntu machine.\nWhen you pair an Echo Plus to a device, the device and the Echo Plus need to establish a connection using the A2DP (Advanced Audio Distribution Profile) protocol. This protocol is used to transmit high-quality audio over Bluetooth.\nWhen you play audio on the machine before pairing the Echo Plus, it initiates the A2DP connection between the two devices. This allows the Echo Plus to establish a connection with the machine as an audio sink, which enables it to receive and play audio.\nIt\u0026rsquo;s possible that the Echo Plus is not able to initiate the A2DP connection on its own, so playing audio on the machine before pairing helps establish the connection. Once the connection is established, the Echo Plus should be able to play audio.\nI just unpaired the devices, then started a YouTube video on my Ubuntu machine and then repeated the steps above. A that point I’ve been able to send audio to my Echo Plus.\n","permalink":"https://manuelfedele.github.io/posts/ubuntu-echo-plus-alexa-workaround-bluetooth-speaker/","summary":"TLDR; I just unpaired the devices, then started a YouTube video on my Ubuntu machine and then repeated the steps below (pairing) while the audio was playing. At that point I’ve been able to send audio to my Echo Plus.\nYesterday, I tried to use my Amazon Echo Plus as bluetooth speaker on my media center Running Ubuntu 20.04.\nI paired the Echo Plus using Alexa app on my phone following these steps:","title":"Amazon Echo Plus as bluetooth speaker on Ubuntu 20.04"}]