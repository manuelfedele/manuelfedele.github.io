<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on Git Push and Run</title><link>https://manuelfedele.github.io/tags/python/</link><description>Recent content in Python on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© 2026 Manuel Fedele</copyright><lastBuildDate>Sun, 22 Feb 2026 09:30:00 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator</title><link>https://manuelfedele.github.io/posts/building-ai-sre-assistant-from-scratch/</link><pubDate>Sun, 22 Feb 2026 09:30:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/building-ai-sre-assistant-from-scratch/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 What if your on-call engineer never slept, had instant access to every repository and every AWS account, and could trace a production issue from DNS to database in under a minute? This post walks through every layer of the architecture — from the authentication system to the agent framework, tool registry, streaming infrastructure, and deployment.
&lt;/div>

&lt;div class="admonition relative overflow-hidden rounded-lg border-l-4 my-3 px-4 py-3 shadow-sm" data-type="note">
 &lt;div class="flex items-center gap-2 font-semibold text-inherit">
 &lt;div class="flex shrink-0 h-5 w-5 items-center justify-center text-lg">&lt;span class="relative block icon">&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">&lt;path fill="currentColor" d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z"/>&lt;/svg>
&lt;/span>&lt;/div>
 &lt;div class="grow">
 Note
 &lt;/div>
 &lt;/div>&lt;div class="admonition-content mt-3 text-base leading-relaxed text-inherit">&lt;p>This article describes an AI-powered SRE assistant built with the Strands Agents SDK, Django, React, and AWS. The agent autonomously investigates infrastructure issues by combining LLM reasoning with deep integrations into GitLab and AWS.&lt;/p></description></item><item><title>Building an AI-Powered Platform Operations Agent</title><link>https://manuelfedele.github.io/posts/building-ai-powered-platform-operations-agent/</link><pubDate>Sun, 15 Feb 2026 11:00:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/building-ai-powered-platform-operations-agent/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Platform engineering teams handle a constant stream of repetitive requests. This post walks through building an AI agent that automates common platform tasks — user provisioning, key rotation, service health checks — by giving an LLM access to internal tools through a structured tool-calling interface.
&lt;/div>

&lt;p>Platform engineering teams handle a constant stream of repetitive requests: onboarding users, managing API keys, checking service health, rotating credentials. Most of these tasks follow well-defined procedures that a human executes step by step. What if an AI agent could handle them instead?&lt;/p></description></item><item><title>Building an AI-Powered Document Processing Pipeline on AWS</title><link>https://manuelfedele.github.io/posts/building-ai-document-processing-pipeline-aws/</link><pubDate>Wed, 03 Dec 2025 16:45:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/building-ai-document-processing-pipeline-aws/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 A serverless document processing pipeline on AWS that uses LLMs to extract structured data from unstructured documents — invoices, contracts, reports — at scale. No GPU clusters required.
&lt;/div>

&lt;p>Insurance companies process millions of documents every year: police reports, medical records, invoices, repair estimates. Traditionally, human operators read each document, classify it, extract the relevant fields, and enter the data into the claims system. This is slow, expensive, and error-prone.&lt;/p></description></item><item><title>Serving Protocol Buffers from FastAPI: Binary Endpoints and gRPC Gateway</title><link>https://manuelfedele.github.io/posts/use-protobuf-with-fastapi/</link><pubDate>Wed, 04 Jan 2023 16:00:43 +0100</pubDate><guid>https://manuelfedele.github.io/posts/use-protobuf-with-fastapi/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 FastAPI is excellent for rapid API development. Protobuf is excellent for compact, typed binary payloads. You can combine them without any magic Pydantic integration &amp;ndash; just read raw bytes, parse with the generated class, and return bytes with the right Content-Type.
&lt;/div>

&lt;p>If you search for &amp;ldquo;FastAPI protobuf&amp;rdquo; you will find many posts that try to use Pydantic models as a bridge to protobuf serialization. There is no such bridge in Pydantic. The correct approach is simpler and more direct: FastAPI endpoints can accept and return raw bytes. The protobuf Python library handles the actual encoding. This post walks through a complete working implementation, content negotiation, and testing.&lt;/p></description></item><item><title>Python Async/Await in Practice: asyncio, FastAPI, and Common Pitfalls</title><link>https://manuelfedele.github.io/posts/understand-async-await-in-python/</link><pubDate>Sun, 01 Jan 2023 14:50:35 +0100</pubDate><guid>https://manuelfedele.github.io/posts/understand-async-await-in-python/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Async/await is not magic. It is cooperative multitasking for I/O-bound work, built on a single-threaded event loop. Getting it wrong does not crash your program; it silently makes it slower and harder to debug. This post covers what the event loop actually does, how to use asyncio correctly, the FastAPI async model, and the mistakes that cost teams weeks.
&lt;/div>

&lt;p>Python&amp;rsquo;s &lt;code>async&lt;/code>/&lt;code>await&lt;/code> syntax landed in Python 3.5 and became genuinely production-ready in Python 3.7 with &lt;code>asyncio.run&lt;/code>. Today it powers FastAPI, aiohttp, and most of the modern Python async ecosystem. But a large fraction of the async code I see in the wild has subtle bugs: missing &lt;code>await&lt;/code>, calls to blocking libraries inside async functions, or CPU-heavy work that brings the event loop to a halt.&lt;/p></description></item><item><title>Building Production APIs with FastAPI: Pydantic, Dependency Injection, and Deployment</title><link>https://manuelfedele.github.io/posts/create-webserver-with-fastapi-and-uvicorn/</link><pubDate>Fri, 30 Dec 2022 14:08:35 +0100</pubDate><guid>https://manuelfedele.github.io/posts/create-webserver-with-fastapi-and-uvicorn/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 FastAPI combines Python type hints with automatic OpenAPI documentation and near-Go performance. It has become the default choice for Python APIs. This post covers the patterns that matter in production: Pydantic models, dependency injection, background tasks, and multi-worker deployment.
&lt;/div>

&lt;p>FastAPI is not a thin wrapper around Starlette. The combination of Pydantic v2 for validation, &lt;code>Depends()&lt;/code> for dependency injection, and async-native request handling makes it the closest Python equivalent to a typed HTTP framework. The original version of this post had a broken handler signature and no production content. This is the rebuild.&lt;/p></description></item><item><title>Python Generators and yield: Building Memory-Efficient Pipelines</title><link>https://manuelfedele.github.io/posts/what-does-yield-keyword-do-in-python/</link><pubDate>Thu, 29 Dec 2022 10:19:25 +0100</pubDate><guid>https://manuelfedele.github.io/posts/what-does-yield-keyword-do-in-python/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 A generator is a lazy sequence. It produces values one at a time on demand instead of materializing everything into memory at once. For large datasets, streaming APIs, and data processing pipelines, generators are the correct default, not an optimization applied after the fact.
&lt;/div>

&lt;p>Python generators are one of the most practically useful features in the language, and one of the most underused by engineers who learned Python from web tutorials. This post goes beyond &amp;ldquo;use yield instead of return&amp;rdquo; and covers the full picture: the iterator protocol, memory characteristics, &lt;code>yield from&lt;/code>, generator pipelines, and real-world streaming use cases.&lt;/p></description></item><item><title>Poetry No Module Seed via App Data</title><link>https://manuelfedele.github.io/posts/poetry-no-module-seed-via-app-data/</link><pubDate>Mon, 01 Nov 2021 15:15:47 +0100</pubDate><guid>https://manuelfedele.github.io/posts/poetry-no-module-seed-via-app-data/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 For my last project, I used &lt;strong>poetry&lt;/strong> to manage dependencies and package my code. Poetry comes with all the tools you might need to manage your projects in a deterministic way.
&lt;/div>

&lt;p>For my last project, I used &lt;strong>poetry&lt;/strong> to manage dependencies and package my code.
Poetry comes with all the tools you might need to manage your projects in a deterministic way.&lt;/p>
&lt;p>Anyway, after running poetry init in an existing project, I tried to let poetry create a virtuale environment, by adding the first dependecy, but when I did poetry add twisted it suddenly hang out, printing:&lt;/p></description></item></channel></rss>