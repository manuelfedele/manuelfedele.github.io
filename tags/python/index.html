<!doctype html><html lang=en><head><title>Python :: Git Push and Run</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://manuelfedele.github.io/tags/python/><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><link rel=stylesheet href=https://manuelfedele.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://manuelfedele.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://manuelfedele.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://manuelfedele.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://manuelfedele.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://manuelfedele.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://manuelfedele.github.io/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css><link rel=stylesheet href=https://manuelfedele.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css><link rel=stylesheet href=https://manuelfedele.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://manuelfedele.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css><link rel=stylesheet href=https://manuelfedele.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://manuelfedele.github.io/style.css><link rel="shortcut icon" href=https://manuelfedele.github.io/favicon.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Python"><meta property="og:description" content><meta property="og:url" content="https://manuelfedele.github.io/tags/python/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:image" content="https://manuelfedele.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/tags/python/index.xml rel=alternate type=application/rss+xml title="Git Push and Run"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>git push && run</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></nav></header><div class=content><h1>Posts for: #Python</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/leveraging-ai-as-a-platform-engineer/>Leveraging AI as a Platform Engineer: What Actually Works</a></h1><div class=post-meta><time class=post-date>2026-03-01</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/ai/>AI</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/llm/>LLM</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/devops/>DevOps</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/automation/>automation</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/architecture/>architecture</a>&nbsp;</span><div class=post-content><p>I have spent the last year building AI into the core of my daily engineering work, not as a chat assistant, but as an active participant in systems that move real infrastructure and interact with production APIs. This post is an attempt to write down what I have learned: the patterns that work, the ones that looked good in demos but failed in practice, and the architectural decisions that turned out to matter.</p></div><div><a class="read-more button inline" href=/posts/leveraging-ai-as-a-platform-engineer/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/building-ai-sre-assistant-from-scratch/>Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator</a></h1><div class=post-meta><time class=post-date>2026-02-22</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/ai/>AI</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/django/>django</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/react/>react</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/gitlab/>GitLab</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/llm/>LLM</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/devops/>DevOps</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/sre/>SRE</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/architecture/>architecture</a>&nbsp;</span><div class=post-content><h1 id=building-an-ai-sre-assistant-from-scratch-architecture-of-an-autonomous-infrastructure-investigator>Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator</h1><p>What if your on-call engineer never slept, had instant access to every repository and every AWS account, and could trace a production issue from DNS to database in under a minute?</p><p>That&rsquo;s the question that led me to build TARS, an AI-powered SRE assistant that autonomously investigates infrastructure issues by combining LLM reasoning with deep integrations into GitLab and AWS. Named after the robot from Interstellar (because every good internal tool needs a movie reference), TARS is a full-stack application where engineers interact with an AI agent through a chat interface. The agent doesn&rsquo;t just answer questions. It investigates. It clones repos, greps code, reads CloudWatch logs, traces DNS chains, inspects ECS services, and synthesizes findings into structured reports.</p></div><div><a class="read-more button inline" href=/posts/building-ai-sre-assistant-from-scratch/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/building-ai-powered-platform-operations-agent/>Building an AI-Powered Platform Operations Agent</a></h1><div class=post-meta><time class=post-date>2026-02-15</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/ai/>AI</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/devops/>DevOps</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/automation/>automation</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/llm/>LLM</a>&nbsp;</span><div class=post-content><h1 id=building-an-ai-powered-platform-operations-agent>Building an AI-Powered Platform Operations Agent</h1><p>Platform engineering teams handle a constant stream of repetitive requests: onboarding users, managing API keys, checking service health, rotating credentials. Most of these tasks follow well-defined procedures that a human executes step by step. What if an AI agent could handle them instead?</p><p>In this post, I&rsquo;ll walk through the architecture of an AI-powered operations agent that automates common platform tasks by giving an LLM access to your internal tools through a structured tool-calling interface.</p></div><div><a class="read-more button inline" href=/posts/building-ai-powered-platform-operations-agent/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/building-ai-document-processing-pipeline-aws/>Building an AI-Powered Document Processing Pipeline on AWS</a></h1><div class=post-meta><time class=post-date>2025-12-03</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/ai/>AI</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/llm/>LLM</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/step-functions/>Step Functions</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/lambda/>Lambda</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/serverless/>serverless</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/architecture/>architecture</a>&nbsp;</span><div class=post-content><h1 id=building-an-ai-powered-document-processing-pipeline-on-aws>Building an AI-Powered Document Processing Pipeline on AWS</h1><p>Insurance companies process millions of documents every year: police reports, medical records, invoices, repair estimates. Traditionally, human operators read each document, classify it, extract the relevant fields, and enter the data into the claims system. This is slow, expensive, and error-prone.</p><p>In this post I&rsquo;ll describe the architecture of a production document processing pipeline I helped build. The system ingests claim documents, extracts text using vision-based LLMs, clusters and classifies document sections, extracts structured data, and generates vector embeddings for semantic search. All of this runs on a fully serverless AWS architecture with no idle infrastructure costs.</p></div><div><a class="read-more button inline" href=/posts/building-ai-document-processing-pipeline-aws/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/use-protobuf-with-fastapi/>Use Protobuf With Fastapi</a></h1><div class=post-meta><time class=post-date>2023-01-04</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/fastapi/>fastapi</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/protobuf/>protobuf</a>&nbsp;</span><div class=post-content><p>Protocol buffers, also known as Protobuf, are a popular data serialization format used for communication between services. They are efficient, easy to use, and language-agnostic. In this article, we will look at how to use Protobuf with FastAPI, a modern, high-performance web framework for building APIs with Python.</p><p>First, let&rsquo;s start by installing the necessary dependencies. You will need to install fastapi, google-protobuf, and grpcio. You can do this by running the following command:</p></div><div><a class="read-more button inline" href=/posts/use-protobuf-with-fastapi/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/understand-async-await-in-python/>Understand Async Await in Python</a></h1><div class=post-meta><time class=post-date>2023-01-01</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/asyncio/>asyncio</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;</span><div class=post-content><p>Async/await is a powerful programming construct that allows you to write asynchronous code in a synchronous-like style. It was introduced in Python 3.5 as part of the asyncio module and has become a popular choice for writing concurrent and parallel code in Python.</p><p>In this post, we&rsquo;ll take a look at what async/await is and how it works, as well as some of the benefits and drawbacks of using it. We&rsquo;ll also see some examples of how to use async/await in Python to write efficient and scalable code.</p></div><div><a class="read-more button inline" href=/posts/understand-async-await-in-python/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/create-webserver-with-fastapi-and-uvicorn/>Create a Webserver With Fastapi and Uvicorn</a></h1><div class=post-meta><time class=post-date>2022-12-30</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/fastapi/>fastapi</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/uvicorn/>uvicorn</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/webserver/>webserver</a>&nbsp;</span><div class=post-content><p>FastAPI is a modern, fast, web framework for building APIs with Python 3.7 and above. It is built on top of Starlette, a lightweight ASGI framework, and uses the uvicorn ASGI server.</p><p>Here is an example of how to create a web server with FastAPI and uvicorn:</p><ol><li>Install FastAPI and uvicorn using pip:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pip install fastapi uvicorn
</span></span></code></pre></div><ol start=2><li>Create a file called main.py and import FastAPI:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>fastapi</span> <span class=kn>import</span> <span class=n>FastAPI</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>FastAPI</span><span class=p>()</span>
</span></span></code></pre></div><ol start=3><li>Define a function that will be the endpoint for your API. This function should have a request parameter that specifies the HTTP request and a response parameter that specifies the HTTP response. You can use the @app.get decorator to define a function as a GET endpoint:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@app.get</span><span class=p>(</span><span class=s2>&#34;/&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>read_root</span><span class=p>(</span><span class=n>request</span><span class=p>,</span> <span class=n>response</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>response</span><span class=o>.</span><span class=n>status_code</span> <span class=o>=</span> <span class=mi>200</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;Hello&#34;</span><span class=p>:</span> <span class=s2>&#34;World&#34;</span><span class=p>}</span>
</span></span></code></pre></div><ol start=4><li>Run the web server using uvicorn:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>uvicorn</span>
</span></span><span class=line><span class=cl>    <span class=n>uvicorn</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>app</span><span class=p>,</span> <span class=n>host</span><span class=o>=</span><span class=s2>&#34;0.0.0.0&#34;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>8000</span><span class=p>)</span>
</span></span></code></pre></div><p>This will start the web server on the specified host and port (in this case, 0.0.0.0 and 8000). You can then access the endpoint at http://0.0.0.0:8000/.</p></div><div><a class="read-more button inline" href=/posts/create-webserver-with-fastapi-and-uvicorn/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/what-does-yield-keyword-do-in-python/>What Does Yield Keyword Do in Python</a></h1><div class=post-meta><time class=post-date>2022-12-29</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;</span><div class=post-content><p>The keyword &ldquo;yield&rdquo; is a important part of the Python programming language, and it can be used in a number of different ways. In this article, we&rsquo;ll take a closer look at what the yield keyword does in Python, and how it can be used to create more efficient and powerful programs.</p><p>The primary use of the yield keyword is to create a generator function. A generator function is a special type of function that produces a sequence of values, one at a time, when it is called. Unlike a regular function, which executes all of its code and returns a single value, a generator function can be paused at any point and resumed later, allowing it to produce a potentially infinite sequence of values.</p></div><div><a class="read-more button inline" href=/posts/what-does-yield-keyword-do-in-python/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/poetry-no-module-seed-via-app-data/>Poetry No Module Seed via App Data</a></h1><div class=post-meta><time class=post-date>2021-11-01</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/poetry/>poetry</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;</span><div class=post-content><p>For my last project, I used <strong>poetry</strong> to manage dependencies and package my code.
Poetry comes with all the tools you might need to manage your projects in a deterministic way.</p><p>Anyway, after running poetry init in an existing project, I tried to let poetry create a virtuale environment, by adding the first dependecy, but when I did poetry add twisted it suddenly hang out, printing:</p><pre tabindex=0><code>No module named &#39;virtualenv.seed.via_app_data&#39;
</code></pre><p>Why is that? Because <strong>poetry</strong> was using the wrong virtualenv instance, so to solve this:</p></div><div><a class="read-more button inline" href=/posts/poetry-no-module-seed-via-app-data/>[]</a></div></article><div class=pagination><div class=pagination__buttons></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>