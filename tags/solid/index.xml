<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Solid on Git Push and Run</title><link>https://manuelfedele.github.io/tags/solid/</link><description>Recent content in Solid on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Sun, 11 Dec 2022 18:57:13 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/solid/index.xml" rel="self" type="application/rss+xml"/><item><title>The Factory Pattern in Go: Dependency Inversion and Testable Services</title><link>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</link><pubDate>Sun, 11 Dec 2022 18:57:13 +0100</pubDate><guid>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 The factory pattern in Go is primarily about interface-based construction that enables dependency inversion and testing. The toy animal example is fine for learning the syntax. This post shows the version that matters in production: storage backends, notification senders, and testable services.
&lt;/div>

&lt;p>The original version of this post had two paragraphs and a &lt;code>Dog.Speak()&lt;/code> example. That covers the syntax but misses the point entirely. The factory pattern in Go is not about creating animals. It is about writing code where the calling layer does not need to know or care which concrete implementation it receives.&lt;/p></description></item></channel></rss>