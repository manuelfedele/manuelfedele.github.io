<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Authentication on Git Push and Run</title><link>https://manuelfedele.github.io/tags/authentication/</link><description>Recent content in Authentication on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Wed, 27 Nov 2024 17:18:00 +0000</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/authentication/index.xml" rel="self" type="application/rss+xml"/><item><title>JWT Authentication in Go: HS256, RS256, and Middleware Patterns</title><link>https://manuelfedele.github.io/posts/jwt-issuer-in-go/</link><pubDate>Wed, 27 Nov 2024 17:18:00 +0000</pubDate><guid>https://manuelfedele.github.io/posts/jwt-issuer-in-go/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 JWTs are not sessions. They are signed, self-contained claims that cannot be revoked without additional infrastructure. Understanding that tradeoff before you reach for JWT is more important than any implementation detail. This post covers HS256 vs RS256, correct validation middleware, token revocation with Redis, and a JWKS endpoint for service-to-service verification.
&lt;/div>

&lt;p>JWTs are widely misused. Teams reach for them by default because every tutorial shows them, not because they are the right tool for the job. Before writing any code, you need to understand what JWTs actually are and what they are not.&lt;/p></description></item></channel></rss>