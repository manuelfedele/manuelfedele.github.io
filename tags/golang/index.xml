<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on Git Push and Run</title><link>https://manuelfedele.github.io/tags/golang/</link><description>Recent content in Golang on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Fri, 14 Nov 2025 10:30:00 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Building Interactive CLI Tools in Go with Bubbletea</title><link>https://manuelfedele.github.io/posts/building-interactive-cli-tools-in-go-with-bubbletea/</link><pubDate>Fri, 14 Nov 2025 10:30:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/building-interactive-cli-tools-in-go-with-bubbletea/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Bubbletea brings the Elm architecture to the terminal, making it possible to build rich, interactive CLI tools in Go with clean state management. This post covers the fundamentals with a practical example.
&lt;/div>

&lt;p>If you&amp;rsquo;ve ever wanted to build a terminal application that feels more like a proper UI than a wall of text, the &lt;a href="https://github.com/charmbracelet" target="_blank" rel="noreferrer">charmbracelet&lt;/a> ecosystem is the way to go. I&amp;rsquo;ve been using it to build internal DevOps tools, and the developer experience is excellent. In this post, I&amp;rsquo;ll walk through building an interactive CLI tool using &lt;a href="https://github.com/charmbracelet/bubbletea" target="_blank" rel="noreferrer">Bubbletea&lt;/a> and &lt;a href="https://github.com/charmbracelet/huh" target="_blank" rel="noreferrer">Huh&lt;/a>, the same libraries behind tools like &lt;code>gum&lt;/code> and &lt;code>soft-serve&lt;/code>.&lt;/p></description></item><item><title>Building a Chess Engine - From Position Evaluation to Search Techniques</title><link>https://manuelfedele.github.io/posts/evaluate-chess-position/</link><pubDate>Wed, 27 Nov 2024 17:33:00 +0000</pubDate><guid>https://manuelfedele.github.io/posts/evaluate-chess-position/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position&amp;hellip;
&lt;/div>

&lt;p>Chess engines are fascinating pieces of software that combine various computer science concepts: position evaluation, tree search, move generation, and optimization techniques. This guide will walk you through implementing a chess engine, with a particular focus on position evaluation and search strategies.&lt;/p></description></item><item><title>JWT Authentication in Go: HS256, RS256, and Middleware Patterns</title><link>https://manuelfedele.github.io/posts/jwt-issuer-in-go/</link><pubDate>Wed, 27 Nov 2024 17:18:00 +0000</pubDate><guid>https://manuelfedele.github.io/posts/jwt-issuer-in-go/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 JWTs are not sessions. They are signed, self-contained claims that cannot be revoked without additional infrastructure. Understanding that tradeoff before you reach for JWT is more important than any implementation detail. This post covers HS256 vs RS256, correct validation middleware, token revocation with Redis, and a JWKS endpoint for service-to-service verification.
&lt;/div>

&lt;p>JWTs are widely misused. Teams reach for them by default because every tutorial shows them, not because they are the right tool for the job. Before writing any code, you need to understand what JWTs actually are and what they are not.&lt;/p></description></item><item><title>Dijkstra's Algorithm in Go: Implementation, Optimization, and Real-World Use</title><link>https://manuelfedele.github.io/posts/implementing-djikstra-algorithm-in-go/</link><pubDate>Wed, 27 Nov 2024 17:01:00 +0000</pubDate><guid>https://manuelfedele.github.io/posts/implementing-djikstra-algorithm-in-go/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Graph shortest-path problems appear constantly in platform engineering: network routing, dependency resolution, service mesh path optimization, and CI pipeline scheduling all reduce to finding the minimum-cost path through a directed weighted graph. Dijkstra&amp;rsquo;s algorithm is the workhorse for these problems when edge weights are non-negative. This post covers a correct Go implementation, the heap-based optimization that makes it practical on large graphs, path reconstruction, and a realistic dependency-resolution use case.
&lt;/div>


&lt;h2 class="relative group">Graph Representation
 &lt;div id="graph-representation" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#graph-representation" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>An adjacency list using integer node IDs is the right choice for Dijkstra in Go. String keys are convenient for small examples but add unnecessary hashing overhead on graphs with thousands of nodes. We represent weighted edges as structs and store the graph as a slice of slices (indexed by node ID).&lt;/p></description></item><item><title>Clipboard Security Monitoring in Go: Detecting and Redacting Secrets</title><link>https://manuelfedele.github.io/posts/clipboard-watch-remove-accidentally-typed-passwords/</link><pubDate>Sun, 26 Nov 2023 11:29:46 +0100</pubDate><guid>https://manuelfedele.github.io/posts/clipboard-watch-remove-accidentally-typed-passwords/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Accidentally typing a password into the wrong field and having it sit in your clipboard is a real security risk. A clipboard monitor can detect common secret patterns and redact them automatically before you paste them somewhere they should not go.
&lt;/div>

&lt;p>This post builds a production-quality clipboard watcher in Go: regex-based secret detection, thread-safe polling with context cancellation, desktop notifications on redaction, and OS-level background service setup for macOS and Linux.&lt;/p></description></item><item><title>Clean Package Design in Go: Single Responsibility and Package Cohesion</title><link>https://manuelfedele.github.io/posts/the-single-responsibility-principle/</link><pubDate>Tue, 21 Mar 2023 15:10:03 +0100</pubDate><guid>https://manuelfedele.github.io/posts/the-single-responsibility-principle/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 SRP in Go is about package boundaries and exported surfaces, not just splitting methods into files. When a package has one reason to change, you can test it in isolation, swap implementations behind an interface, and reason about its behavior without reading the rest of the codebase.
&lt;/div>

&lt;p>The Single Responsibility Principle (SRP) is often stated as &amp;ldquo;a class should have one reason to change.&amp;rdquo; In Go, there are no classes, but the principle applies with equal force to packages and to the exported types within them. Getting it wrong produces a God service: one package that knows about the database, email, HTTP, and business logic all at once. Getting it right produces a codebase where changing the email provider does not require touching the database layer.&lt;/p></description></item><item><title>Design Patterns in Go: Idiomatic Implementations</title><link>https://manuelfedele.github.io/posts/implement-desing-patterns-with-golang/</link><pubDate>Tue, 21 Feb 2023 13:16:06 +0100</pubDate><guid>https://manuelfedele.github.io/posts/implement-desing-patterns-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go approaches design patterns differently from Java or C++. Because Go uses composition instead of inheritance, and because functions are first-class values, many patterns that require elaborate class hierarchies in OOP languages collapse into a few idiomatic Go constructs. This post shows the correct, production-ready implementations and, just as importantly, tells you when not to reach for a pattern at all.
&lt;/div>

&lt;p>Design patterns are not a checklist. In Go, applying Java-style patterns wholesale is the fastest path to code that looks foreign to every Go developer who reads it. The patterns below are presented in their idiomatic Go form, which is often significantly simpler than the textbook version.&lt;/p></description></item><item><title>NATS Messaging in Go: Core, JetStream, and Production Patterns</title><link>https://manuelfedele.github.io/posts/nats-messaging-with-golang/</link><pubDate>Mon, 13 Feb 2023 18:57:15 +0100</pubDate><guid>https://manuelfedele.github.io/posts/nats-messaging-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 NATS is a single binary, sub-millisecond messaging system built for cloud-native workloads. It is not Kafka, and it is not Redis Streams. Knowing when to choose it and what it cannot do is as important as knowing how to use it. This post covers core NATS pub/sub, queue groups, request/reply, JetStream persistence, pull consumers, and authentication.
&lt;/div>

&lt;p>Kafka, NATS, Redis Streams, and RabbitMQ all describe themselves as &amp;ldquo;messaging systems.&amp;rdquo; They are not interchangeable. Kafka is optimised for high-throughput event log storage with long-term replay. Redis Streams is a good fit when you already have Redis and need a lightweight consumer group. RabbitMQ is the right choice when you need complex routing and AMQP semantics.&lt;/p></description></item><item><title>Solving Sudoku in Go: Backtracking, Constraint Caching, and Benchmarks</title><link>https://manuelfedele.github.io/posts/build-a-sudoku-solver-in-golang/</link><pubDate>Wed, 01 Feb 2023 21:09:26 +0100</pubDate><guid>https://manuelfedele.github.io/posts/build-a-sudoku-solver-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Sudoku solving is a classic constraint satisfaction problem (CSP). The same algorithmic techniques &amp;ndash; backtracking with constraint propagation &amp;ndash; appear in production systems for job scheduling, resource allocation, and configuration validation. Understanding how to implement and optimize a Sudoku solver gives you a concrete mental model for tackling these problems at scale.
&lt;/div>


&lt;h2 class="relative group">Problem Representation
 &lt;div id="problem-representation" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#problem-representation" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>A Sudoku grid is a 9x9 matrix of integers where 0 represents an empty cell. A fixed-size array is the right type: it lives on the stack, has no allocation overhead, and can be passed by value for snapshot semantics during backtracking.&lt;/p></description></item><item><title>Real-Time Communication in Go: TCP Sockets, Message Framing, and WebSockets</title><link>https://manuelfedele.github.io/posts/socket-messaging-with-golang/</link><pubDate>Sun, 29 Jan 2023 18:44:12 +0100</pubDate><guid>https://manuelfedele.github.io/posts/socket-messaging-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 TCP is a stream protocol, not a message protocol. If you read bytes into a fixed buffer, you will silently truncate messages larger than that buffer. You need framing. This post covers length-prefixed framing, a multi-client broadcast server, and WebSocket support for browser clients.
&lt;/div>

&lt;p>The first thing most tutorials about sockets in Go get wrong is the buffer. Reading into &lt;code>make([]byte, 1024)&lt;/code> is not message-oriented. A 1025-byte message gets split across two reads. A 512-byte message and a 300-byte message can arrive in one read. TCP is a stream &amp;ndash; you need to add structure on top of it.&lt;/p></description></item><item><title>Email Open Tracking with Go: Tracking Pixels, Unique URLs, and GDPR</title><link>https://manuelfedele.github.io/posts/tracking-pixel-technology-email-golang/</link><pubDate>Sun, 22 Jan 2023 19:02:19 +0100</pubDate><guid>https://manuelfedele.github.io/posts/tracking-pixel-technology-email-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 A tracking pixel is a 1x1 transparent image embedded in an HTML email. When an email client renders the image, it fires an HTTP GET request to your server &amp;ndash; logging the open event. Used correctly, tracking pixels power read receipts, delivery confirmation, and engagement analytics for transactional and marketing emails. Used carelessly, they violate GDPR and produce misleading metrics. This post covers a production-correct Go implementation with per-recipient unique URLs, an honest discussion of what the data actually measures, and the compliance obligations you cannot skip.
&lt;/div>


&lt;h2 class="relative group">How It Works
 &lt;div id="how-it-works" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#how-it-works" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>The mechanism is simple, but the details matter for accuracy and compliance.&lt;/p></description></item><item><title>Communicating with Stockfish from Go: The UCI Protocol</title><link>https://manuelfedele.github.io/posts/evaluate-chess-position-with-golang/</link><pubDate>Thu, 19 Jan 2023 21:33:41 +0100</pubDate><guid>https://manuelfedele.github.io/posts/evaluate-chess-position-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Stockfish is the world&amp;rsquo;s strongest chess engine. Communicating with it from Go via the UCI protocol takes about 30 lines. This post shows the real implementation: process spawning, the UCI handshake, FEN input, evaluation parsing, and a complete reusable Engine struct.
&lt;/div>

&lt;p>The original version of this post called non-existent methods like &lt;code>chess.NewEngine(&amp;quot;stockfish&amp;quot;)&lt;/code>, &lt;code>SetDifficulty&lt;/code>, and &lt;code>Evaluate&lt;/code> on the &lt;code>notnil/chess&lt;/code> library. That library is a chess rules engine &amp;ndash; it does not wrap Stockfish at all. Communicating with Stockfish requires the UCI protocol over stdin/stdout, which is exactly what this post covers.&lt;/p></description></item><item><title>Memoization in Go: Caching Expensive Computations Correctly</title><link>https://manuelfedele.github.io/posts/the-memoization-technique/</link><pubDate>Mon, 16 Jan 2023 21:07:26 +0100</pubDate><guid>https://manuelfedele.github.io/posts/the-memoization-technique/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Memoization is the optimization technique of caching the return value of a pure function so that repeated calls with the same inputs skip the computation entirely. It applies whenever a function is expensive, deterministic, and called multiple times with the same arguments. Done correctly in Go it requires a mutex, and in modern code a generic wrapper makes it reusable across types.
&lt;/div>

&lt;p>Memoization is often introduced with Fibonacci because the recursive explosion is easy to visualize. But the real production applications are elsewhere: permission checks that hit a database, configuration lookups over a network, or expensive cryptographic computations. This post covers the full picture from basic implementation through data race prevention, generic wrappers, and time-to-live (TTL) invalidation.&lt;/p></description></item><item><title>Algorithmic Trading with Alpaca and Go: Paper Trading and Real-Time Data</title><link>https://manuelfedele.github.io/posts/trading-with-alpaca-and-golang/</link><pubDate>Sun, 15 Jan 2023 19:24:09 +0100</pubDate><guid>https://manuelfedele.github.io/posts/trading-with-alpaca-and-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Alpaca provides commission-free, API-first trading with a paper trading environment for safe strategy testing. This post covers the actual Go SDK patterns, correct order placement, real-time data retrieval, a simple momentum strategy, and the risk management you need before going live.
&lt;/div>

&lt;p>The original version of this post called functions like &lt;code>alpaca.PlaceOrder&lt;/code>, &lt;code>alpaca.GetQuote&lt;/code>, and &lt;code>alpaca.ListTrades&lt;/code> as package-level functions. None of these exist in the current SDK. The real library uses a client struct. This post uses the actual &lt;code>github.com/alpacahq/alpaca-trade-api-go/v3/alpaca&lt;/code> package.&lt;/p></description></item><item><title>Testing in Go: From Unit Tests to Mocks and Benchmarks</title><link>https://manuelfedele.github.io/posts/unit-testing-in-golang/</link><pubDate>Mon, 09 Jan 2023 20:49:03 +0100</pubDate><guid>https://manuelfedele.github.io/posts/unit-testing-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go&amp;rsquo;s testing philosophy is stdlib-first and table-driven. You rarely need an external framework. The &lt;code>testing&lt;/code> package, combined with interfaces for dependency injection and &lt;code>httptest&lt;/code> for HTTP, covers almost everything you will encounter in production codebases.
&lt;/div>

&lt;p>A lot of Go developers coming from Python or Java reach for testify or gomock before they need to. Go&amp;rsquo;s standard library is remarkably complete for testing. This post walks through the patterns that experienced Go engineers actually use: table-driven tests with subtests, interface-based mocks, HTTP handler testing, benchmarks, and coverage analysis.&lt;/p></description></item><item><title>Video Streaming in Go: HTTP Range Requests, HLS Segments, and FFmpeg</title><link>https://manuelfedele.github.io/posts/streaming-video-with-golang/</link><pubDate>Wed, 04 Jan 2023 21:23:20 +0100</pubDate><guid>https://manuelfedele.github.io/posts/streaming-video-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Proper video streaming in HTTP is not about piping bytes. It is about range requests that let players seek, HLS segments that allow adaptive bitrate, and keeping FFmpeg as a subprocess while Go handles HTTP. Get these three things right and you have a working video server.
&lt;/div>

&lt;p>&lt;code>http.ServeFile&lt;/code> actually does handle range requests correctly for static files. The problem comes when you try to build something more sophisticated: transcoding on the fly, live streaming, or HLS segmentation. This post covers each scenario with working code, and explains what &lt;code>http.ServeFile&lt;/code> does and does not handle.&lt;/p></description></item><item><title>The Go context Package: Cancellation, Timeouts, and Propagation in Production</title><link>https://manuelfedele.github.io/posts/the-context-package/</link><pubDate>Tue, 03 Jan 2023 20:36:29 +0100</pubDate><guid>https://manuelfedele.github.io/posts/the-context-package/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 The &lt;code>context&lt;/code> package exists for one primary reason: goroutine lifecycle management. It gives you a standard, composable way to propagate cancellation signals, deadlines, and request-scoped metadata across API boundaries. Understanding how it works in production is the difference between a service that drains cleanly and one that leaks goroutines under load.
&lt;/div>

&lt;p>Every non-trivial Go service uses &lt;code>context&lt;/code>. You pass it from HTTP handlers to database queries, from gRPC interceptors to downstream API calls. But many engineers treat it as little more than a convention to satisfy function signatures. This post covers how &lt;code>context&lt;/code> actually works, where it fails silently when misused, and the patterns that matter in production.&lt;/p></description></item><item><title>Protocol Buffers in Go: Serialization, gRPC, and Performance</title><link>https://manuelfedele.github.io/posts/use-protobuf-with-golang/</link><pubDate>Tue, 27 Dec 2022 18:48:44 +0100</pubDate><guid>https://manuelfedele.github.io/posts/use-protobuf-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Protocol Buffers give you binary serialization that is roughly 40% smaller and 6x faster than JSON. That trade-off is worth it for internal microservice traffic. It is not worth it for a public REST API that humans need to read with curl.
&lt;/div>

&lt;p>Protocol Buffers (protobuf) are Google&amp;rsquo;s binary serialization format. The pitch is simple: define your data schema once in a &lt;code>.proto&lt;/code> file, generate typed code in any language, and get compact wire format for free. The catch is tooling overhead and the loss of human readability. This post walks through a complete Go setup: correct marshaling API, a gRPC service, and a benchmark comparing protobuf to JSON.&lt;/p></description></item><item><title>Building CLIs in Go with Cobra: Flags, Subcommands, and Shell Completion</title><link>https://manuelfedele.github.io/posts/create-command-line-application-with-golang/</link><pubDate>Tue, 20 Dec 2022 10:03:30 +0100</pubDate><guid>https://manuelfedele.github.io/posts/create-command-line-application-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Cobra is the de-facto standard for serious Go CLIs. kubectl, the GitHub CLI, and Docker all use it. If you are building a command-line tool with multiple subcommands, typed flags, and shell completion, this is how you do it properly.
&lt;/div>

&lt;p>Raw &lt;code>os.Args&lt;/code> parsing works for a single command with one positional argument. The moment you add a second subcommand or a &lt;code>--dry-run&lt;/code> flag, you are reinventing the wheel. Cobra handles argument parsing, flag validation, help text generation, and shell completion out of the box.&lt;/p></description></item><item><title>Redis in Go with go-redis/v9: Caching, Pub/Sub, and Production Patterns</title><link>https://manuelfedele.github.io/posts/use-redis-with-golang/</link><pubDate>Mon, 19 Dec 2022 19:32:27 +0100</pubDate><guid>https://manuelfedele.github.io/posts/use-redis-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Redis is not just a cache. It is a data structure server that speaks TCP, persists to disk, replicates across nodes, and handles pub/sub fan-out in a single binary. This post covers how to use it properly from Go with go-redis/v9: connection pools, TTL management, the cache-aside pattern, sorted sets for rate limiting, pub/sub, and pipelines.
&lt;/div>

&lt;p>Most teams reach for Redis when they need a fast key-value cache, hit it with &lt;code>SET&lt;/code>/&lt;code>GET&lt;/code>, and stop there. That misses most of what Redis can do. This post works through the data structures and operational patterns that matter in production services: proper connection pool configuration, TTL discipline, the cache-aside pattern with generics, lists as queues, sorted sets for sliding-window rate limiting, pub/sub for fan-out, and atomic pipelines.&lt;/p></description></item><item><title>Building Desktop Applications in Go with Fyne: Stock Market Dashboard</title><link>https://manuelfedele.github.io/posts/create-desktop-application-stock-market-data-golang/</link><pubDate>Mon, 19 Dec 2022 19:08:58 +0100</pubDate><guid>https://manuelfedele.github.io/posts/create-desktop-application-stock-market-data-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Fyne is Go&amp;rsquo;s best cross-platform UI toolkit. One codebase compiles to Windows, macOS, and Linux, shipping as a native binary with no runtime dependency. This post builds a real stock market dashboard, covering Fyne&amp;rsquo;s widget system, layout engine, goroutine safety rules, and distribution.
&lt;/div>


&lt;h2 class="relative group">Why Fyne
 &lt;div id="why-fyne" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#why-fyne" aria-label="Anchor">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Go desktop applications have historically been awkward. CGo-based bindings to GTK or Qt work, but the build complexity is painful. Fyne takes a different approach: it uses OpenGL for rendering, keeping the API pure Go and the resulting binary fully self-contained.&lt;/p></description></item><item><title>Building Production HTTP Services in Go</title><link>https://manuelfedele.github.io/posts/how-to-create-a-webserver-in-golang/</link><pubDate>Sun, 11 Dec 2022 19:14:21 +0100</pubDate><guid>https://manuelfedele.github.io/posts/how-to-create-a-webserver-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go&amp;rsquo;s &lt;code>net/http&lt;/code> standard library is production-ready. With Go 1.22+ enhanced routing, method and path pattern matching are built in. You do not need a framework for most services &amp;ndash; but you do need to configure timeouts, graceful shutdown, and middleware correctly from the start.
&lt;/div>

&lt;p>Most Go HTTP tutorials show &lt;code>http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)&lt;/code> and call it a day. That code will run, but it will leak goroutines under load, hang forever on slow clients, and crash non-gracefully when you deploy a new version. This post covers what a production-ready Go HTTP service actually looks like, using only the standard library for the core, with a note on when a router library pays off.&lt;/p></description></item><item><title>Go Interfaces in Practice: Polymorphism, Composition, and Testing</title><link>https://manuelfedele.github.io/posts/how-to-use-interfaces-in-golang/</link><pubDate>Sun, 11 Dec 2022 19:04:27 +0100</pubDate><guid>https://manuelfedele.github.io/posts/how-to-use-interfaces-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go interfaces are implicit. You do not declare that a type implements an interface. If a type has the right methods, it satisfies the interface. This single design decision makes Go interfaces more flexible, more composable, and more powerful for testing than explicit interface implementations in Java or C#.
&lt;/div>

&lt;p>Interfaces are the mechanism Go uses to express polymorphism, to decouple consumers from producers, and to make code testable without heavyweight frameworks. This post works through the patterns that matter in real codebases: polymorphism with slices of interfaces, the &lt;code>io.Reader&lt;/code>/&lt;code>io.Writer&lt;/code> design, interface composition, interfaces for test mocks, and the line between &lt;code>any&lt;/code> and generics.&lt;/p></description></item><item><title>The Factory Pattern in Go: Dependency Inversion and Testable Services</title><link>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</link><pubDate>Sun, 11 Dec 2022 18:57:13 +0100</pubDate><guid>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 The factory pattern in Go is primarily about interface-based construction that enables dependency inversion and testing. The toy animal example is fine for learning the syntax. This post shows the version that matters in production: storage backends, notification senders, and testable services.
&lt;/div>

&lt;p>The original version of this post had two paragraphs and a &lt;code>Dog.Speak()&lt;/code> example. That covers the syntax but misses the point entirely. The factory pattern in Go is not about creating animals. It is about writing code where the calling layer does not need to know or care which concrete implementation it receives.&lt;/p></description></item></channel></rss>