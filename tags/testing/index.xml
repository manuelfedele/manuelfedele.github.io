<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Testing on Git Push and Run</title><link>https://manuelfedele.github.io/tags/testing/</link><description>Recent content in Testing on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Mon, 09 Jan 2023 20:49:03 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/testing/index.xml" rel="self" type="application/rss+xml"/><item><title>Testing in Go: From Unit Tests to Mocks and Benchmarks</title><link>https://manuelfedele.github.io/posts/unit-testing-in-golang/</link><pubDate>Mon, 09 Jan 2023 20:49:03 +0100</pubDate><guid>https://manuelfedele.github.io/posts/unit-testing-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go&amp;rsquo;s testing philosophy is stdlib-first and table-driven. You rarely need an external framework. The &lt;code>testing&lt;/code> package, combined with interfaces for dependency injection and &lt;code>httptest&lt;/code> for HTTP, covers almost everything you will encounter in production codebases.
&lt;/div>

&lt;p>A lot of Go developers coming from Python or Java reach for testify or gomock before they need to. Go&amp;rsquo;s standard library is remarkably complete for testing. This post walks through the patterns that experienced Go engineers actually use: table-driven tests with subtests, interface-based mocks, HTTP handler testing, benchmarks, and coverage analysis.&lt;/p></description></item><item><title>The Factory Pattern in Go: Dependency Inversion and Testable Services</title><link>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</link><pubDate>Sun, 11 Dec 2022 18:57:13 +0100</pubDate><guid>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 The factory pattern in Go is primarily about interface-based construction that enables dependency inversion and testing. The toy animal example is fine for learning the syntax. This post shows the version that matters in production: storage backends, notification senders, and testable services.
&lt;/div>

&lt;p>The original version of this post had two paragraphs and a &lt;code>Dog.Speak()&lt;/code> example. That covers the syntax but misses the point entirely. The factory pattern in Go is not about creating animals. It is about writing code where the calling layer does not need to know or care which concrete implementation it receives.&lt;/p></description></item></channel></rss>