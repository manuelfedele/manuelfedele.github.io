<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Security on Git Push and Run</title><link>https://manuelfedele.github.io/tags/security/</link><description>Recent content in Security on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Sun, 01 Mar 2026 10:00:00 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/security/index.xml" rel="self" type="application/rss+xml"/><item><title>Shipping a DORA Compliance Tool from Zero to Production in One Day</title><link>https://manuelfedele.github.io/posts/shipping-a-dora-compliance-tool-from-zero-to-prod/</link><pubDate>Sun, 01 Mar 2026 10:00:00 +0100</pubDate><guid>https://manuelfedele.github.io/posts/shipping-a-dora-compliance-tool-from-zero-to-prod/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I spent a single session building a DORA-compliant Third Party Management tool from scratch, adding Microsoft Entra ID SSO, migrating the entire infrastructure from CloudFormation to Terraform, deploying to both qual and prod on ECS Fargate, and fixing a cascade of real-world deployment problems along the way. Here is an honest account of what broke and how I fixed it.
&lt;/div>

&lt;p>I built a DORA-compliant Third Party Management (TPM) tool: a Django + React application for managing ICT provider lifecycles, risk assessments, and regulatory registers. Then I wired up Microsoft Entra ID SSO, containerized it, and deployed it to AWS ECS Fargate using a Terraform pipeline, in a corporate environment full of proxies, permission boundaries, and shared infrastructure.&lt;/p></description></item><item><title>JWT Authentication in Go: HS256, RS256, and Middleware Patterns</title><link>https://manuelfedele.github.io/posts/jwt-issuer-in-go/</link><pubDate>Wed, 27 Nov 2024 17:18:00 +0000</pubDate><guid>https://manuelfedele.github.io/posts/jwt-issuer-in-go/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 JWTs are not sessions. They are signed, self-contained claims that cannot be revoked without additional infrastructure. Understanding that tradeoff before you reach for JWT is more important than any implementation detail. This post covers HS256 vs RS256, correct validation middleware, token revocation with Redis, and a JWKS endpoint for service-to-service verification.
&lt;/div>

&lt;p>JWTs are widely misused. Teams reach for them by default because every tutorial shows them, not because they are the right tool for the job. Before writing any code, you need to understand what JWTs actually are and what they are not.&lt;/p></description></item><item><title>Clipboard Security Monitoring in Go: Detecting and Redacting Secrets</title><link>https://manuelfedele.github.io/posts/clipboard-watch-remove-accidentally-typed-passwords/</link><pubDate>Sun, 26 Nov 2023 11:29:46 +0100</pubDate><guid>https://manuelfedele.github.io/posts/clipboard-watch-remove-accidentally-typed-passwords/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Accidentally typing a password into the wrong field and having it sit in your clipboard is a real security risk. A clipboard monitor can detect common secret patterns and redact them automatically before you paste them somewhere they should not go.
&lt;/div>

&lt;p>This post builds a production-quality clipboard watcher in Go: regex-based secret detection, thread-safe polling with context cancellation, desktop notifications on redaction, and OS-level background service setup for macOS and Linux.&lt;/p></description></item></channel></rss>