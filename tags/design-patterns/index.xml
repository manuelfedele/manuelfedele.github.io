<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>design patterns on Git Push and Run</title><link>https://manuelfedele.github.io/tags/design-patterns/</link><description>Recent content in design patterns on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 11 Dec 2022 18:57:13 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Implement Factory Design Pattern Golang</title><link>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</link><pubDate>Sun, 11 Dec 2022 18:57:13 +0100</pubDate><guid>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</guid><description>
To implement the factory design pattern in Go, you can create a factory function that returns an object that implements a common interface. This function can take parameters to specify the type of object to be created. Here is an example of how you might implement the factory design pattern in Go:
// Define an interface that the factory will create objects for type Animal interface { Speak() string } // Define a factory function that returns an object that implements the Animal interface func NewAnimal(animalType string) Animal { switch animalType { case &amp;#34;dog&amp;#34;: return &amp;amp;Dog{} case &amp;#34;cat&amp;#34;: return &amp;amp;Cat{} default: return nil } } // Define a struct for a dog that implements the Animal interface type Dog struct{} func (d *Dog) Speak() string { return &amp;#34;Woof!</description></item></channel></rss>