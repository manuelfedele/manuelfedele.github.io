<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>design patterns on Git Push and Run</title>
    <link>https://manuelfedele.github.io/tags/design-patterns/</link>
    <description>Recent content in design patterns on Git Push and Run</description>
    <image>
      <url>https://manuelfedele.github.io/img/card-pillow.jpg</url>
      <link>https://manuelfedele.github.io/img/card-pillow.jpg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 21 Feb 2023 13:16:06 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Implement Desing Patterns With Golang</title>
      <link>https://manuelfedele.github.io/posts/implement-desing-patterns-with-golang/</link>
      <pubDate>Tue, 21 Feb 2023 13:16:06 +0100</pubDate>
      
      <guid>https://manuelfedele.github.io/posts/implement-desing-patterns-with-golang/</guid>
      <description>Design patterns are reusable solutions to common software design problems. They are a way to structure and organize code in a way that makes it easier to understand, maintain, and extend. In this article, we&amp;rsquo;ll explore how to implement some popular design patterns in Go.
Singleton pattern The singleton pattern is a creational design pattern that ensures a class has only one instance and provides a global access point to it.</description>
    </item>
    
    <item>
      <title>How to Use Interfaces in Golang</title>
      <link>https://manuelfedele.github.io/posts/how-to-use-interfaces-in-golang/</link>
      <pubDate>Sun, 11 Dec 2022 19:04:27 +0100</pubDate>
      
      <guid>https://manuelfedele.github.io/posts/how-to-use-interfaces-in-golang/</guid>
      <description>In Go, an interface is a type that defines a set of methods that a struct must implement in order to implement the interface. An interface defines the behavior or capabilities of a struct without specifying the implementation details. This allows different structs to implement the same interface in different ways, promoting loose coupling and flexibility in your code.
Here is an example of an interface in Go:
// Define an interface named Animal type Animal interface { // Define a method named Speak that takes no arguments and returns a string Speak() string } In this example, the Animal interface defines a single method named Speak(), which takes no arguments and returns a string.</description>
    </item>
    
    <item>
      <title>Implement Factory Design Pattern in Golang</title>
      <link>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</link>
      <pubDate>Sun, 11 Dec 2022 18:57:13 +0100</pubDate>
      
      <guid>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</guid>
      <description>To implement the factory design pattern in Go, you can create a factory function that returns an object that implements a common interface. This function can take parameters to specify the type of object to be created. Here is an example of how you might implement the factory design pattern in Go:
// Define an interface that the factory will create objects for type Animal interface { Speak() string } // Define a factory function that returns an object that implements the Animal interface func NewAnimal(animalType string) Animal { switch animalType { case &amp;#34;dog&amp;#34;: return &amp;amp;Dog{} case &amp;#34;cat&amp;#34;: return &amp;amp;Cat{} default: return nil } } // Define a struct for a dog that implements the Animal interface type Dog struct{} func (d *Dog) Speak() string { return &amp;#34;Woof!</description>
    </item>
    
  </channel>
</rss>
