<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design Patterns on Git Push and Run</title><link>https://manuelfedele.github.io/tags/design-patterns/</link><description>Recent content in Design Patterns on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Tue, 21 Mar 2023 15:10:03 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Clean Package Design in Go: Single Responsibility and Package Cohesion</title><link>https://manuelfedele.github.io/posts/the-single-responsibility-principle/</link><pubDate>Tue, 21 Mar 2023 15:10:03 +0100</pubDate><guid>https://manuelfedele.github.io/posts/the-single-responsibility-principle/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 SRP in Go is about package boundaries and exported surfaces, not just splitting methods into files. When a package has one reason to change, you can test it in isolation, swap implementations behind an interface, and reason about its behavior without reading the rest of the codebase.
&lt;/div>

&lt;p>The Single Responsibility Principle (SRP) is often stated as &amp;ldquo;a class should have one reason to change.&amp;rdquo; In Go, there are no classes, but the principle applies with equal force to packages and to the exported types within them. Getting it wrong produces a God service: one package that knows about the database, email, HTTP, and business logic all at once. Getting it right produces a codebase where changing the email provider does not require touching the database layer.&lt;/p></description></item><item><title>Design Patterns in Go: Idiomatic Implementations</title><link>https://manuelfedele.github.io/posts/implement-desing-patterns-with-golang/</link><pubDate>Tue, 21 Feb 2023 13:16:06 +0100</pubDate><guid>https://manuelfedele.github.io/posts/implement-desing-patterns-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go approaches design patterns differently from Java or C++. Because Go uses composition instead of inheritance, and because functions are first-class values, many patterns that require elaborate class hierarchies in OOP languages collapse into a few idiomatic Go constructs. This post shows the correct, production-ready implementations and, just as importantly, tells you when not to reach for a pattern at all.
&lt;/div>

&lt;p>Design patterns are not a checklist. In Go, applying Java-style patterns wholesale is the fastest path to code that looks foreign to every Go developer who reads it. The patterns below are presented in their idiomatic Go form, which is often significantly simpler than the textbook version.&lt;/p></description></item><item><title>Go Interfaces in Practice: Polymorphism, Composition, and Testing</title><link>https://manuelfedele.github.io/posts/how-to-use-interfaces-in-golang/</link><pubDate>Sun, 11 Dec 2022 19:04:27 +0100</pubDate><guid>https://manuelfedele.github.io/posts/how-to-use-interfaces-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go interfaces are implicit. You do not declare that a type implements an interface. If a type has the right methods, it satisfies the interface. This single design decision makes Go interfaces more flexible, more composable, and more powerful for testing than explicit interface implementations in Java or C#.
&lt;/div>

&lt;p>Interfaces are the mechanism Go uses to express polymorphism, to decouple consumers from producers, and to make code testable without heavyweight frameworks. This post works through the patterns that matter in real codebases: polymorphism with slices of interfaces, the &lt;code>io.Reader&lt;/code>/&lt;code>io.Writer&lt;/code> design, interface composition, interfaces for test mocks, and the line between &lt;code>any&lt;/code> and generics.&lt;/p></description></item><item><title>The Factory Pattern in Go: Dependency Inversion and Testable Services</title><link>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</link><pubDate>Sun, 11 Dec 2022 18:57:13 +0100</pubDate><guid>https://manuelfedele.github.io/posts/implement-factory-design-pattern-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 The factory pattern in Go is primarily about interface-based construction that enables dependency inversion and testing. The toy animal example is fine for learning the syntax. This post shows the version that matters in production: storage backends, notification senders, and testable services.
&lt;/div>

&lt;p>The original version of this post had two paragraphs and a &lt;code>Dog.Speak()&lt;/code> example. That covers the syntax but misses the point entirely. The factory pattern in Go is not about creating animals. It is about writing code where the calling layer does not need to know or care which concrete implementation it receives.&lt;/p></description></item></channel></rss>