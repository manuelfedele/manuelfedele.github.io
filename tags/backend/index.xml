<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Backend on Git Push and Run</title><link>https://manuelfedele.github.io/tags/backend/</link><description>Recent content in Backend on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Fri, 13 Jan 2023 17:24:25 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/backend/index.xml" rel="self" type="application/rss+xml"/><item><title>Elasticsearch in Practice: Indexing, Searching, and Relevance Scoring</title><link>https://manuelfedele.github.io/posts/a-quick-overview-of-elasticsearch/</link><pubDate>Fri, 13 Jan 2023 17:24:25 +0100</pubDate><guid>https://manuelfedele.github.io/posts/a-quick-overview-of-elasticsearch/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Elasticsearch is not just a database with a search box. It is a distributed relevance engine built on inverted indexes, and understanding that distinction changes how you design schemas, queries, and aggregations.
&lt;/div>

&lt;p>I have run Elasticsearch in production for log analytics, product search, and document retrieval pipelines. The same mistakes appear every time a team treats it like a relational database. This post covers what you actually need to know: mappings, query semantics, relevance scoring, and aggregations as they really work.&lt;/p></description></item><item><title>Python Generators and yield: Building Memory-Efficient Pipelines</title><link>https://manuelfedele.github.io/posts/what-does-yield-keyword-do-in-python/</link><pubDate>Thu, 29 Dec 2022 10:19:25 +0100</pubDate><guid>https://manuelfedele.github.io/posts/what-does-yield-keyword-do-in-python/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 A generator is a lazy sequence. It produces values one at a time on demand instead of materializing everything into memory at once. For large datasets, streaming APIs, and data processing pipelines, generators are the correct default, not an optimization applied after the fact.
&lt;/div>

&lt;p>Python generators are one of the most practically useful features in the language, and one of the most underused by engineers who learned Python from web tutorials. This post goes beyond &amp;ldquo;use yield instead of return&amp;rdquo; and covers the full picture: the iterator protocol, memory characteristics, &lt;code>yield from&lt;/code>, generator pipelines, and real-world streaming use cases.&lt;/p></description></item><item><title>PostgreSQL JSONB: Flexible Schema, Indexing, and When to Use It</title><link>https://manuelfedele.github.io/posts/work-with-json-postgresql/</link><pubDate>Mon, 19 Dec 2022 18:20:30 +0100</pubDate><guid>https://manuelfedele.github.io/posts/work-with-json-postgresql/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 JSONB is not a replacement for normalized schemas. It is a tool for genuinely semi-structured data where the shape varies per row and you need to query inside it. Use it precisely, and it saves you from premature schema commits. Use it everywhere, and you have reinvented a document store on top of a relational database.
&lt;/div>

&lt;p>PostgreSQL&amp;rsquo;s JSONB type is one of the most powerful and most misused features in the database. This post covers the practical details: storage differences, operators, GIN indexes, mutation functions, and the patterns where JSONB earns its place.&lt;/p></description></item></channel></rss>