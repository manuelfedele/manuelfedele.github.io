<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jetstream on Git Push and Run</title><link>https://manuelfedele.github.io/tags/jetstream/</link><description>Recent content in Jetstream on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Mon, 13 Feb 2023 18:57:15 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/jetstream/index.xml" rel="self" type="application/rss+xml"/><item><title>NATS Messaging in Go: Core, JetStream, and Production Patterns</title><link>https://manuelfedele.github.io/posts/nats-messaging-with-golang/</link><pubDate>Mon, 13 Feb 2023 18:57:15 +0100</pubDate><guid>https://manuelfedele.github.io/posts/nats-messaging-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 NATS is a single binary, sub-millisecond messaging system built for cloud-native workloads. It is not Kafka, and it is not Redis Streams. Knowing when to choose it and what it cannot do is as important as knowing how to use it. This post covers core NATS pub/sub, queue groups, request/reply, JetStream persistence, pull consumers, and authentication.
&lt;/div>

&lt;p>Kafka, NATS, Redis Streams, and RabbitMQ all describe themselves as &amp;ldquo;messaging systems.&amp;rdquo; They are not interchangeable. Kafka is optimised for high-throughput event log storage with long-term replay. Redis Streams is a good fit when you already have Redis and need a lightweight consumer group. RabbitMQ is the right choice when you need complex routing and AMQP semantics.&lt;/p></description></item></channel></rss>