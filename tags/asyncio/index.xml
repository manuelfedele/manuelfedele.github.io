<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Asyncio on Git Push and Run</title><link>https://manuelfedele.github.io/tags/asyncio/</link><description>Recent content in Asyncio on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Sun, 01 Jan 2023 14:50:35 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/asyncio/index.xml" rel="self" type="application/rss+xml"/><item><title>Python Async/Await in Practice: asyncio, FastAPI, and Common Pitfalls</title><link>https://manuelfedele.github.io/posts/understand-async-await-in-python/</link><pubDate>Sun, 01 Jan 2023 14:50:35 +0100</pubDate><guid>https://manuelfedele.github.io/posts/understand-async-await-in-python/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Async/await is not magic. It is cooperative multitasking for I/O-bound work, built on a single-threaded event loop. Getting it wrong does not crash your program; it silently makes it slower and harder to debug. This post covers what the event loop actually does, how to use asyncio correctly, the FastAPI async model, and the mistakes that cost teams weeks.
&lt;/div>

&lt;p>Python&amp;rsquo;s &lt;code>async&lt;/code>/&lt;code>await&lt;/code> syntax landed in Python 3.5 and became genuinely production-ready in Python 3.7 with &lt;code>asyncio.run&lt;/code>. Today it powers FastAPI, aiohttp, and most of the modern Python async ecosystem. But a large fraction of the async code I see in the wild has subtle bugs: missing &lt;code>await&lt;/code>, calls to blocking libraries inside async functions, or CPU-heavy work that brings the event loop to a halt.&lt;/p></description></item></channel></rss>