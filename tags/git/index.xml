<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on Git Push and Run</title><link>https://manuelfedele.github.io/tags/git/</link><description>Recent content in Git on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Tue, 07 Mar 2023 17:14:30 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/git/index.xml" rel="self" type="application/rss+xml"/><item><title>Git Branch Management: Local, Remote, and Keeping Your Repo Clean</title><link>https://manuelfedele.github.io/posts/how-to-delete-git-branch-locally/</link><pubDate>Tue, 07 Mar 2023 17:14:30 +0100</pubDate><guid>https://manuelfedele.github.io/posts/how-to-delete-git-branch-locally/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Branch management is one of the most common sources of confusion and mistakes in team workflows. Branches pile up, remote tracking refs go stale, and people either delete the wrong thing or never clean up at all. This is the reference you&amp;rsquo;ll want to bookmark.
&lt;/div>

&lt;p>After a few months on a shared repository, the branch list starts to look like an archaeological dig. There are feature branches from tickets closed six months ago, a &lt;code>hotfix-DO-NOT-DELETE&lt;/code> that nobody dares touch, and a dozen &lt;code>origin/feature-*&lt;/code> tracking refs for branches that no longer exist on the remote. Understanding exactly how local branches, remote branches, and remote tracking refs relate to each other is the foundation of keeping this under control.&lt;/p></description></item><item><title>Undoing Changes in Git: reset, revert, restore, and When to Use Each</title><link>https://manuelfedele.github.io/posts/how-to-undo-most-recent-local-git-commit/</link><pubDate>Tue, 28 Feb 2023 17:09:02 +0100</pubDate><guid>https://manuelfedele.github.io/posts/how-to-undo-most-recent-local-git-commit/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Git has four main verbs for undoing things: restore, reset, revert, and reflog. Picking the wrong one either rewrites history that others have already pulled, or throws away work you wanted to keep. Here is the mental model for choosing correctly.
&lt;/div>

&lt;p>The &amp;ldquo;how do I undo this?&amp;rdquo; question comes up constantly, and the answer depends on one critical variable: has anyone else already pulled the commit you want to undo? If yes, rewriting history causes pain for your teammates. If no, you have more options. The map below will get you to the right command quickly, but understanding why each command works the way it does is what makes the difference in an incident at 2am.&lt;/p></description></item><item><title>git fetch vs git pull: Remote Tracking and Rebase Workflows</title><link>https://manuelfedele.github.io/posts/what-is-the-difference-between-git-pull-and-git-fetch/</link><pubDate>Sun, 08 Jan 2023 17:16:40 +0100</pubDate><guid>https://manuelfedele.github.io/posts/what-is-the-difference-between-git-pull-and-git-fetch/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 &lt;code>git fetch&lt;/code> is always safe. &lt;code>git pull&lt;/code> is fetch plus merge (or rebase), and that second step is where things go wrong. Understanding the difference changes how you collaborate on shared branches.
&lt;/div>

&lt;p>Most developers learn &lt;code>git pull&lt;/code> first and use it reflexively. It works fine in isolation, but on a team with an active shared branch it quietly adds merge commits to your history, can fail mid-operation if your working tree is dirty, and obscures what actually arrived from the remote. Knowing when to use &lt;code>fetch&lt;/code> instead gives you back control.&lt;/p></description></item></channel></rss>