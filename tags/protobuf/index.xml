<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Protobuf on Git Push and Run</title><link>https://manuelfedele.github.io/tags/protobuf/</link><description>Recent content in Protobuf on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Wed, 04 Jan 2023 16:00:43 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/protobuf/index.xml" rel="self" type="application/rss+xml"/><item><title>Serving Protocol Buffers from FastAPI: Binary Endpoints and gRPC Gateway</title><link>https://manuelfedele.github.io/posts/use-protobuf-with-fastapi/</link><pubDate>Wed, 04 Jan 2023 16:00:43 +0100</pubDate><guid>https://manuelfedele.github.io/posts/use-protobuf-with-fastapi/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 FastAPI is excellent for rapid API development. Protobuf is excellent for compact, typed binary payloads. You can combine them without any magic Pydantic integration &amp;ndash; just read raw bytes, parse with the generated class, and return bytes with the right Content-Type.
&lt;/div>

&lt;p>If you search for &amp;ldquo;FastAPI protobuf&amp;rdquo; you will find many posts that try to use Pydantic models as a bridge to protobuf serialization. There is no such bridge in Pydantic. The correct approach is simpler and more direct: FastAPI endpoints can accept and return raw bytes. The protobuf Python library handles the actual encoding. This post walks through a complete working implementation, content negotiation, and testing.&lt;/p></description></item><item><title>Protocol Buffers in Go: Serialization, gRPC, and Performance</title><link>https://manuelfedele.github.io/posts/use-protobuf-with-golang/</link><pubDate>Tue, 27 Dec 2022 18:48:44 +0100</pubDate><guid>https://manuelfedele.github.io/posts/use-protobuf-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Protocol Buffers give you binary serialization that is roughly 40% smaller and 6x faster than JSON. That trade-off is worth it for internal microservice traffic. It is not worth it for a public REST API that humans need to read with curl.
&lt;/div>

&lt;p>Protocol Buffers (protobuf) are Google&amp;rsquo;s binary serialization format. The pitch is simple: define your data schema once in a &lt;code>.proto&lt;/code> file, generate typed code in any language, and get compact wire format for free. The catch is tooling overhead and the loss of human readability. This post walks through a complete Go setup: correct marshaling API, a gRPC service, and a benchmark comparing protobuf to JSON.&lt;/p></description></item></channel></rss>