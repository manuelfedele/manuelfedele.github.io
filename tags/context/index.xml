<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Context on Git Push and Run</title><link>https://manuelfedele.github.io/tags/context/</link><description>Recent content in Context on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Tue, 03 Jan 2023 20:36:29 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/tags/context/index.xml" rel="self" type="application/rss+xml"/><item><title>The Go context Package: Cancellation, Timeouts, and Propagation in Production</title><link>https://manuelfedele.github.io/posts/the-context-package/</link><pubDate>Tue, 03 Jan 2023 20:36:29 +0100</pubDate><guid>https://manuelfedele.github.io/posts/the-context-package/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 The &lt;code>context&lt;/code> package exists for one primary reason: goroutine lifecycle management. It gives you a standard, composable way to propagate cancellation signals, deadlines, and request-scoped metadata across API boundaries. Understanding how it works in production is the difference between a service that drains cleanly and one that leaks goroutines under load.
&lt;/div>

&lt;p>Every non-trivial Go service uses &lt;code>context&lt;/code>. You pass it from HTTP handlers to database queries, from gRPC interceptors to downstream API calls. But many engineers treat it as little more than a convention to satisfy function signatures. This post covers how &lt;code>context&lt;/code> actually works, where it fails silently when misused, and the patterns that matter in production.&lt;/p></description></item></channel></rss>