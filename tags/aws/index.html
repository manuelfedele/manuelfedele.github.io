<!doctype html><html lang=en><head><title>AWS :: Git Push and Run</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://manuelfedele.github.io/tags/aws/><script async src="https://www.googletagmanager.com/gtag/js?id=G-K9P1DJX238"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K9P1DJX238")}</script><link rel=stylesheet href=https://manuelfedele.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://manuelfedele.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://manuelfedele.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://manuelfedele.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://manuelfedele.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://manuelfedele.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://manuelfedele.github.io/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css><link rel=stylesheet href=https://manuelfedele.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css><link rel=stylesheet href=https://manuelfedele.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://manuelfedele.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css><link rel=stylesheet href=https://manuelfedele.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://manuelfedele.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://manuelfedele.github.io/style.css><link rel="shortcut icon" href=https://manuelfedele.github.io/favicon.png><link rel=apple-touch-icon href=https://manuelfedele.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="AWS"><meta property="og:description" content><meta property="og:url" content="https://manuelfedele.github.io/tags/aws/"><meta property="og:site_name" content="Git Push and Run"><meta property="og:image" content="https://manuelfedele.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/tags/aws/index.xml rel=alternate type=application/rss+xml title="Git Push and Run"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>git push && run</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li></ul></nav></header><div class=content><h1>Posts for: #AWS</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/leveraging-ai-as-a-platform-engineer/>Leveraging AI as a Platform Engineer: What Actually Works</a></h1><div class=post-meta><time class=post-date>2026-03-01</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/ai/>AI</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/llm/>LLM</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/devops/>DevOps</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/automation/>automation</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/architecture/>architecture</a>&nbsp;</span><div class=post-content><p>I have spent the last year building AI into the core of my daily engineering work, not as a chat assistant, but as an active participant in systems that move real infrastructure and interact with production APIs. This post is an attempt to write down what I have learned: the patterns that work, the ones that looked good in demos but failed in practice, and the architectural decisions that turned out to matter.</p></div><div><a class="read-more button inline" href=/posts/leveraging-ai-as-a-platform-engineer/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/wasm-vert-cloudfront-zero-cost/>WASM in the Browser: Deploying VERT on CloudFront for Free</a></h1><div class=post-meta><time class=post-date>2026-03-01</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/wasm/>WASM</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/cloudfront/>CloudFront</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/s3/>S3</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/svelte/>Svelte</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/web/>web</a>&nbsp;</span><div class=post-content><h2 id=what-is-webassembly>What is WebAssembly?</h2><p>WebAssembly (WASM) is a binary instruction format that runs inside the browser at near-native speed. Think of it as a portable compilation target: you write code in Rust, C, C++, or Go, compile it to <code>.wasm</code>, and the browser executes it directly in a sandboxed VM alongside JavaScript.</p><p>The browser has always been able to run <em>computation</em>, but JavaScript is an interpreted, dynamically typed language. It is fast enough for most tasks, but there are workloads where it simply is not competitive: video encoding, image processing, cryptography, physics simulations. Before WASM, these had to live on a server. Now they can live in the browser tab.</p></div><div><a class="read-more button inline" href=/posts/wasm-vert-cloudfront-zero-cost/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/building-ai-sre-assistant-from-scratch/>Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator</a></h1><div class=post-meta><time class=post-date>2026-02-22</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/ai/>AI</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/django/>django</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/react/>react</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/gitlab/>GitLab</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/llm/>LLM</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/devops/>DevOps</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/sre/>SRE</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/architecture/>architecture</a>&nbsp;</span><div class=post-content><h1 id=building-an-ai-sre-assistant-from-scratch-architecture-of-an-autonomous-infrastructure-investigator>Building an AI SRE Assistant From Scratch: Architecture of an Autonomous Infrastructure Investigator</h1><p>What if your on-call engineer never slept, had instant access to every repository and every AWS account, and could trace a production issue from DNS to database in under a minute?</p><p>That&rsquo;s the question that led me to build TARS, an AI-powered SRE assistant that autonomously investigates infrastructure issues by combining LLM reasoning with deep integrations into GitLab and AWS. Named after the robot from Interstellar (because every good internal tool needs a movie reference), TARS is a full-stack application where engineers interact with an AI agent through a chat interface. The agent doesn&rsquo;t just answer questions. It investigates. It clones repos, greps code, reads CloudWatch logs, traces DNS chains, inspects ECS services, and synthesizes findings into structured reports.</p></div><div><a class="read-more button inline" href=/posts/building-ai-sre-assistant-from-scratch/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/ecs-fargate-production-patterns/>ECS Fargate Production Patterns That Actually Work</a></h1><div class=post-meta><time class=post-date>2026-01-08</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/ecs/>ECS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/fargate/>Fargate</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/terraform/>Terraform</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/docker/>Docker</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/cloud/>cloud</a>&nbsp;</span><div class=post-content><h1 id=ecs-fargate-production-patterns-that-actually-work>ECS Fargate Production Patterns That Actually Work</h1><p>I&rsquo;ve deployed and managed many containerized services on ECS Fargate. Over time, a set of patterns has emerged that I apply consistently to every new service. This post documents those patterns with Terraform examples, covering everything from Fargate Spot strategies to deployment circuit breakers and ARM64 migration.</p><h2 id=the-standard-architecture>The Standard Architecture</h2><p>Every service I deploy follows the same high-level architecture:</p><pre tabindex=0><code>Internet/VPC -&gt; ALB (HTTPS, TLS 1.3) -&gt; ECS Fargate -&gt; Aurora PostgreSQL Serverless v2
                 |
                WAF (rate limiting + AWS managed rules)
</code></pre><p>Each component has its own security group, with traffic flowing only from the layer above. The ALB sits in private subnets (no public-facing services), and Route53 private hosted zones handle internal DNS.</p></div><div><a class="read-more button inline" href=/posts/ecs-fargate-production-patterns/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/building-ai-document-processing-pipeline-aws/>Building an AI-Powered Document Processing Pipeline on AWS</a></h1><div class=post-meta><time class=post-date>2025-12-03</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/ai/>AI</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/llm/>LLM</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/step-functions/>Step Functions</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/lambda/>Lambda</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/serverless/>serverless</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/python/>python</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/architecture/>architecture</a>&nbsp;</span><div class=post-content><h1 id=building-an-ai-powered-document-processing-pipeline-on-aws>Building an AI-Powered Document Processing Pipeline on AWS</h1><p>Insurance companies process millions of documents every year: police reports, medical records, invoices, repair estimates. Traditionally, human operators read each document, classify it, extract the relevant fields, and enter the data into the claims system. This is slow, expensive, and error-prone.</p><p>In this post I&rsquo;ll describe the architecture of a production document processing pipeline I helped build. The system ingests claim documents, extracts text using vision-based LLMs, clusters and classifies document sections, extracts structured data, and generates vector embeddings for semantic search. All of this runs on a fully serverless AWS architecture with no idle infrastructure costs.</p></div><div><a class="read-more button inline" href=/posts/building-ai-document-processing-pipeline-aws/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/multi-account-aws-terraform-workspaces/>Managing Multi-Account AWS Infrastructure with Terraform Workspaces</a></h1><div class=post-meta><time class=post-date>2025-09-22</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/terraform/>Terraform</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/iac/>IaC</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/devops/>DevOps</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/cloud/>cloud</a>&nbsp;</span><div class=post-content><h1 id=managing-multi-account-aws-infrastructure-with-terraform-workspaces>Managing Multi-Account AWS Infrastructure with Terraform Workspaces</h1><p>When you&rsquo;re managing infrastructure across dozens of AWS accounts, you need patterns that scale. In this post I&rsquo;ll share the approach I use to manage multi-account, multi-environment AWS infrastructure using Terraform workspaces, modular code, and a consistent tagging strategy.</p><h2 id=the-problem>The Problem</h2><p>Imagine this setup: you have multiple organizational scopes (teams, business units, projects), each with their own AWS accounts for non-production and production. On top of that, your non-production account hosts multiple environments (dev, integration, certification). Multiply this by several countries or regions, and you&rsquo;re looking at a lot of infrastructure to manage.</p></div><div><a class="read-more button inline" href=/posts/multi-account-aws-terraform-workspaces/>[]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://manuelfedele.github.io/posts/aws-opensearch-as-monitoring-tool/>Aws Opensearch as Monitoring Tool</a></h1><div class=post-meta><time class=post-date>2023-07-12</time></div><span class=post-tags>#<a href=https://manuelfedele.github.io/tags/aws/>AWS</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/opensearch/>Opensearch</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/monitoring/>Monitoring</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/elasticsearch/>Elasticsearch</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/logging/>Logging</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/kibana/>Kibana</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/cloudwatch/>Cloudwatch</a>&nbsp;
#<a href=https://manuelfedele.github.io/tags/lambda/>Lambda</a>&nbsp;</span><div class=post-content><h1 id=cross-account-logging-shipping-aws-lambda-logs-to-opensearch>Cross-Account Logging: Shipping AWS Lambda Logs to OpenSearch</h1><p>In today&rsquo;s distributed systems, logging and monitoring play a crucial role in detecting anomalies and ensuring system health. AWS Lambda and OpenSearch are often paired to deliver efficient, scalable logging solutions. However, complexities can arise when these resources live in separate AWS accounts. This blog post will guide you through the process of sending AWS Lambda logs from Account A to an OpenSearch cluster in Account B using Terraform as the Infrastructure as Code (IAC) tool and GitLab for CI/CD pipelines.</p></div><div><a class="read-more button inline" href=/posts/aws-opensearch-as-monitoring-tool/>[]</a></div></article><div class=pagination><div class=pagination__buttons></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>