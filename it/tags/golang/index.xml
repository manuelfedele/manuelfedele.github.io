<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on Git Push and Run</title><link>https://manuelfedele.github.io/it/tags/golang/</link><description>Recent content in Golang on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>it</language><copyright>© 2026 Manuel Fedele</copyright><lastBuildDate>Fri, 14 Nov 2025 10:30:00 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/it/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Costruire Tool CLI Interattivi in Go con Bubbletea</title><link>https://manuelfedele.github.io/it/posts/building-interactive-cli-tools-in-go-with-bubbletea/</link><pubDate>Fri, 14 Nov 2025 10:30:00 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/building-interactive-cli-tools-in-go-with-bubbletea/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Bubbletea porta l&amp;rsquo;architettura Elm nel terminale, rendendo possibile costruire tool CLI ricchi e interattivi in Go con una gestione dello stato pulita. Questo articolo copre i fondamentali con un esempio pratico.
&lt;/div>

&lt;p>Se hai mai voluto costruire un&amp;rsquo;applicazione terminale che sembri più un&amp;rsquo;interfaccia vera che un muro di testo, l&amp;rsquo;ecosistema &lt;a href="https://github.com/charmbracelet" target="_blank" rel="noreferrer">charmbracelet&lt;/a> è la strada giusta. Lo uso per costruire tool DevOps interni, e l&amp;rsquo;esperienza da sviluppatore è eccellente. In questo articolo mostro come costruire un tool CLI interattivo usando &lt;a href="https://github.com/charmbracelet/bubbletea" target="_blank" rel="noreferrer">Bubbletea&lt;/a> e &lt;a href="https://github.com/charmbracelet/huh" target="_blank" rel="noreferrer">Huh&lt;/a>.&lt;/p></description></item><item><title>Costruire un motore scacchistico - dalla valutazione della posizione alle tecniche di ricerca</title><link>https://manuelfedele.github.io/it/posts/evaluate-chess-position/</link><pubDate>Wed, 27 Nov 2024 17:33:00 +0000</pubDate><guid>https://manuelfedele.github.io/it/posts/evaluate-chess-position/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I motori scacchistici sono software affascinanti che combinano diversi concetti di informatica: valutazione della posizione, ricerca ad albero, generazione delle mosse e tecniche di ottimizzazione. Questa guida illustra come implementare un motore scacchistico, con particolare attenzione alla&amp;hellip;
&lt;/div>

&lt;p>I motori scacchistici sono software affascinanti che combinano diversi concetti di informatica: valutazione della posizione, ricerca ad albero, generazione delle mosse e tecniche di ottimizzazione. Questa guida illustra come implementare un motore scacchistico, con particolare attenzione alla valutazione della posizione e alle strategie di ricerca.&lt;/p></description></item><item><title>JWT Authentication in Go: HS256, RS256 e Pattern di Middleware</title><link>https://manuelfedele.github.io/it/posts/jwt-issuer-in-go/</link><pubDate>Wed, 27 Nov 2024 17:18:00 +0000</pubDate><guid>https://manuelfedele.github.io/it/posts/jwt-issuer-in-go/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I JWT non sono sessioni. Sono claim firmati e auto-contenuti che non possono essere revocati senza infrastruttura aggiuntiva. Capire questo tradeoff prima di scegliere JWT e&amp;rsquo; piu&amp;rsquo; importante di qualsiasi dettaglio implementativo. Questo post copre HS256 vs RS256, middleware di validazione corretto, revoca dei token con Redis e un endpoint JWKS per la verifica service-to-service.
&lt;/div>

&lt;p>I JWT sono ampiamente mal utilizzati. I team li usano per default perche&amp;rsquo; ogni tutorial li mostra, non perche&amp;rsquo; siano lo strumento giusto per il lavoro. Prima di scrivere codice, bisogna capire cosa sono davvero i JWT e cosa non sono.&lt;/p></description></item><item><title>L'Algoritmo di Dijkstra in Go: Implementazione, Ottimizzazione e Uso Reale</title><link>https://manuelfedele.github.io/it/posts/implementing-djikstra-algorithm-in-go/</link><pubDate>Wed, 27 Nov 2024 17:01:00 +0000</pubDate><guid>https://manuelfedele.github.io/it/posts/implementing-djikstra-algorithm-in-go/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I problemi di percorso minimo sui grafi compaiono costantemente nel platform engineering: routing di rete, risoluzione delle dipendenze, ottimizzazione dei percorsi in un service mesh e scheduling di pipeline CI si riducono tutti a trovare il percorso a costo minimo in un grafo diretto e pesato. L&amp;rsquo;algoritmo di Dijkstra e il cavallo di battaglia per questi problemi quando i pesi degli archi sono non negativi. Questo articolo copre una corretta implementazione in Go, l&amp;rsquo;ottimizzazione basata su heap che la rende pratica su grafi di grandi dimensioni, la ricostruzione del percorso e un caso d&amp;rsquo;uso realistico di risoluzione delle dipendenze.
&lt;/div>


&lt;h2 class="relative group">Rappresentazione del Grafo
 &lt;div id="rappresentazione-del-grafo" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#rappresentazione-del-grafo" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Una lista di adiacenza con ID di nodo interi e la scelta giusta per Dijkstra in Go. Le chiavi stringa sono comode per esempi piccoli ma aggiungono overhead di hashing inutile su grafi con migliaia di nodi. Rappresentiamo gli archi pesati come struct e memorizziamo il grafo come una slice di slice (indicizzata per ID nodo).&lt;/p></description></item><item><title>Monitoraggio della clipboard in Go: rilevamento e redazione di segreti</title><link>https://manuelfedele.github.io/it/posts/clipboard-watch-remove-accidentally-typed-passwords/</link><pubDate>Sun, 26 Nov 2023 11:29:46 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/clipboard-watch-remove-accidentally-typed-passwords/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Digitare accidentalmente una password nel campo sbagliato e lasciarla nella clipboard è un rischio di sicurezza reale. Un monitor della clipboard può rilevare i pattern di segreti comuni e redigerli automaticamente prima che vengano incollati dove non dovrebbero andare.
&lt;/div>

&lt;p>Questo articolo costruisce un clipboard watcher di qualita produzione in Go: rilevamento di segreti basato su regex, polling thread-safe con context cancellation, notifiche desktop alla redazione e configurazione del servizio di background a livello OS per macOS e Linux.&lt;/p></description></item><item><title>Design di package pulito in Go: Singola responsabilità e coesione</title><link>https://manuelfedele.github.io/it/posts/the-single-responsibility-principle/</link><pubDate>Tue, 21 Mar 2023 15:10:03 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/the-single-responsibility-principle/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 L&amp;rsquo;SRP in Go riguarda i confini dei package e le superfici esportate, non solo dividere i metodi in file diversi. Quando un package ha un solo motivo per cambiare, lo si può testare in isolamento, sostituire le implementazioni dietro un&amp;rsquo;interfaccia e ragionare sul suo comportamento senza leggere il resto del codebase.
&lt;/div>

&lt;p>Il Single Responsibility Principle (SRP) viene spesso enunciato come &amp;ldquo;una classe dovrebbe avere un solo motivo per cambiare.&amp;rdquo; In Go non esistono classi, ma il principio si applica con uguale forza ai package e ai tipi esportati al loro interno. Sbagliarlo produce un God service: un unico package che conosce il database, l&amp;rsquo;email, HTTP e la business logic tutti insieme. Applicarlo correttamente produce un codebase dove cambiare il provider email non richiede di toccare il layer del database.&lt;/p></description></item><item><title>Design Pattern in Go: Implementazioni Idiomatiche</title><link>https://manuelfedele.github.io/it/posts/implement-desing-patterns-with-golang/</link><pubDate>Tue, 21 Feb 2023 13:16:06 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/implement-desing-patterns-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go affronta i design pattern in modo diverso rispetto a Java o C++. Poiche Go usa la composizione invece dell&amp;rsquo;ereditarieta, e le funzioni sono valori di prima classe, molti pattern che richiedono elaborate gerarchie di classi nei linguaggi OOP si riducono a pochi costrutti idiomatici Go. Questo articolo mostra le implementazioni corrette, pronte per la produzione, e, altrettanto importante, quando non usare affatto un pattern.
&lt;/div>

&lt;p>I design pattern non sono una checklist. In Go, applicare pattern in stile Java porta rapidamente a codice che appare estraneo a ogni sviluppatore Go che lo legge. I pattern qui sotto sono presentati nella loro forma idiomatica Go, spesso molto piu semplice della versione da libro di testo.&lt;/p></description></item><item><title>NATS Messaging in Go: Core, JetStream e Pattern di Produzione</title><link>https://manuelfedele.github.io/it/posts/nats-messaging-with-golang/</link><pubDate>Mon, 13 Feb 2023 18:57:15 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/nats-messaging-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 NATS e&amp;rsquo; un sistema di messaggistica in un unico binario con latenza sub-millisecondo, costruito per i workload cloud-native. Non e&amp;rsquo; Kafka, e non e&amp;rsquo; Redis Streams. Sapere quando sceglierlo e cosa non sa fare e&amp;rsquo; importante quanto sapere come usarlo. Questo post copre core pub/sub, queue group, request/reply, JetStream, pull consumer e autenticazione.
&lt;/div>

&lt;p>Kafka, NATS, Redis Streams e RabbitMQ si descrivono tutti come &amp;ldquo;sistemi di messaggistica.&amp;rdquo; Non sono intercambiabili. Kafka e&amp;rsquo; ottimizzato per lo storage di event log ad alto throughput con replay a lungo termine. Redis Streams e&amp;rsquo; una buona scelta quando hai gia&amp;rsquo; Redis e hai bisogno di un consumer group leggero. RabbitMQ e&amp;rsquo; la scelta giusta per routing complesso e semantiche AMQP.&lt;/p></description></item><item><title>Risolvere il Sudoku in Go: Backtracking, Constraint Caching e Benchmark</title><link>https://manuelfedele.github.io/it/posts/build-a-sudoku-solver-in-golang/</link><pubDate>Wed, 01 Feb 2023 21:09:26 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/build-a-sudoku-solver-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Il Sudoku e un classico problema di soddisfacimento di vincoli (CSP). Le stesse tecniche algoritmiche &amp;ndash; backtracking con propagazione dei vincoli &amp;ndash; compaiono in sistemi di produzione per la pianificazione di job, l&amp;rsquo;allocazione di risorse e la validazione delle configurazioni. Capire come implementare e ottimizzare un solver Sudoku ti da un modello mentale concreto per affrontare questi problemi su larga scala.
&lt;/div>


&lt;h2 class="relative group">Rappresentazione del Problema
 &lt;div id="rappresentazione-del-problema" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#rappresentazione-del-problema" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Una griglia Sudoku e una matrice 9x9 di interi dove 0 rappresenta una cella vuota. Un array di dimensione fissa e il tipo giusto: risiede sullo stack, non ha overhead di allocazione e puo essere passato per valore per la semantica di snapshot durante il backtracking.&lt;/p></description></item><item><title>Comunicazione Real-Time in Go: TCP Socket, Message Framing e WebSocket</title><link>https://manuelfedele.github.io/it/posts/socket-messaging-with-golang/</link><pubDate>Sun, 29 Jan 2023 18:44:12 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/socket-messaging-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 TCP e un protocollo stream, non un protocollo a messaggi. Se leggi i byte in un buffer a dimensione fissa, troncherai silenziosamente i messaggi piu grandi di quel buffer. Hai bisogno del framing. Questo articolo copre il framing con prefisso di lunghezza, un server broadcast multi-client e il supporto WebSocket per i client browser.
&lt;/div>

&lt;p>La prima cosa che la maggior parte dei tutorial sui socket in Go sbaglia e il buffer. Leggere in &lt;code>make([]byte, 1024)&lt;/code> non e orientato ai messaggi. Un messaggio di 1025 byte viene diviso in due letture. Un messaggio di 512 byte e uno di 300 byte possono arrivare in una singola chiamata &lt;code>Read&lt;/code>. TCP e uno stream: devi aggiungere struttura sopra di esso.&lt;/p></description></item><item><title>Email Open Tracking con Go: Tracking Pixel, URL Univoci e GDPR</title><link>https://manuelfedele.github.io/it/posts/tracking-pixel-technology-email-golang/</link><pubDate>Sun, 22 Jan 2023 19:02:19 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/tracking-pixel-technology-email-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Un tracking pixel e un&amp;rsquo;immagine trasparente 1x1 incorporata in un&amp;rsquo;email HTML. Quando un client email renderizza l&amp;rsquo;immagine, invia una richiesta HTTP GET al server &amp;ndash; registrando l&amp;rsquo;evento di apertura. Usati correttamente, i tracking pixel alimentano le ricevute di lettura, la conferma di consegna e l&amp;rsquo;analisi del coinvolgimento per email transazionali e di marketing. Usati con superficialita, violano il GDPR e producono metriche fuorvianti. Questo articolo copre un&amp;rsquo;implementazione Go corretta per la produzione con URL univoci per destinatario, una discussione onesta su cosa misurano effettivamente i dati, e gli obblighi di conformita che non si possono ignorare.
&lt;/div>


&lt;h2 class="relative group">Come Funziona
 &lt;div id="come-funziona" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#come-funziona" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Il meccanismo e semplice, ma i dettagli contano per la precisione e la conformita.&lt;/p></description></item><item><title>Comunicare con Stockfish da Go: il protocollo UCI</title><link>https://manuelfedele.github.io/it/posts/evaluate-chess-position-with-golang/</link><pubDate>Thu, 19 Jan 2023 21:33:41 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/evaluate-chess-position-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Stockfish e il motore scacchistico piu forte al mondo. Comunicare con esso da Go tramite il protocollo UCI richiede circa 30 righe. Questo articolo mostra l&amp;rsquo;implementazione reale: avvio del processo, handshake UCI, input FEN, parsing della valutazione e una struct Engine completa e riusabile.
&lt;/div>

&lt;p>La versione originale di questo articolo chiamava metodi inesistenti come &lt;code>chess.NewEngine(&amp;quot;stockfish&amp;quot;)&lt;/code>, &lt;code>SetDifficulty&lt;/code> e &lt;code>Evaluate&lt;/code> sulla libreria &lt;code>notnil/chess&lt;/code>. Quella libreria e un motore per le regole degli scacchi &amp;ndash; non fa da wrapper a Stockfish in alcun modo. Comunicare con Stockfish richiede il protocollo UCI su stdin/stdout, che e esattamente cio che questo articolo illustra.&lt;/p></description></item><item><title>Memoizzazione in Go: Caching di Computazioni Costose nel Modo Corretto</title><link>https://manuelfedele.github.io/it/posts/the-memoization-technique/</link><pubDate>Mon, 16 Jan 2023 21:07:26 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/the-memoization-technique/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 La memoizzazione e la tecnica di ottimizzazione che consiste nel fare il caching del valore restituito da una funzione pura, in modo che le chiamate ripetute con gli stessi input saltino completamente la computazione. Si applica ogni volta che una funzione e costosa, deterministica e chiamata piu volte con gli stessi argomenti. Fatta correttamente in Go richiede un mutex, e nel codice moderno un wrapper generico la rende riutilizzabile su piu tipi.
&lt;/div>

&lt;p>La memoizzazione viene spesso introdotta con Fibonacci perche l&amp;rsquo;esplosione ricorsiva e facile da visualizzare. Ma le applicazioni reali in produzione sono altrove: controlli dei permessi che accedono a un database, lookup di configurazione su rete, o costose computazioni crittografiche. Questo post copre il quadro completo: dall&amp;rsquo;implementazione di base alla prevenzione delle data race, ai wrapper generici e all&amp;rsquo;invalidazione con time-to-live (TTL).&lt;/p></description></item><item><title>Trading algoritmico con Alpaca e Go: paper trading e dati in tempo reale</title><link>https://manuelfedele.github.io/it/posts/trading-with-alpaca-and-golang/</link><pubDate>Sun, 15 Jan 2023 19:24:09 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/trading-with-alpaca-and-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Alpaca offre trading commission-free e API-first con un ambiente di paper trading per testare le strategie in sicurezza. Questo articolo copre i pattern reali dell&amp;rsquo;SDK Go, il corretto piazzamento degli ordini, il recupero dei dati in tempo reale, una semplice strategia momentum e la gestione del rischio necessaria prima di andare live.
&lt;/div>

&lt;p>La versione originale di questo articolo chiamava funzioni come &lt;code>alpaca.PlaceOrder&lt;/code>, &lt;code>alpaca.GetQuote&lt;/code> e &lt;code>alpaca.ListTrades&lt;/code> come funzioni a livello di package. Nessuna di queste esiste nell&amp;rsquo;SDK corrente. La vera libreria usa una struct client. Questo articolo usa il pacchetto reale &lt;code>github.com/alpacahq/alpaca-trade-api-go/v3/alpaca&lt;/code>.&lt;/p></description></item><item><title>Testing in Go: Dai Unit Test ai Mock e ai Benchmark</title><link>https://manuelfedele.github.io/it/posts/unit-testing-in-golang/</link><pubDate>Mon, 09 Jan 2023 20:49:03 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/unit-testing-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 La filosofia di testing di Go e stdlib-first e table-driven. Raramente hai bisogno di un framework esterno. Il package &lt;code>testing&lt;/code>, combinato con le interfacce per la dependency injection e &lt;code>httptest&lt;/code> per HTTP, copre quasi tutto cio che incontrerai nei codebase di produzione.
&lt;/div>

&lt;p>Molti sviluppatori Go che vengono da Python o Java usano testify o gomock prima che ne abbiano effettivo bisogno. La libreria standard di Go e notevolmente completa per il testing. Questo post illustra i pattern che gli ingegneri Go esperti usano davvero: table-driven test con subtest, mock basati su interfacce, testing degli HTTP handler, benchmark e analisi della coverage.&lt;/p></description></item><item><title>Video Streaming in Go: Range Request HTTP, Segmenti HLS e FFmpeg</title><link>https://manuelfedele.github.io/it/posts/streaming-video-with-golang/</link><pubDate>Wed, 04 Jan 2023 21:23:20 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/streaming-video-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Il video streaming corretto in HTTP non riguarda il piping di byte. Riguarda le range request che permettono ai player di fare seeking, i segmenti HLS che abilitano il bitrate adattivo, e mantenere FFmpeg come sottoprocesso mentre Go gestisce HTTP. Fai bene queste tre cose e hai un server video funzionante.
&lt;/div>

&lt;p>&lt;code>http.ServeFile&lt;/code> gestisce effettivamente le range request correttamente per i file statici. Il problema sorge quando cerchi di costruire qualcosa di piu sofisticato: transcodifica al volo, live streaming, o segmentazione HLS. Questo articolo copre ogni scenario con codice funzionante, e spiega cosa gestisce e cosa non gestisce &lt;code>http.ServeFile&lt;/code>.&lt;/p></description></item><item><title>Il package context di Go: Cancellazione, Timeout e Propagazione in Produzione</title><link>https://manuelfedele.github.io/it/posts/the-context-package/</link><pubDate>Tue, 03 Jan 2023 20:36:29 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/the-context-package/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Il package &lt;code>context&lt;/code> esiste per un motivo principale: la gestione del ciclo di vita delle goroutine. Fornisce un modo standard e componibile per propagare segnali di cancellazione, deadline e metadati request-scoped attraverso i confini delle API. Capire come funziona in produzione fa la differenza tra un servizio che si spegne pulitamente e uno che perde goroutine sotto carico.
&lt;/div>

&lt;p>Ogni servizio Go non banale usa &lt;code>context&lt;/code>. Lo si passa dagli HTTP handler alle query sul database, dagli interceptor gRPC alle chiamate API downstream. Ma molti ingegneri lo trattano come poco piu di una convenzione per soddisfare le firme delle funzioni. Questo post spiega come &lt;code>context&lt;/code> funziona davvero, dove fallisce silenziosamente quando viene mal utilizzato, e i pattern che contano in produzione.&lt;/p></description></item><item><title>Protocol Buffers in Go: Serializzazione, gRPC e Performance</title><link>https://manuelfedele.github.io/it/posts/use-protobuf-with-golang/</link><pubDate>Tue, 27 Dec 2022 18:48:44 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/use-protobuf-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Protocol Buffers offrono serializzazione binaria circa il 40% più compatta e 6 volte più veloce di JSON. Vale la pena del trade-off per il traffico interno tra microservizi. Non vale la pena per un&amp;rsquo;API REST pubblica che gli sviluppatori devono leggere con curl.
&lt;/div>

&lt;p>Protocol Buffers (protobuf) sono il formato di serializzazione binaria di Google. Il vantaggio è semplice: definisci lo schema dati una volta in un file &lt;code>.proto&lt;/code>, generi codice tipizzato in qualsiasi linguaggio e ottieni un formato wire compatto. Lo svantaggio è l&amp;rsquo;overhead degli strumenti e la perdita di leggibilità umana. Questo articolo illustra un setup completo in Go: la corretta API di marshaling, un servizio gRPC e un benchmark che confronta protobuf con JSON.&lt;/p></description></item><item><title>Costruire CLI in Go con Cobra: flag, sottocomandi e shell completion</title><link>https://manuelfedele.github.io/it/posts/create-command-line-application-with-golang/</link><pubDate>Tue, 20 Dec 2022 10:03:30 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/create-command-line-application-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Cobra e lo standard de-facto per CLI Go serie. kubectl, la GitHub CLI e Docker lo usano tutti. Se stai costruendo uno strumento a riga di comando con piu sottocomandi, flag tipizzati e shell completion, ecco come farlo correttamente.
&lt;/div>

&lt;p>Il parsing grezzo di &lt;code>os.Args&lt;/code> funziona per un singolo comando con un argomento posizionale. Nel momento in cui aggiungi un secondo sottocomando o un flag &lt;code>--dry-run&lt;/code>, stai reinventando la ruota. Cobra gestisce il parsing degli argomenti, la validazione dei flag, la generazione dei testi di help e la shell completion out of the box.&lt;/p></description></item><item><title>Redis in Go con go-redis/v9: Caching, Pub/Sub e Pattern di Produzione</title><link>https://manuelfedele.github.io/it/posts/use-redis-with-golang/</link><pubDate>Mon, 19 Dec 2022 19:32:27 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/use-redis-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Redis non e&amp;rsquo; solo una cache. E&amp;rsquo; un server di strutture dati che parla TCP, persiste su disco, replica tra nodi e gestisce il fan-out pub/sub in un unico binario. Questo post spiega come usarlo correttamente da Go con go-redis/v9: pool di connessioni, gestione TTL, cache-aside pattern, sorted set per il rate limiting, pub/sub e pipeline.
&lt;/div>

&lt;p>La maggior parte dei team ricorre a Redis quando ha bisogno di una cache chiave-valore veloce, lo usa con &lt;code>SET&lt;/code>/&lt;code>GET&lt;/code> e si ferma li&amp;rsquo;. Questo significa perdere quasi tutto quello che Redis sa fare. Questo post copre le strutture dati e i pattern operativi che contano in produzione: configurazione corretta del connection pool, disciplina sui TTL, cache-aside pattern con i generics, liste come code, sorted set per il rate limiting a finestra scorrevole, pub/sub per il fan-out e pipeline atomiche.&lt;/p></description></item><item><title>Applicazioni desktop in Go con Fyne: dashboard mercato azionario</title><link>https://manuelfedele.github.io/it/posts/create-desktop-application-stock-market-data-golang/</link><pubDate>Mon, 19 Dec 2022 19:08:58 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/create-desktop-application-stock-market-data-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Fyne e il miglior toolkit UI cross-platform per Go. Un unico codebase compila su Windows, macOS e Linux, producendo un binario nativo senza dipendenze runtime. Questo articolo costruisce una vera dashboard per il mercato azionario, coprendo il sistema di widget di Fyne, il layout engine, le regole di thread safety per le goroutine e la distribuzione.
&lt;/div>


&lt;h2 class="relative group">Perche Fyne
 &lt;div id="perche-fyne" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#perche-fyne" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Le applicazioni desktop in Go sono storicamente state scomode. I binding CGo a GTK o Qt funzionano, ma la complessita di build e considerevole. Fyne adotta un approccio diverso: usa OpenGL per il rendering, mantenendo l&amp;rsquo;API in puro Go e il binario risultante completamente autonomo.&lt;/p></description></item><item><title>Costruire Servizi HTTP in Produzione con Go</title><link>https://manuelfedele.github.io/it/posts/how-to-create-a-webserver-in-golang/</link><pubDate>Sun, 11 Dec 2022 19:14:21 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/how-to-create-a-webserver-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 La libreria standard &lt;code>net/http&lt;/code> di Go è pronta per la produzione. Con il routing migliorato di Go 1.22+, il matching per metodo e pattern è integrato. Per la maggior parte dei servizi non serve un framework &amp;ndash; ma è necessario configurare correttamente timeout, graceful shutdown e middleware fin dall&amp;rsquo;inizio.
&lt;/div>

&lt;p>La maggior parte dei tutorial Go su HTTP mostra &lt;code>http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)&lt;/code> e finisce lì. Quel codice funzionerà, ma perderà goroutine sotto carico, si bloccherà per sempre su client lenti e si spegnerà in modo non controllato durante i deploy. Questo articolo mostra come appare davvero un servizio HTTP Go pronto per la produzione, usando solo la libreria standard per il core, con una nota su quando un router esterno vale la pena.&lt;/p></description></item><item><title>Interfacce Go in Pratica: Polimorfismo, Composizione e Testing</title><link>https://manuelfedele.github.io/it/posts/how-to-use-interfaces-in-golang/</link><pubDate>Sun, 11 Dec 2022 19:04:27 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/how-to-use-interfaces-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Le interfacce Go sono implicite. Non dichiari che un tipo implementa un&amp;rsquo;interfaccia. Se un tipo ha i metodi giusti, soddisfa l&amp;rsquo;interfaccia. Questa singola scelta di design rende le interfacce Go piu flessibili, piu componibili e piu potenti per il testing rispetto alle implementazioni di interfacce esplicite in Java o C#.
&lt;/div>

&lt;p>Le interfacce sono il meccanismo che Go usa per esprimere il polimorfismo, per disaccoppiare i consumer dai producer, e per rendere il codice testabile senza framework pesanti. Questo post tratta i pattern che contano nei codebase reali: polimorfismo con slice di interfacce, il design di &lt;code>io.Reader&lt;/code>/&lt;code>io.Writer&lt;/code>, composizione di interfacce, interfacce per i mock nei test, e il confine tra &lt;code>any&lt;/code> e i generics.&lt;/p></description></item><item><title>Il pattern Factory in Go: dependency inversion e servizi testabili</title><link>https://manuelfedele.github.io/it/posts/implement-factory-design-pattern-golang/</link><pubDate>Sun, 11 Dec 2022 18:57:13 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/implement-factory-design-pattern-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Il pattern Factory in Go riguarda principalmente la costruzione basata su interfacce che abilita la dependency inversion e il testing. L&amp;rsquo;esempio degli animali va bene per imparare la sintassi. Questo articolo mostra la versione che conta in produzione: backend di storage, sender di notifiche e servizi testabili.
&lt;/div>

&lt;p>La versione originale di questo articolo aveva due paragrafi e un esempio con &lt;code>Dog.Speak()&lt;/code>. Questo copre la sintassi ma manca completamente il punto. Il pattern Factory in Go non riguarda la creazione di animali. Riguarda la scrittura di codice in cui il layer chiamante non ha bisogno di sapere o importarsi di quale implementazione concreta riceve.&lt;/p></description></item></channel></rss>