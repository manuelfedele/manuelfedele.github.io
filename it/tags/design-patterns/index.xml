<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design Patterns on Git Push and Run</title><link>https://manuelfedele.github.io/it/tags/design-patterns/</link><description>Recent content in Design Patterns on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>it</language><copyright>© 2026 Manuel Fedele</copyright><lastBuildDate>Tue, 21 Mar 2023 15:10:03 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/it/tags/design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Design di package pulito in Go: Singola responsabilità e coesione</title><link>https://manuelfedele.github.io/it/posts/the-single-responsibility-principle/</link><pubDate>Tue, 21 Mar 2023 15:10:03 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/the-single-responsibility-principle/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 L&amp;rsquo;SRP in Go riguarda i confini dei package e le superfici esportate, non solo dividere i metodi in file diversi. Quando un package ha un solo motivo per cambiare, lo si può testare in isolamento, sostituire le implementazioni dietro un&amp;rsquo;interfaccia e ragionare sul suo comportamento senza leggere il resto del codebase.
&lt;/div>

&lt;p>Il Single Responsibility Principle (SRP) viene spesso enunciato come &amp;ldquo;una classe dovrebbe avere un solo motivo per cambiare.&amp;rdquo; In Go non esistono classi, ma il principio si applica con uguale forza ai package e ai tipi esportati al loro interno. Sbagliarlo produce un God service: un unico package che conosce il database, l&amp;rsquo;email, HTTP e la business logic tutti insieme. Applicarlo correttamente produce un codebase dove cambiare il provider email non richiede di toccare il layer del database.&lt;/p></description></item><item><title>Design Pattern in Go: Implementazioni Idiomatiche</title><link>https://manuelfedele.github.io/it/posts/implement-desing-patterns-with-golang/</link><pubDate>Tue, 21 Feb 2023 13:16:06 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/implement-desing-patterns-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go affronta i design pattern in modo diverso rispetto a Java o C++. Poiche Go usa la composizione invece dell&amp;rsquo;ereditarieta, e le funzioni sono valori di prima classe, molti pattern che richiedono elaborate gerarchie di classi nei linguaggi OOP si riducono a pochi costrutti idiomatici Go. Questo articolo mostra le implementazioni corrette, pronte per la produzione, e, altrettanto importante, quando non usare affatto un pattern.
&lt;/div>

&lt;p>I design pattern non sono una checklist. In Go, applicare pattern in stile Java porta rapidamente a codice che appare estraneo a ogni sviluppatore Go che lo legge. I pattern qui sotto sono presentati nella loro forma idiomatica Go, spesso molto piu semplice della versione da libro di testo.&lt;/p></description></item><item><title>Interfacce Go in Pratica: Polimorfismo, Composizione e Testing</title><link>https://manuelfedele.github.io/it/posts/how-to-use-interfaces-in-golang/</link><pubDate>Sun, 11 Dec 2022 19:04:27 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/how-to-use-interfaces-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Le interfacce Go sono implicite. Non dichiari che un tipo implementa un&amp;rsquo;interfaccia. Se un tipo ha i metodi giusti, soddisfa l&amp;rsquo;interfaccia. Questa singola scelta di design rende le interfacce Go piu flessibili, piu componibili e piu potenti per il testing rispetto alle implementazioni di interfacce esplicite in Java o C#.
&lt;/div>

&lt;p>Le interfacce sono il meccanismo che Go usa per esprimere il polimorfismo, per disaccoppiare i consumer dai producer, e per rendere il codice testabile senza framework pesanti. Questo post tratta i pattern che contano nei codebase reali: polimorfismo con slice di interfacce, il design di &lt;code>io.Reader&lt;/code>/&lt;code>io.Writer&lt;/code>, composizione di interfacce, interfacce per i mock nei test, e il confine tra &lt;code>any&lt;/code> e i generics.&lt;/p></description></item><item><title>Il pattern Factory in Go: dependency inversion e servizi testabili</title><link>https://manuelfedele.github.io/it/posts/implement-factory-design-pattern-golang/</link><pubDate>Sun, 11 Dec 2022 18:57:13 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/implement-factory-design-pattern-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Il pattern Factory in Go riguarda principalmente la costruzione basata su interfacce che abilita la dependency inversion e il testing. L&amp;rsquo;esempio degli animali va bene per imparare la sintassi. Questo articolo mostra la versione che conta in produzione: backend di storage, sender di notifiche e servizi testabili.
&lt;/div>

&lt;p>La versione originale di questo articolo aveva due paragrafi e un esempio con &lt;code>Dog.Speak()&lt;/code>. Questo copre la sintassi ma manca completamente il punto. Il pattern Factory in Go non riguarda la creazione di animali. Riguarda la scrittura di codice in cui il layer chiamante non ha bisogno di sapere o importarsi di quale implementazione concreta riceve.&lt;/p></description></item></channel></rss>