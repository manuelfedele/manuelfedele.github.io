<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Context on Git Push and Run</title><link>https://manuelfedele.github.io/it/tags/context/</link><description>Recent content in Context on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>it</language><copyright>Â© 2026 Manuel Fedele</copyright><lastBuildDate>Tue, 03 Jan 2023 20:36:29 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/it/tags/context/index.xml" rel="self" type="application/rss+xml"/><item><title>Il package context di Go: Cancellazione, Timeout e Propagazione in Produzione</title><link>https://manuelfedele.github.io/it/posts/the-context-package/</link><pubDate>Tue, 03 Jan 2023 20:36:29 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/the-context-package/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Il package &lt;code>context&lt;/code> esiste per un motivo principale: la gestione del ciclo di vita delle goroutine. Fornisce un modo standard e componibile per propagare segnali di cancellazione, deadline e metadati request-scoped attraverso i confini delle API. Capire come funziona in produzione fa la differenza tra un servizio che si spegne pulitamente e uno che perde goroutine sotto carico.
&lt;/div>

&lt;p>Ogni servizio Go non banale usa &lt;code>context&lt;/code>. Lo si passa dagli HTTP handler alle query sul database, dagli interceptor gRPC alle chiamate API downstream. Ma molti ingegneri lo trattano come poco piu di una convenzione per soddisfare le firme delle funzioni. Questo post spiega come &lt;code>context&lt;/code> funziona davvero, dove fallisce silenziosamente quando viene mal utilizzato, e i pattern che contano in produzione.&lt;/p></description></item></channel></rss>