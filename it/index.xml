<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git Push and Run</title><link>https://manuelfedele.github.io/it/</link><description>Recent content on Git Push and Run</description><generator>Hugo -- gohugo.io</generator><language>it</language><copyright>© 2026 Manuel Fedele</copyright><lastBuildDate>Sun, 01 Mar 2026 12:00:00 +0100</lastBuildDate><atom:link href="https://manuelfedele.github.io/it/index.xml" rel="self" type="application/rss+xml"/><item><title>Sfruttare l'AI come Ingegnere Software: Cosa Funziona Davvero</title><link>https://manuelfedele.github.io/it/posts/leveraging-ai-as-a-platform-engineer/</link><pubDate>Sun, 01 Mar 2026 12:00:00 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/leveraging-ai-as-a-platform-engineer/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Uso i tool AI seriamente da circa un anno — non per svago, non in modo sperimentale, ma come parte fondamentale del mio lavoro quotidiano. Questo articolo non parla di AI che genera codice. Parla di come l&amp;rsquo;AI cambia il modo in cui un ingegnere esperto pensa, indaga e prende decisioni.
&lt;/div>


&lt;h2 class="relative group">Il Cambiamento Che Conta Davvero
 &lt;div id="il-cambiamento-che-conta-davvero" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#il-cambiamento-che-conta-davvero" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>La versione naive dello sviluppo assistito dall&amp;rsquo;AI è: descrivi cosa vuoi, l&amp;rsquo;AI lo scrive, tu revisioni e vai avanti. Questo è reale e utile, ma è anche la cosa meno interessante che l&amp;rsquo;AI fa per me.&lt;/p></description></item><item><title>Da Zero alla Produzione con uno Strumento di Conformità DORA in un Giorno</title><link>https://manuelfedele.github.io/it/posts/shipping-a-dora-compliance-tool-from-zero-to-prod/</link><pubDate>Sun, 01 Mar 2026 10:00:00 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/shipping-a-dora-compliance-tool-from-zero-to-prod/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Ho trascorso un&amp;rsquo;unica sessione a costruire da zero uno strumento di gestione dei fornitori terzi conforme al DORA, aggiungendo il SSO Microsoft Entra ID, migrando l&amp;rsquo;intera infrastruttura da CloudFormation a Terraform, e deployando in ambienti qual e prod su ECS Fargate, risolvendo lungo la strada una cascata di problemi reali. Questo è il resoconto onesto di cosa ha funzionato e di cosa no.
&lt;/div>

&lt;p>Ho costruito un Third Party Management (TPM) tool conforme al DORA: un&amp;rsquo;applicazione Django + React per gestire i cicli di vita dei fornitori ICT, le valutazioni del rischio e i registri regolatori. Ho poi integrato il SSO Microsoft Entra ID, containerizzato il tutto e deployato su AWS ECS Fargate con una pipeline Terraform, in un ambiente aziendale pieno di proxy, permission boundary e infrastruttura condivisa.&lt;/p></description></item><item><title>WASM nel Browser: Distribuire VERT su CloudFront Gratuitamente</title><link>https://manuelfedele.github.io/it/posts/wasm-vert-cloudfront-zero-cost/</link><pubDate>Sun, 01 Mar 2026 10:00:00 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/wasm-vert-cloudfront-zero-cost/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 WebAssembly consente di eseguire lavoro CPU-intensivo direttamente nel tab del browser — senza server, senza upload, senza costi. Questo articolo spiega cosa è WASM e come hostare VERT, un convertitore di file completamente locale, su AWS CloudFront a costo praticamente zero.
&lt;/div>


&lt;h2 class="relative group">Cos&amp;rsquo;è WebAssembly?
 &lt;div id="cosè-webassembly" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#cos%c3%a8-webassembly" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>WebAssembly (WASM) è un formato di istruzione binaria che gira nel browser a velocità quasi nativa. Pensalo come un target di compilazione portabile: scrivi codice in Rust, C, C++ o Go, compilalo in &lt;code>.wasm&lt;/code>, e il browser lo esegue direttamente in una VM sandbox accanto a JavaScript.&lt;/p></description></item><item><title>Costruire un Assistente SRE AI da Zero: Architettura di un Investigatore Infrastrutturale Autonomo</title><link>https://manuelfedele.github.io/it/posts/building-ai-sre-assistant-from-scratch/</link><pubDate>Sun, 22 Feb 2026 09:30:00 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/building-ai-sre-assistant-from-scratch/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Cosa succederebbe se il tuo ingegnere di on-call non dormisse mai, avesse accesso istantaneo a ogni repository e ogni account AWS, e potesse tracciare un problema di produzione dal DNS al database in meno di un minuto? Questo articolo descrive ogni layer dell&amp;rsquo;architettura — dal sistema di autenticazione al framework agente, al registry dei tool, all&amp;rsquo;infrastruttura di streaming e al deployment.
&lt;/div>

&lt;div class="admonition relative overflow-hidden rounded-lg border-l-4 my-3 px-4 py-3 shadow-sm" data-type="note">
 &lt;div class="flex items-center gap-2 font-semibold text-inherit">
 &lt;div class="flex shrink-0 h-5 w-5 items-center justify-center text-lg">&lt;span class="relative block icon">&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">&lt;path fill="currentColor" d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z"/>&lt;/svg>
&lt;/span>&lt;/div>
 &lt;div class="grow">
 Nota
 &lt;/div>
 &lt;/div>&lt;div class="admonition-content mt-3 text-base leading-relaxed text-inherit">&lt;p>Questo articolo descrive un assistente SRE AI costruito con l&amp;rsquo;SDK Strands Agents, Django, React e AWS. L&amp;rsquo;agente indaga autonomamente i problemi infrastrutturali combinando ragionamento LLM con integrazioni profonde in GitLab e AWS.&lt;/p></description></item><item><title>Costruire un Agente AI per le Operazioni di Piattaforma</title><link>https://manuelfedele.github.io/it/posts/building-ai-powered-platform-operations-agent/</link><pubDate>Sun, 15 Feb 2026 11:00:00 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/building-ai-powered-platform-operations-agent/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I team di platform engineering gestiscono un flusso costante di richieste ripetitive. Questo articolo mostra come costruire un agente AI che automatizza le attività comuni di piattaforma — provisioning utenti, rotazione chiavi, controlli di salute dei servizi — dando a un LLM accesso agli strumenti interni attraverso un&amp;rsquo;interfaccia di tool-calling strutturata.
&lt;/div>

&lt;p>I team di platform engineering gestiscono un flusso costante di richieste ripetitive: onboarding utenti, gestione API key, verifica dello stato dei servizi, rotazione credenziali. La maggior parte di questi compiti segue procedure ben definite che un umano esegue passo per passo. E se un agente AI potesse gestirle al suo posto?&lt;/p></description></item><item><title>Pattern ECS Fargate per la Produzione Che Funzionano Davvero</title><link>https://manuelfedele.github.io/it/posts/ecs-fargate-production-patterns/</link><pubDate>Thu, 08 Jan 2026 14:20:00 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/ecs-fargate-production-patterns/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Un insieme di pattern ECS Fargate collaudati in produzione che applico a ogni servizio — covering strategie Spot, circuit breaker per i deployment, migrazione ARM64, health check e ottimizzazione dei costi con Aurora Serverless v2.
&lt;/div>

&lt;p>Ho distribuito e gestito molti servizi containerizzati su ECS Fargate. Nel tempo è emerso un insieme di pattern che applico sistematicamente a ogni nuovo servizio. Questo articolo documenta quei pattern con esempi Terraform, coprendo tutto dalle strategie Fargate Spot ai circuit breaker di deployment e alla migrazione ARM64.&lt;/p></description></item><item><title>Costruire una Pipeline di Elaborazione Documenti AI su AWS</title><link>https://manuelfedele.github.io/it/posts/building-ai-document-processing-pipeline-aws/</link><pubDate>Wed, 03 Dec 2025 16:45:00 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/building-ai-document-processing-pipeline-aws/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Una pipeline serverless di elaborazione documenti su AWS che usa LLM per estrarre dati strutturati da documenti non strutturati — fatture, contratti, report — su larga scala. Nessun cluster GPU richiesto.
&lt;/div>

&lt;p>Le compagnie assicurative elaborano milioni di documenti ogni anno: verbali di polizia, cartelle cliniche, fatture, preventivi di riparazione. Tradizionalmente, operatori umani leggono ogni documento, lo classificano, ne estraggono i campi rilevanti e inseriscono i dati nel sistema dei sinistri. Questo è lento, costoso e soggetto a errori.&lt;/p></description></item><item><title>Costruire Tool CLI Interattivi in Go con Bubbletea</title><link>https://manuelfedele.github.io/it/posts/building-interactive-cli-tools-in-go-with-bubbletea/</link><pubDate>Fri, 14 Nov 2025 10:30:00 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/building-interactive-cli-tools-in-go-with-bubbletea/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Bubbletea porta l&amp;rsquo;architettura Elm nel terminale, rendendo possibile costruire tool CLI ricchi e interattivi in Go con una gestione dello stato pulita. Questo articolo copre i fondamentali con un esempio pratico.
&lt;/div>

&lt;p>Se hai mai voluto costruire un&amp;rsquo;applicazione terminale che sembri più un&amp;rsquo;interfaccia vera che un muro di testo, l&amp;rsquo;ecosistema &lt;a href="https://github.com/charmbracelet" target="_blank" rel="noreferrer">charmbracelet&lt;/a> è la strada giusta. Lo uso per costruire tool DevOps interni, e l&amp;rsquo;esperienza da sviluppatore è eccellente. In questo articolo mostro come costruire un tool CLI interattivo usando &lt;a href="https://github.com/charmbracelet/bubbletea" target="_blank" rel="noreferrer">Bubbletea&lt;/a> e &lt;a href="https://github.com/charmbracelet/huh" target="_blank" rel="noreferrer">Huh&lt;/a>.&lt;/p></description></item><item><title>Gestire Infrastruttura AWS Multi-Account con Terraform Workspaces</title><link>https://manuelfedele.github.io/it/posts/multi-account-aws-terraform-workspaces/</link><pubDate>Mon, 22 Sep 2025 09:15:00 +0200</pubDate><guid>https://manuelfedele.github.io/it/posts/multi-account-aws-terraform-workspaces/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Gestire Terraform su più account AWS e ambienti senza duplicare il codice. Questo articolo copre il pattern workspace, il remote state, le assunzioni di ruolo cross-account e la struttura dei moduli che scala da 3 account a 30.
&lt;/div>

&lt;p>Quando gestisci infrastruttura su decine di account AWS, hai bisogno di pattern che scalino. In questo articolo condivido l&amp;rsquo;approccio che uso per gestire infrastruttura AWS multi-account e multi-ambiente usando Terraform workspaces, codice modulare e una strategia di tagging coerente.&lt;/p></description></item><item><title>Costruire un motore scacchistico - dalla valutazione della posizione alle tecniche di ricerca</title><link>https://manuelfedele.github.io/it/posts/evaluate-chess-position/</link><pubDate>Wed, 27 Nov 2024 17:33:00 +0000</pubDate><guid>https://manuelfedele.github.io/it/posts/evaluate-chess-position/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I motori scacchistici sono software affascinanti che combinano diversi concetti di informatica: valutazione della posizione, ricerca ad albero, generazione delle mosse e tecniche di ottimizzazione. Questa guida illustra come implementare un motore scacchistico, con particolare attenzione alla&amp;hellip;
&lt;/div>

&lt;p>I motori scacchistici sono software affascinanti che combinano diversi concetti di informatica: valutazione della posizione, ricerca ad albero, generazione delle mosse e tecniche di ottimizzazione. Questa guida illustra come implementare un motore scacchistico, con particolare attenzione alla valutazione della posizione e alle strategie di ricerca.&lt;/p></description></item><item><title>JWT Authentication in Go: HS256, RS256 e Pattern di Middleware</title><link>https://manuelfedele.github.io/it/posts/jwt-issuer-in-go/</link><pubDate>Wed, 27 Nov 2024 17:18:00 +0000</pubDate><guid>https://manuelfedele.github.io/it/posts/jwt-issuer-in-go/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I JWT non sono sessioni. Sono claim firmati e auto-contenuti che non possono essere revocati senza infrastruttura aggiuntiva. Capire questo tradeoff prima di scegliere JWT e&amp;rsquo; piu&amp;rsquo; importante di qualsiasi dettaglio implementativo. Questo post copre HS256 vs RS256, middleware di validazione corretto, revoca dei token con Redis e un endpoint JWKS per la verifica service-to-service.
&lt;/div>

&lt;p>I JWT sono ampiamente mal utilizzati. I team li usano per default perche&amp;rsquo; ogni tutorial li mostra, non perche&amp;rsquo; siano lo strumento giusto per il lavoro. Prima di scrivere codice, bisogna capire cosa sono davvero i JWT e cosa non sono.&lt;/p></description></item><item><title>L'Algoritmo di Dijkstra in Go: Implementazione, Ottimizzazione e Uso Reale</title><link>https://manuelfedele.github.io/it/posts/implementing-djikstra-algorithm-in-go/</link><pubDate>Wed, 27 Nov 2024 17:01:00 +0000</pubDate><guid>https://manuelfedele.github.io/it/posts/implementing-djikstra-algorithm-in-go/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I problemi di percorso minimo sui grafi compaiono costantemente nel platform engineering: routing di rete, risoluzione delle dipendenze, ottimizzazione dei percorsi in un service mesh e scheduling di pipeline CI si riducono tutti a trovare il percorso a costo minimo in un grafo diretto e pesato. L&amp;rsquo;algoritmo di Dijkstra e il cavallo di battaglia per questi problemi quando i pesi degli archi sono non negativi. Questo articolo copre una corretta implementazione in Go, l&amp;rsquo;ottimizzazione basata su heap che la rende pratica su grafi di grandi dimensioni, la ricostruzione del percorso e un caso d&amp;rsquo;uso realistico di risoluzione delle dipendenze.
&lt;/div>


&lt;h2 class="relative group">Rappresentazione del Grafo
 &lt;div id="rappresentazione-del-grafo" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#rappresentazione-del-grafo" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Una lista di adiacenza con ID di nodo interi e la scelta giusta per Dijkstra in Go. Le chiavi stringa sono comode per esempi piccoli ma aggiungono overhead di hashing inutile su grafi con migliaia di nodi. Rappresentiamo gli archi pesati come struct e memorizziamo il grafo come una slice di slice (indicizzata per ID nodo).&lt;/p></description></item><item><title>Monitoraggio della clipboard in Go: rilevamento e redazione di segreti</title><link>https://manuelfedele.github.io/it/posts/clipboard-watch-remove-accidentally-typed-passwords/</link><pubDate>Sun, 26 Nov 2023 11:29:46 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/clipboard-watch-remove-accidentally-typed-passwords/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Digitare accidentalmente una password nel campo sbagliato e lasciarla nella clipboard è un rischio di sicurezza reale. Un monitor della clipboard può rilevare i pattern di segreti comuni e redigerli automaticamente prima che vengano incollati dove non dovrebbero andare.
&lt;/div>

&lt;p>Questo articolo costruisce un clipboard watcher di qualita produzione in Go: rilevamento di segreti basato su regex, polling thread-safe con context cancellation, notifiche desktop alla redazione e configurazione del servizio di background a livello OS per macOS e Linux.&lt;/p></description></item><item><title>Inviare i log Lambda a OpenSearch tra account AWS diversi con Terraform</title><link>https://manuelfedele.github.io/it/posts/aws-opensearch-as-monitoring-tool/</link><pubDate>Wed, 12 Jul 2023 08:42:00 +0200</pubDate><guid>https://manuelfedele.github.io/it/posts/aws-opensearch-as-monitoring-tool/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 La centralizzazione dei log su piu account e un requisito fondamentale per qualsiasi platform team. Se le funzioni Lambda si trovano in un account AWS e gli strumenti di osservabilita in un altro, serve una pipeline production-grade che trasferisca i log tra account senza compromettere la sicurezza. Ecco la configurazione Terraform completa.
&lt;/div>

&lt;p>Ogni organizzazione AWS matura separa prima o poi i workload dai servizi condivisi in account distinti. Compute nell&amp;rsquo;Account A, OpenSearch nell&amp;rsquo;Account B. La sfida e far attraversare i log di CloudWatch quel confine tra account in modo affidabile, con IAM a minimo privilegio e senza credenziali hardcoded.&lt;/p></description></item><item><title>Design di package pulito in Go: Singola responsabilità e coesione</title><link>https://manuelfedele.github.io/it/posts/the-single-responsibility-principle/</link><pubDate>Tue, 21 Mar 2023 15:10:03 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/the-single-responsibility-principle/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 L&amp;rsquo;SRP in Go riguarda i confini dei package e le superfici esportate, non solo dividere i metodi in file diversi. Quando un package ha un solo motivo per cambiare, lo si può testare in isolamento, sostituire le implementazioni dietro un&amp;rsquo;interfaccia e ragionare sul suo comportamento senza leggere il resto del codebase.
&lt;/div>

&lt;p>Il Single Responsibility Principle (SRP) viene spesso enunciato come &amp;ldquo;una classe dovrebbe avere un solo motivo per cambiare.&amp;rdquo; In Go non esistono classi, ma il principio si applica con uguale forza ai package e ai tipi esportati al loro interno. Sbagliarlo produce un God service: un unico package che conosce il database, l&amp;rsquo;email, HTTP e la business logic tutti insieme. Applicarlo correttamente produce un codebase dove cambiare il provider email non richiede di toccare il layer del database.&lt;/p></description></item><item><title>Automazione Pianificata con GitHub Actions: Casi d'Uso DevOps Reali</title><link>https://manuelfedele.github.io/it/posts/schedule-github-action-with-cron/</link><pubDate>Sun, 12 Mar 2023 15:03:40 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/schedule-github-action-with-cron/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I trigger cron in GitHub Actions sono potenti per l&amp;rsquo;automazione che non dovrebbe richiedere un essere umano per attivarsi: audit notturni di vulnerabilità, controlli settimanali dei costi, alert di scadenza dei certificati. Questa è la guida pratica &amp;ndash; workflow reali, casi d&amp;rsquo;uso reali e le trappole da evitare.
&lt;/div>

&lt;p>La maggior parte dei tutorial su GitHub Actions tratta i trigger push e pull request. Il trigger &lt;code>schedule&lt;/code> riceve meno attenzione, ma è spesso dove vive l&amp;rsquo;automazione più preziosa. Un audit notturno delle dipendenze che apre una issue quando trova CVE. Un controllo settimanale dei costi che avvisa Slack quando la bolletta AWS sale. Un controllo dei certificati che ti avvisa prima che il certificato scada, non dopo. Niente di tutto questo richiede che un developer prema un pulsante.&lt;/p></description></item><item><title>Gestione dei Branch Git: Locale, Remoto e Pulizia del Repository</title><link>https://manuelfedele.github.io/it/posts/how-to-delete-git-branch-locally/</link><pubDate>Tue, 07 Mar 2023 17:14:30 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/how-to-delete-git-branch-locally/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 La gestione dei branch è una delle fonti più comuni di confusione ed errori nei workflow di team. I branch si accumulano, i remote tracking ref diventano obsoleti e le persone o eliminano la cosa sbagliata o non puliscono mai. Questo è il riferimento che vorrai salvare tra i preferiti.
&lt;/div>

&lt;p>Dopo qualche mese su un repository condiviso, la lista dei branch inizia a sembrare uno scavo archeologico. Ci sono branch di feature per ticket chiusi sei mesi fa, un &lt;code>hotfix-DO-NOT-DELETE&lt;/code> che nessuno osa toccare e una dozzina di ref &lt;code>origin/feature-*&lt;/code> per branch che non esistono più sul remote. Capire esattamente come branch locali, branch remoti e remote tracking ref si relazionano tra loro è la base per tenere tutto sotto controllo.&lt;/p></description></item><item><title>Annullare Modifiche in Git: reset, revert, restore e Quando Usarli</title><link>https://manuelfedele.github.io/it/posts/how-to-undo-most-recent-local-git-commit/</link><pubDate>Tue, 28 Feb 2023 17:09:02 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/how-to-undo-most-recent-local-git-commit/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Git ha quattro verbi principali per annullare le cose: restore, reset, revert e reflog. Scegliere quello sbagliato riscrive la storia che altri hanno già scaricato, oppure butta via lavoro che volevi conservare. Ecco il modello mentale per scegliere correttamente.
&lt;/div>

&lt;p>La domanda &amp;ldquo;come faccio a disfare questo?&amp;rdquo; ricorre continuamente, e la risposta dipende da una variabile critica: qualcun altro ha già scaricato il commit che vuoi annullare? Se sì, riscrivere la storia causa problemi ai tuoi colleghi. Se no, hai più opzioni. La mappa qui sotto ti porterà al comando giusto rapidamente, ma capire perché ogni comando funziona nel modo in cui funziona è ciò che fa la differenza in un incidente alle 2 di notte.&lt;/p></description></item><item><title>Design Pattern in Go: Implementazioni Idiomatiche</title><link>https://manuelfedele.github.io/it/posts/implement-desing-patterns-with-golang/</link><pubDate>Tue, 21 Feb 2023 13:16:06 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/implement-desing-patterns-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Go affronta i design pattern in modo diverso rispetto a Java o C++. Poiche Go usa la composizione invece dell&amp;rsquo;ereditarieta, e le funzioni sono valori di prima classe, molti pattern che richiedono elaborate gerarchie di classi nei linguaggi OOP si riducono a pochi costrutti idiomatici Go. Questo articolo mostra le implementazioni corrette, pronte per la produzione, e, altrettanto importante, quando non usare affatto un pattern.
&lt;/div>

&lt;p>I design pattern non sono una checklist. In Go, applicare pattern in stile Java porta rapidamente a codice che appare estraneo a ogni sviluppatore Go che lo legge. I pattern qui sotto sono presentati nella loro forma idiomatica Go, spesso molto piu semplice della versione da libro di testo.&lt;/p></description></item><item><title>NATS Messaging in Go: Core, JetStream e Pattern di Produzione</title><link>https://manuelfedele.github.io/it/posts/nats-messaging-with-golang/</link><pubDate>Mon, 13 Feb 2023 18:57:15 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/nats-messaging-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 NATS e&amp;rsquo; un sistema di messaggistica in un unico binario con latenza sub-millisecondo, costruito per i workload cloud-native. Non e&amp;rsquo; Kafka, e non e&amp;rsquo; Redis Streams. Sapere quando sceglierlo e cosa non sa fare e&amp;rsquo; importante quanto sapere come usarlo. Questo post copre core pub/sub, queue group, request/reply, JetStream, pull consumer e autenticazione.
&lt;/div>

&lt;p>Kafka, NATS, Redis Streams e RabbitMQ si descrivono tutti come &amp;ldquo;sistemi di messaggistica.&amp;rdquo; Non sono intercambiabili. Kafka e&amp;rsquo; ottimizzato per lo storage di event log ad alto throughput con replay a lungo termine. Redis Streams e&amp;rsquo; una buona scelta quando hai gia&amp;rsquo; Redis e hai bisogno di un consumer group leggero. RabbitMQ e&amp;rsquo; la scelta giusta per routing complesso e semantiche AMQP.&lt;/p></description></item><item><title>Risolvere il Sudoku in Go: Backtracking, Constraint Caching e Benchmark</title><link>https://manuelfedele.github.io/it/posts/build-a-sudoku-solver-in-golang/</link><pubDate>Wed, 01 Feb 2023 21:09:26 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/build-a-sudoku-solver-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Il Sudoku e un classico problema di soddisfacimento di vincoli (CSP). Le stesse tecniche algoritmiche &amp;ndash; backtracking con propagazione dei vincoli &amp;ndash; compaiono in sistemi di produzione per la pianificazione di job, l&amp;rsquo;allocazione di risorse e la validazione delle configurazioni. Capire come implementare e ottimizzare un solver Sudoku ti da un modello mentale concreto per affrontare questi problemi su larga scala.
&lt;/div>


&lt;h2 class="relative group">Rappresentazione del Problema
 &lt;div id="rappresentazione-del-problema" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#rappresentazione-del-problema" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Una griglia Sudoku e una matrice 9x9 di interi dove 0 rappresenta una cella vuota. Un array di dimensione fissa e il tipo giusto: risiede sullo stack, non ha overhead di allocazione e puo essere passato per valore per la semantica di snapshot durante il backtracking.&lt;/p></description></item><item><title>Comunicazione Real-Time in Go: TCP Socket, Message Framing e WebSocket</title><link>https://manuelfedele.github.io/it/posts/socket-messaging-with-golang/</link><pubDate>Sun, 29 Jan 2023 18:44:12 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/socket-messaging-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 TCP e un protocollo stream, non un protocollo a messaggi. Se leggi i byte in un buffer a dimensione fissa, troncherai silenziosamente i messaggi piu grandi di quel buffer. Hai bisogno del framing. Questo articolo copre il framing con prefisso di lunghezza, un server broadcast multi-client e il supporto WebSocket per i client browser.
&lt;/div>

&lt;p>La prima cosa che la maggior parte dei tutorial sui socket in Go sbaglia e il buffer. Leggere in &lt;code>make([]byte, 1024)&lt;/code> non e orientato ai messaggi. Un messaggio di 1025 byte viene diviso in due letture. Un messaggio di 512 byte e uno di 300 byte possono arrivare in una singola chiamata &lt;code>Read&lt;/code>. TCP e uno stream: devi aggiungere struttura sopra di esso.&lt;/p></description></item><item><title>Email Open Tracking con Go: Tracking Pixel, URL Univoci e GDPR</title><link>https://manuelfedele.github.io/it/posts/tracking-pixel-technology-email-golang/</link><pubDate>Sun, 22 Jan 2023 19:02:19 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/tracking-pixel-technology-email-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Un tracking pixel e un&amp;rsquo;immagine trasparente 1x1 incorporata in un&amp;rsquo;email HTML. Quando un client email renderizza l&amp;rsquo;immagine, invia una richiesta HTTP GET al server &amp;ndash; registrando l&amp;rsquo;evento di apertura. Usati correttamente, i tracking pixel alimentano le ricevute di lettura, la conferma di consegna e l&amp;rsquo;analisi del coinvolgimento per email transazionali e di marketing. Usati con superficialita, violano il GDPR e producono metriche fuorvianti. Questo articolo copre un&amp;rsquo;implementazione Go corretta per la produzione con URL univoci per destinatario, una discussione onesta su cosa misurano effettivamente i dati, e gli obblighi di conformita che non si possono ignorare.
&lt;/div>


&lt;h2 class="relative group">Come Funziona
 &lt;div id="come-funziona" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#come-funziona" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Il meccanismo e semplice, ma i dettagli contano per la precisione e la conformita.&lt;/p></description></item><item><title>Comunicare con Stockfish da Go: il protocollo UCI</title><link>https://manuelfedele.github.io/it/posts/evaluate-chess-position-with-golang/</link><pubDate>Thu, 19 Jan 2023 21:33:41 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/evaluate-chess-position-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Stockfish e il motore scacchistico piu forte al mondo. Comunicare con esso da Go tramite il protocollo UCI richiede circa 30 righe. Questo articolo mostra l&amp;rsquo;implementazione reale: avvio del processo, handshake UCI, input FEN, parsing della valutazione e una struct Engine completa e riusabile.
&lt;/div>

&lt;p>La versione originale di questo articolo chiamava metodi inesistenti come &lt;code>chess.NewEngine(&amp;quot;stockfish&amp;quot;)&lt;/code>, &lt;code>SetDifficulty&lt;/code> e &lt;code>Evaluate&lt;/code> sulla libreria &lt;code>notnil/chess&lt;/code>. Quella libreria e un motore per le regole degli scacchi &amp;ndash; non fa da wrapper a Stockfish in alcun modo. Comunicare con Stockfish richiede il protocollo UCI su stdin/stdout, che e esattamente cio che questo articolo illustra.&lt;/p></description></item><item><title>Memoizzazione in Go: Caching di Computazioni Costose nel Modo Corretto</title><link>https://manuelfedele.github.io/it/posts/the-memoization-technique/</link><pubDate>Mon, 16 Jan 2023 21:07:26 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/the-memoization-technique/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 La memoizzazione e la tecnica di ottimizzazione che consiste nel fare il caching del valore restituito da una funzione pura, in modo che le chiamate ripetute con gli stessi input saltino completamente la computazione. Si applica ogni volta che una funzione e costosa, deterministica e chiamata piu volte con gli stessi argomenti. Fatta correttamente in Go richiede un mutex, e nel codice moderno un wrapper generico la rende riutilizzabile su piu tipi.
&lt;/div>

&lt;p>La memoizzazione viene spesso introdotta con Fibonacci perche l&amp;rsquo;esplosione ricorsiva e facile da visualizzare. Ma le applicazioni reali in produzione sono altrove: controlli dei permessi che accedono a un database, lookup di configurazione su rete, o costose computazioni crittografiche. Questo post copre il quadro completo: dall&amp;rsquo;implementazione di base alla prevenzione delle data race, ai wrapper generici e all&amp;rsquo;invalidazione con time-to-live (TTL).&lt;/p></description></item><item><title>Trading algoritmico con Alpaca e Go: paper trading e dati in tempo reale</title><link>https://manuelfedele.github.io/it/posts/trading-with-alpaca-and-golang/</link><pubDate>Sun, 15 Jan 2023 19:24:09 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/trading-with-alpaca-and-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Alpaca offre trading commission-free e API-first con un ambiente di paper trading per testare le strategie in sicurezza. Questo articolo copre i pattern reali dell&amp;rsquo;SDK Go, il corretto piazzamento degli ordini, il recupero dei dati in tempo reale, una semplice strategia momentum e la gestione del rischio necessaria prima di andare live.
&lt;/div>

&lt;p>La versione originale di questo articolo chiamava funzioni come &lt;code>alpaca.PlaceOrder&lt;/code>, &lt;code>alpaca.GetQuote&lt;/code> e &lt;code>alpaca.ListTrades&lt;/code> come funzioni a livello di package. Nessuna di queste esiste nell&amp;rsquo;SDK corrente. La vera libreria usa una struct client. Questo articolo usa il pacchetto reale &lt;code>github.com/alpacahq/alpaca-trade-api-go/v3/alpaca&lt;/code>.&lt;/p></description></item><item><title>Elasticsearch in pratica: Indicizzazione, ricerca e rilevanza</title><link>https://manuelfedele.github.io/it/posts/a-quick-overview-of-elasticsearch/</link><pubDate>Fri, 13 Jan 2023 17:24:25 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/a-quick-overview-of-elasticsearch/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Elasticsearch non è solo un database con un campo di ricerca. È un motore di rilevanza distribuito costruito su indici invertiti, e capire questa distinzione cambia il modo in cui si progettano schemi, query e aggregazioni.
&lt;/div>

&lt;p>Ho usato Elasticsearch in produzione per log analytics, ricerca di prodotti e pipeline di recupero documenti. Gli stessi errori emergono ogni volta che un team lo tratta come un database relazionale. Questo articolo copre ciò che bisogna davvero sapere: mapping, semantica delle query, scoring di rilevanza e aggregazioni come funzionano realmente.&lt;/p></description></item><item><title>Testing in Go: Dai Unit Test ai Mock e ai Benchmark</title><link>https://manuelfedele.github.io/it/posts/unit-testing-in-golang/</link><pubDate>Mon, 09 Jan 2023 20:49:03 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/unit-testing-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 La filosofia di testing di Go e stdlib-first e table-driven. Raramente hai bisogno di un framework esterno. Il package &lt;code>testing&lt;/code>, combinato con le interfacce per la dependency injection e &lt;code>httptest&lt;/code> per HTTP, copre quasi tutto cio che incontrerai nei codebase di produzione.
&lt;/div>

&lt;p>Molti sviluppatori Go che vengono da Python o Java usano testify o gomock prima che ne abbiano effettivo bisogno. La libreria standard di Go e notevolmente completa per il testing. Questo post illustra i pattern che gli ingegneri Go esperti usano davvero: table-driven test con subtest, mock basati su interfacce, testing degli HTTP handler, benchmark e analisi della coverage.&lt;/p></description></item><item><title>git fetch vs git pull: Remote Tracking e Workflow con Rebase</title><link>https://manuelfedele.github.io/it/posts/what-is-the-difference-between-git-pull-and-git-fetch/</link><pubDate>Sun, 08 Jan 2023 17:16:40 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/what-is-the-difference-between-git-pull-and-git-fetch/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 &lt;code>git fetch&lt;/code> è sempre sicuro. &lt;code>git pull&lt;/code> è fetch più merge (o rebase), e quel secondo passaggio è dove le cose vanno storte. Capire la differenza cambia il modo in cui collabori sui branch condivisi.
&lt;/div>

&lt;p>La maggior parte dei developer impara prima &lt;code>git pull&lt;/code> e lo usa in modo riflesso. Funziona bene in isolamento, ma su un team con un branch condiviso attivo aggiunge silenziosamente commit di merge alla storia, può fallire a metà operazione se il working tree non è pulito e oscura ciò che è effettivamente arrivato dal remote. Sapere quando usare &lt;code>fetch&lt;/code> invece ti ridà il controllo.&lt;/p></description></item><item><title>Video Streaming in Go: Range Request HTTP, Segmenti HLS e FFmpeg</title><link>https://manuelfedele.github.io/it/posts/streaming-video-with-golang/</link><pubDate>Wed, 04 Jan 2023 21:23:20 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/streaming-video-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Il video streaming corretto in HTTP non riguarda il piping di byte. Riguarda le range request che permettono ai player di fare seeking, i segmenti HLS che abilitano il bitrate adattivo, e mantenere FFmpeg come sottoprocesso mentre Go gestisce HTTP. Fai bene queste tre cose e hai un server video funzionante.
&lt;/div>

&lt;p>&lt;code>http.ServeFile&lt;/code> gestisce effettivamente le range request correttamente per i file statici. Il problema sorge quando cerchi di costruire qualcosa di piu sofisticato: transcodifica al volo, live streaming, o segmentazione HLS. Questo articolo copre ogni scenario con codice funzionante, e spiega cosa gestisce e cosa non gestisce &lt;code>http.ServeFile&lt;/code>.&lt;/p></description></item><item><title>Servire Protocol Buffers con FastAPI: Endpoint Binari e gRPC Gateway</title><link>https://manuelfedele.github.io/it/posts/use-protobuf-with-fastapi/</link><pubDate>Wed, 04 Jan 2023 16:00:43 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/use-protobuf-with-fastapi/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 FastAPI e eccellente per lo sviluppo rapido di API. Protobuf e eccellente per payload binari compatti e tipizzati. Puoi combinarli senza alcuna magia di integrazione Pydantic: leggi i byte grezzi, parsali con la classe generata e restituisci bytes con il Content-Type corretto.
&lt;/div>

&lt;p>Se cerchi &amp;ldquo;FastAPI protobuf&amp;rdquo; troverai molti articoli che cercano di usare i modelli Pydantic come ponte alla serializzazione protobuf. Non esiste tale ponte in Pydantic. L&amp;rsquo;approccio corretto e piu semplice e diretto: gli endpoint FastAPI possono accettare e restituire bytes grezzi. La libreria Python di protobuf gestisce la codifica effettiva. Questo articolo illustra un&amp;rsquo;implementazione completa funzionante, la content negotiation e il testing.&lt;/p></description></item><item><title>Il package context di Go: Cancellazione, Timeout e Propagazione in Produzione</title><link>https://manuelfedele.github.io/it/posts/the-context-package/</link><pubDate>Tue, 03 Jan 2023 20:36:29 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/the-context-package/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Il package &lt;code>context&lt;/code> esiste per un motivo principale: la gestione del ciclo di vita delle goroutine. Fornisce un modo standard e componibile per propagare segnali di cancellazione, deadline e metadati request-scoped attraverso i confini delle API. Capire come funziona in produzione fa la differenza tra un servizio che si spegne pulitamente e uno che perde goroutine sotto carico.
&lt;/div>

&lt;p>Ogni servizio Go non banale usa &lt;code>context&lt;/code>. Lo si passa dagli HTTP handler alle query sul database, dagli interceptor gRPC alle chiamate API downstream. Ma molti ingegneri lo trattano come poco piu di una convenzione per soddisfare le firme delle funzioni. Questo post spiega come &lt;code>context&lt;/code> funziona davvero, dove fallisce silenziosamente quando viene mal utilizzato, e i pattern che contano in produzione.&lt;/p></description></item><item><title>Python Async/Await in Pratica: asyncio, FastAPI e Insidie Comuni</title><link>https://manuelfedele.github.io/it/posts/understand-async-await-in-python/</link><pubDate>Sun, 01 Jan 2023 14:50:35 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/understand-async-await-in-python/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Async/await non e&amp;rsquo; magia. E&amp;rsquo; multitasking cooperativo per lavoro I/O-bound, costruito su un event loop a thread singolo. Sbagliarlo non manda in crash il programma; lo rende silenziosamente piu&amp;rsquo; lento e difficile da debuggare. Questo post copre cosa fa davvero l&amp;rsquo;event loop, come usare asyncio correttamente, il modello async di FastAPI e gli errori che costano settimane ai team.
&lt;/div>

&lt;p>La sintassi &lt;code>async&lt;/code>/&lt;code>await&lt;/code> di Python e&amp;rsquo; arrivata in Python 3.5 ed e&amp;rsquo; diventata genuinamente pronta per la produzione in Python 3.7 con &lt;code>asyncio.run&lt;/code>. Oggi alimenta FastAPI, aiohttp e la maggior parte del moderno ecosistema async Python. Ma una grande frazione del codice async che vedo in giro ha bug sottili: &lt;code>await&lt;/code> mancante, chiamate a librerie bloccanti dentro funzioni async, o lavoro CPU-intensivo che blocca l&amp;rsquo;event loop.&lt;/p></description></item><item><title>Costruire un Bot Telegram in Rust con Teloxide</title><link>https://manuelfedele.github.io/it/posts/create-a-telegram-bot-with-rust/</link><pubDate>Sat, 31 Dec 2022 14:26:23 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/create-a-telegram-bot-with-rust/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Rust e una scelta insolita per un bot Telegram, ma i trade-off sono reali: un singolo binario linkato staticamente, immagini Docker sotto i 10MB e utilizzo di memoria che rimane stabile sotto carico. Teloxide e la libreria Telegram standard della community Rust e rende invisibile il plumbing async.
&lt;/div>

&lt;p>La maggior parte dei tutorial per bot Telegram sceglie Python o Node. Rust vale davvero la pena di essere considerato se ti importa della semplicita di deployment (un binario, nessun interprete), dell&amp;rsquo;impronta di memoria, o sei gia in un codebase Rust. Questo articolo illustra un bot completo usando &lt;code>teloxide&lt;/code>: comandi, inline keyboard, una macchina a stati multi-step e deployment in produzione.&lt;/p></description></item><item><title>Costruire API di produzione con FastAPI: Pydantic, dependency injection e deployment</title><link>https://manuelfedele.github.io/it/posts/create-webserver-with-fastapi-and-uvicorn/</link><pubDate>Fri, 30 Dec 2022 14:08:35 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/create-webserver-with-fastapi-and-uvicorn/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 FastAPI combina i type hint di Python con la documentazione OpenAPI automatica e performance vicine a quelle di Go. E diventato la scelta predefinita per le API Python. Questo articolo copre i pattern che contano in produzione: modelli Pydantic, dependency injection, background task e deployment multi-worker.
&lt;/div>

&lt;p>FastAPI non e un semplice wrapper attorno a Starlette. La combinazione di Pydantic v2 per la validazione, &lt;code>Depends()&lt;/code> per la dependency injection e la gestione delle richieste async-native lo rende il piu vicino equivalente Python a un framework HTTP tipizzato. La versione originale di questo articolo aveva una firma dell&amp;rsquo;handler errata e nessun contenuto di produzione. Questa e la ricostruzione.&lt;/p></description></item><item><title>Generator e yield in Python: pipeline efficienti in memoria</title><link>https://manuelfedele.github.io/it/posts/what-does-yield-keyword-do-in-python/</link><pubDate>Thu, 29 Dec 2022 10:19:25 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/what-does-yield-keyword-do-in-python/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Un generator è una sequenza lazy. Produce valori uno alla volta su richiesta invece di materializzare tutto in memoria. Per dataset di grandi dimensioni, API di streaming e pipeline di elaborazione dati, i generator sono il default corretto, non un&amp;rsquo;ottimizzazione da applicare dopo.
&lt;/div>

&lt;p>I generator Python sono una delle funzionalita più praticamente utili del linguaggio e una delle più sottoutilizzate dagli ingegneri che hanno imparato Python dai tutorial web. Questo articolo va oltre il &amp;ldquo;usa yield invece di return&amp;rdquo; e copre il quadro completo: il protocollo iteratore, le caratteristiche di memoria, &lt;code>yield from&lt;/code>, le pipeline di generator e casi d&amp;rsquo;uso reali di streaming.&lt;/p></description></item><item><title>Protocol Buffers in Go: Serializzazione, gRPC e Performance</title><link>https://manuelfedele.github.io/it/posts/use-protobuf-with-golang/</link><pubDate>Tue, 27 Dec 2022 18:48:44 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/use-protobuf-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Protocol Buffers offrono serializzazione binaria circa il 40% più compatta e 6 volte più veloce di JSON. Vale la pena del trade-off per il traffico interno tra microservizi. Non vale la pena per un&amp;rsquo;API REST pubblica che gli sviluppatori devono leggere con curl.
&lt;/div>

&lt;p>Protocol Buffers (protobuf) sono il formato di serializzazione binaria di Google. Il vantaggio è semplice: definisci lo schema dati una volta in un file &lt;code>.proto&lt;/code>, generi codice tipizzato in qualsiasi linguaggio e ottieni un formato wire compatto. Lo svantaggio è l&amp;rsquo;overhead degli strumenti e la perdita di leggibilità umana. Questo articolo illustra un setup completo in Go: la corretta API di marshaling, un servizio gRPC e un benchmark che confronta protobuf con JSON.&lt;/p></description></item><item><title>Costruire CLI in Go con Cobra: flag, sottocomandi e shell completion</title><link>https://manuelfedele.github.io/it/posts/create-command-line-application-with-golang/</link><pubDate>Tue, 20 Dec 2022 10:03:30 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/create-command-line-application-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Cobra e lo standard de-facto per CLI Go serie. kubectl, la GitHub CLI e Docker lo usano tutti. Se stai costruendo uno strumento a riga di comando con piu sottocomandi, flag tipizzati e shell completion, ecco come farlo correttamente.
&lt;/div>

&lt;p>Il parsing grezzo di &lt;code>os.Args&lt;/code> funziona per un singolo comando con un argomento posizionale. Nel momento in cui aggiungi un secondo sottocomando o un flag &lt;code>--dry-run&lt;/code>, stai reinventando la ruota. Cobra gestisce il parsing degli argomenti, la validazione dei flag, la generazione dei testi di help e la shell completion out of the box.&lt;/p></description></item><item><title>Deploy di un sito statico con Hugo e GitHub Actions: hosting a costo zero</title><link>https://manuelfedele.github.io/it/posts/create-website-with-gatsby-and-github-pages/</link><pubDate>Tue, 20 Dec 2022 09:49:01 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/create-website-with-gatsby-and-github-pages/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 I siti statici sono il modo più efficiente per pubblicare contenuti. Nessun server da gestire, nessun costo di runtime, nessuna sorpresa di scalabilità. Con Hugo e GitHub Actions ottieni un blog veloce e versionato, deployato automaticamente a ogni push, a costo effettivamente zero.
&lt;/div>


&lt;h2 class="relative group">Perché Hugo e non Gatsby o Next.js
 &lt;div id="perché-hugo-e-non-gatsby-o-nextjs" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#perch%c3%a9-hugo-e-non-gatsby-o-nextjs" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Gatsby ha avuto il suo momento, ma l&amp;rsquo;ecosistema si è spostato. Il progetto è stato acquisito, la manutenzione è rallentata e la maggior parte dei team che lo usavano è migrata a Next.js o a un generatore statico. Hugo occupa una nicchia diversa: non dipende da React, non richiede Node.js e compila migliaia di pagine in meno di un secondo. Se stai costruendo un blog o un sito di documentazione, e non una vera applicazione React, Hugo è lo strumento giusto.&lt;/p></description></item><item><title>Redis in Go con go-redis/v9: Caching, Pub/Sub e Pattern di Produzione</title><link>https://manuelfedele.github.io/it/posts/use-redis-with-golang/</link><pubDate>Mon, 19 Dec 2022 19:32:27 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/use-redis-with-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Redis non e&amp;rsquo; solo una cache. E&amp;rsquo; un server di strutture dati che parla TCP, persiste su disco, replica tra nodi e gestisce il fan-out pub/sub in un unico binario. Questo post spiega come usarlo correttamente da Go con go-redis/v9: pool di connessioni, gestione TTL, cache-aside pattern, sorted set per il rate limiting, pub/sub e pipeline.
&lt;/div>

&lt;p>La maggior parte dei team ricorre a Redis quando ha bisogno di una cache chiave-valore veloce, lo usa con &lt;code>SET&lt;/code>/&lt;code>GET&lt;/code> e si ferma li&amp;rsquo;. Questo significa perdere quasi tutto quello che Redis sa fare. Questo post copre le strutture dati e i pattern operativi che contano in produzione: configurazione corretta del connection pool, disciplina sui TTL, cache-aside pattern con i generics, liste come code, sorted set per il rate limiting a finestra scorrevole, pub/sub per il fan-out e pipeline atomiche.&lt;/p></description></item><item><title>Applicazioni desktop in Go con Fyne: dashboard mercato azionario</title><link>https://manuelfedele.github.io/it/posts/create-desktop-application-stock-market-data-golang/</link><pubDate>Mon, 19 Dec 2022 19:08:58 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/create-desktop-application-stock-market-data-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Fyne e il miglior toolkit UI cross-platform per Go. Un unico codebase compila su Windows, macOS e Linux, producendo un binario nativo senza dipendenze runtime. Questo articolo costruisce una vera dashboard per il mercato azionario, coprendo il sistema di widget di Fyne, il layout engine, le regole di thread safety per le goroutine e la distribuzione.
&lt;/div>


&lt;h2 class="relative group">Perche Fyne
 &lt;div id="perche-fyne" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#perche-fyne" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Le applicazioni desktop in Go sono storicamente state scomode. I binding CGo a GTK o Qt funzionano, ma la complessita di build e considerevole. Fyne adotta un approccio diverso: usa OpenGL per il rendering, mantenendo l&amp;rsquo;API in puro Go e il binario risultante completamente autonomo.&lt;/p></description></item><item><title>PostgreSQL JSONB: Schema flessibile, indicizzazione e quando usarlo</title><link>https://manuelfedele.github.io/it/posts/work-with-json-postgresql/</link><pubDate>Mon, 19 Dec 2022 18:20:30 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/work-with-json-postgresql/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 JSONB non è un sostituto degli schemi normalizzati. È uno strumento per dati genuinamente semi-strutturati dove la forma varia per riga e si ha bisogno di interrogare il contenuto. Usarlo con precisione evita commit prematuri allo schema. Usarlo ovunque significa aver reinventato un document store sopra un database relazionale.
&lt;/div>

&lt;p>Il tipo JSONB di PostgreSQL è una delle funzionalità più potenti e più abusate del database. Questo articolo copre i dettagli pratici: differenze di storage, operatori, indici GIN, funzioni di mutazione e i pattern dove JSONB guadagna il suo posto.&lt;/p></description></item><item><title>Costruire Servizi HTTP in Produzione con Go</title><link>https://manuelfedele.github.io/it/posts/how-to-create-a-webserver-in-golang/</link><pubDate>Sun, 11 Dec 2022 19:14:21 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/how-to-create-a-webserver-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 La libreria standard &lt;code>net/http&lt;/code> di Go è pronta per la produzione. Con il routing migliorato di Go 1.22+, il matching per metodo e pattern è integrato. Per la maggior parte dei servizi non serve un framework &amp;ndash; ma è necessario configurare correttamente timeout, graceful shutdown e middleware fin dall&amp;rsquo;inizio.
&lt;/div>

&lt;p>La maggior parte dei tutorial Go su HTTP mostra &lt;code>http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)&lt;/code> e finisce lì. Quel codice funzionerà, ma perderà goroutine sotto carico, si bloccherà per sempre su client lenti e si spegnerà in modo non controllato durante i deploy. Questo articolo mostra come appare davvero un servizio HTTP Go pronto per la produzione, usando solo la libreria standard per il core, con una nota su quando un router esterno vale la pena.&lt;/p></description></item><item><title>Interfacce Go in Pratica: Polimorfismo, Composizione e Testing</title><link>https://manuelfedele.github.io/it/posts/how-to-use-interfaces-in-golang/</link><pubDate>Sun, 11 Dec 2022 19:04:27 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/how-to-use-interfaces-in-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Le interfacce Go sono implicite. Non dichiari che un tipo implementa un&amp;rsquo;interfaccia. Se un tipo ha i metodi giusti, soddisfa l&amp;rsquo;interfaccia. Questa singola scelta di design rende le interfacce Go piu flessibili, piu componibili e piu potenti per il testing rispetto alle implementazioni di interfacce esplicite in Java o C#.
&lt;/div>

&lt;p>Le interfacce sono il meccanismo che Go usa per esprimere il polimorfismo, per disaccoppiare i consumer dai producer, e per rendere il codice testabile senza framework pesanti. Questo post tratta i pattern che contano nei codebase reali: polimorfismo con slice di interfacce, il design di &lt;code>io.Reader&lt;/code>/&lt;code>io.Writer&lt;/code>, composizione di interfacce, interfacce per i mock nei test, e il confine tra &lt;code>any&lt;/code> e i generics.&lt;/p></description></item><item><title>Il pattern Factory in Go: dependency inversion e servizi testabili</title><link>https://manuelfedele.github.io/it/posts/implement-factory-design-pattern-golang/</link><pubDate>Sun, 11 Dec 2022 18:57:13 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/implement-factory-design-pattern-golang/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Il pattern Factory in Go riguarda principalmente la costruzione basata su interfacce che abilita la dependency inversion e il testing. L&amp;rsquo;esempio degli animali va bene per imparare la sintassi. Questo articolo mostra la versione che conta in produzione: backend di storage, sender di notifiche e servizi testabili.
&lt;/div>

&lt;p>La versione originale di questo articolo aveva due paragrafi e un esempio con &lt;code>Dog.Speak()&lt;/code>. Questo copre la sintassi ma manca completamente il punto. Il pattern Factory in Go non riguarda la creazione di animali. Riguarda la scrittura di codice in cui il layer chiamante non ha bisogno di sapere o importarsi di quale implementazione concreta riceve.&lt;/p></description></item><item><title>Creare un tema Hugo da zero: layout, partial e template inheritance</title><link>https://manuelfedele.github.io/it/posts/create-template-hugo/</link><pubDate>Thu, 03 Nov 2022 14:57:41 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/create-template-hugo/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Questo tutorial mostra come creare un tema semplice in Hugo. Si presuppone familiarita con HTML, la riga di comando bash e Markdown. Vedremo come Hugo usa i template e come organizzarli per creare un tema. Non tratteremo l&amp;rsquo;uso dei CSS per lo stile.
&lt;/div>

&lt;div class="admonition relative overflow-hidden rounded-lg border-l-4 my-3 px-4 py-3 shadow-sm" data-type="note">
 &lt;div class="flex items-center gap-2 font-semibold text-inherit">
 &lt;div class="flex shrink-0 h-5 w-5 items-center justify-center text-lg">&lt;span class="relative block icon">&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">&lt;path fill="currentColor" d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z"/>&lt;/svg>
&lt;/span>&lt;/div>
 &lt;div class="grow">
 Nota
 &lt;/div>
 &lt;/div>&lt;div class="admonition-content mt-3 text-base leading-relaxed text-inherit">&lt;p>Questo tutorial e rivolto a Hugo v0.100+. Il sistema di layout e cambiato significativamente rispetto alle versioni piu vecchie. Se usi Hugo prima della v0.90, aspettati differenze nelle regole di lookup dei template, nella sintassi di configurazione e nel modo in cui vengono risolte le partial.&lt;/p></description></item><item><title>Poetry: No module named seed via app data</title><link>https://manuelfedele.github.io/it/posts/poetry-no-module-seed-via-app-data/</link><pubDate>Mon, 01 Nov 2021 15:15:47 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/poetry-no-module-seed-via-app-data/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Nel mio ultimo progetto ho usato &lt;strong>poetry&lt;/strong> per gestire le dipendenze e pacchettizzare il codice. Poetry offre tutti gli strumenti necessari per gestire i progetti in modo deterministico.
&lt;/div>

&lt;p>Nel mio ultimo progetto ho usato &lt;strong>poetry&lt;/strong> per gestire le dipendenze e pacchettizzare il codice.
Poetry mette a disposizione tutti gli strumenti necessari per gestire i propri progetti in modo deterministico.&lt;/p>
&lt;p>Dopo aver eseguito &lt;code>poetry init&lt;/code> in un progetto esistente, ho provato a far creare a poetry un ambiente virtuale aggiungendo la prima dipendenza. Ma quando ho eseguito &lt;code>poetry add twisted&lt;/code>, il processo si è bloccato con il seguente errore:&lt;/p></description></item><item><title>Amazon Echo Plus come speaker Bluetooth su Ubuntu 20.04</title><link>https://manuelfedele.github.io/it/posts/ubuntu-echo-plus-alexa-workaround-bluetooth-speaker/</link><pubDate>Tue, 14 Apr 2020 09:37:07 +0100</pubDate><guid>https://manuelfedele.github.io/it/posts/ubuntu-echo-plus-alexa-workaround-bluetooth-speaker/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Ho semplicemente scollegato i dispositivi, avviato un video YouTube sulla mia macchina Ubuntu e ripetuto i passaggi di accoppiamento descritti di seguito mentre l&amp;rsquo;audio era in riproduzione. A quel punto sono riuscito a inviare l&amp;rsquo;audio al mio Echo Plus.
&lt;/div>


&lt;h3 class="relative group">TLDR;
 &lt;div id="tldr" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#tldr" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h3>
&lt;p>Ho semplicemente scollegato i dispositivi, avviato un video YouTube sulla mia macchina Ubuntu e ripetuto i passaggi di accoppiamento descritti di seguito mentre l&amp;rsquo;audio era in riproduzione. A quel punto sono riuscito a inviare l&amp;rsquo;audio al mio Echo Plus.&lt;/p></description></item><item><title>Chi sono</title><link>https://manuelfedele.github.io/it/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://manuelfedele.github.io/it/about/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Head of AI Platforms e Cloud Architect. Costruisco infrastrutture AI su larga scala, progetto sistemi agentici e opero piattaforme cloud che gestiscono migliaia di servizi in più paesi.
&lt;/div>


&lt;h2 class="relative group">Cosa faccio
 &lt;div id="cosa-faccio" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#cosa-faccio" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Guido la practice AI Platforms in un grande gruppo assicurativo europeo, gestendo l&amp;rsquo;intero ciclo di vita dalla strategia e architettura fino alle operazioni in produzione.&lt;/p></description></item><item><title>Coaching</title><link>https://manuelfedele.github.io/it/coaching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://manuelfedele.github.io/it/coaching/</guid><description>&lt;div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">
 Sessioni di coaching 1:1 per ingegneri software che vogliono migliorare le proprie competenze — costruire sistemi AI, progettare infrastrutture cloud, o integrare strumenti come Claude Code nel lavoro quotidiano.
&lt;/div>


&lt;h2 class="relative group">A Chi È Rivolto
 &lt;div id="a-chi-è-rivolto" class="anchor">&lt;/div>
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#a-chi-%c3%a8-rivolto" aria-label="Ancora">#&lt;/a>
 &lt;/span>
 
&lt;/h2>
&lt;p>Sei un ingegnere software, tech lead o architetto che vuole:&lt;/p>
&lt;ul>
&lt;li>Capire come integrare concretamente AI e LLM nel lavoro di ingegneria — non demo, ma sistemi in produzione&lt;/li>
&lt;li>Aggiornarti sui pattern di platform engineering: AWS multi-account, Terraform su larga scala, ECS, pipeline serverless&lt;/li>
&lt;li>Imparare a usare Claude Code e gli strumenti di agentic AI per moltiplicare davvero la tua produttività&lt;/li>
&lt;li>Costruire cose come LLM gateway, agenti autonomi, pipeline di elaborazione documenti, o tooling di ottimizzazione dei costi&lt;/li>
&lt;li>Ricevere feedback onesto ed esperto sulla tua architettura, codice, o approccio&lt;/li>
&lt;/ul>
&lt;p>Lo faccio concretamente da anni — costruendo piattaforme AI su scala enterprise, scrivendo Go e Python in produzione, operando infrastruttura AWS su decine di account — non solo consigliando.&lt;/p></description></item></channel></rss>